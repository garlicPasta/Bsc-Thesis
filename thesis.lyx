#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrartcl
\begin_preamble
\usepackage{url}
\usepackage{graphicx}
\usepackage{titlesec}

\newcommand{\sectionbreak}{\clearpage}


\title{\includegraphics[width=0.6\textwidth]{picture/logo}\\
{\normalsize Bachelorarbeit am Institut für Informatik der Freien Universität Berlin}\\ Darstellung gigantischer Punktwolken auf Android Geräten}

\author{Jakob Krause\\
Matrikelnummer: xxxxxxx \\
jakobkrause@zedat.fu-berlin.de\\\\
Betreuung und Erstgutachten:\\ Prof. Dr. Marco Block-Berlitz\\
Zweitgutachten:\\ }
\date{\today}
\end_preamble
\options ngerman
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\listings_params "language=PHP,frame=lrbt,numbers=left,showstringspaces=false,breaklines=true,xleftmargin=15pt"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
maketitle 
\end_layout

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
vfill{}
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{page}{1} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Einführung 
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
Das Archaeocopter Projekt, welches 2012 von Dr.
 Benjamin Ducke und Prof.
 Dr.
 Marco Block-Berlitz ins Leben gerufen wurde, suchte nach einer Möglichkeit
 zur live Darstellung von dreidimensionalen Punkten während der Flüge des
 Archaeocopters.
\end_layout

\begin_layout Standard
Die Idee ist mit Hilfe der Darstellung feststellen zu können, für welche
 Bereiche des Objektes noch weitere Information gesammelt werden müssen
 um eine ausreichende dreidimensionale Darstellung zu erhalten.
\end_layout

\begin_layout Standard
Dadurch kann während des Fluges ermittelt werden, welche Bereiche schwer
 zu erkennen sind.
 
\end_layout

\begin_layout Standard
Die Darstellung sollte für ein Android Tablet implementiert werden.
\end_layout

\begin_layout Standard
Die Herausforderung bestand darin trotz der Limitierungen eines Tablets
 (wenig RAM, schwache GPU) Punktwolken mit mehreren Millionen Punkten flüssig
 darzustellen.
 Dabei sollte es möglich sein jederzeit neue Punkte in die bestehende Darstellun
g hinzuzufügen.
 Zur Zeit existieren nur bedingt geeignet Softwarelösungen für das Problem.
\end_layout

\begin_layout Subsection
Ziele
\end_layout

\begin_layout Standard
Hauptziel der Arbeit war es eine Datenstruktur zu implementieren welche
 es ermöglicht Punktwolken im 7 stelligen Bereich auf Android Systemen flüssig
 darzustellen.
 Die Punktwolke wird während des Fluges der Drohne berechnet und erweitert,
 daher muss die Datenstruktur dynamisch sein.
 Um mit der Anzahl an Punkten zurechtzukommen sollen Punkte abhängig von
 der Kameraposition geliefert werden.
 Also bei Sichtbarkeit und in einer sinnvollen Detailstufe.
\end_layout

\begin_layout Standard
Das System folgt der Client-Server Architektur.
 Daher muss eine effiziente Lösung für den Netzwerkverkehr gefunden werden.
\end_layout

\begin_layout Standard
Ein weiteres Ziel der Arbeit war es, die Architektur möglichst modular und
 plattformunabhängig zu gestalten um dadurch Austauschbarkeit und Wartbarkeit
 der einzelnen Komponenten zu gewährleisten.
 
\end_layout

\begin_layout Standard
Es sollte möglichst einfach sein, eine App für iOS oder ein anderes mobiles
 Betriebssystem nachzureichen.
 Des weiteren soll eine moderne Auswahl von Frameworks/Komponenten getroffen
 werden.
\end_layout

\begin_layout Standard
Die App sollte möglichst intuitiv benutzbar sein.
\end_layout

\begin_layout Section
Vergleichbare Arbeiten
\end_layout

\begin_layout Standard
Das Interesse an der Darstellung von großen Punktwolken ist durch das Aufkommen
 von modernen 3D Scanner und der 3D Rekonstruktion in den letzten Jahrzehnt
 stark gewachsen.
 Durch den Anstieg der Leistungsfähigkeit von Tablets wurde schon einige
 Ansätze für die Darstellung von sehr großen Punktwolken gemacht.
 Allerdings kann keine bestehende Arbeit alle Anforderungen erfüllen.
\end_layout

\begin_layout Subsection
KiwiViewer
\end_layout

\begin_layout Standard
KiwiViewer ist eine freie 'open-source' App zum erkunden von Punktwolken.
\end_layout

\begin_layout Standard
Die App ist fuer Android sowie iOS verfügbar.
 Multi-Touch Gestensteuerung wird unterstützt.
 
\end_layout

\begin_layout Standard
KiwiViewer 
\begin_inset CommandInset citation
LatexCommand cite
key "KiwiVierwer"

\end_inset

 bedient sich der 
\begin_inset Quotes eld
\end_inset

Point Cloud Library
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "PCL"

\end_inset

 für seine Kernfunktionen.
 Die Punktmenge wird entweder über eine SD-Karte, eMail oder URL geladen.
\end_layout

\begin_layout Paragraph

\emph on
Abgrenzung
\end_layout

\begin_layout Standard
Die App speichert die geladenen Punkte direkt auf dem Tablet.
 Modelle werden nicht vereinfacht.
 Daher treffen Modelle mit mehreren Millionen Punkten schnell an die Grenzen
 der GPU.
\end_layout

\begin_layout Subsection
QSplat Verfahren
\end_layout

\begin_layout Standard
Erste Vorschläge zur Darstellung von sehr großer Punktmengen wurden durch
 das QSplat 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2000:QMP:344779.344940"

\end_inset

 Verfahren gemacht.
 Die Punkteenge wird durch eine 'Multiresolution' Hierarchie auf Basis von
 'bounding spheres' modelliert.
 Abhängig von der Kameraposition wird die Struktur bis zu einer gewissen
 Tiefe (Detailstufe) durchlaufen.
 Das Verfahren kann modifiziert auch zum Streaming von Punktwolken genutzt
 werden 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2001:SQV:364338.364350"

\end_inset

 .
 
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Für HD Displays ist der Algorithmus zu rechenintensiv weil die Berechnung
 pro Display Punkt von der CPU erledigt wird.
 
\end_layout

\begin_layout Subsection
Multiresolution Octree
\end_layout

\begin_layout Standard
Moderne Ansätze benutzen einen Multiresolution Octree 
\begin_inset CommandInset citation
LatexCommand cite
key "Wand:2008:SSP:1363373.1363581"

\end_inset

.
 Diese Datenstruktur speichert die Punkte in ihren äußeren Knoten.
 Die inneren Knoten beinhalten gröbere Präsentationen von ihren direkten
 Kindern.
\end_layout

\begin_layout Standard
Die Punktdaten werden 'out-of-core' verwaltet, also dynamisch auf die Festplatte
 ausgelagert sobald der RAM erschöpft ist.
 Die Datenstruktur bietet den Vorteil, das Punkte dynamisch hinzugefügt
 werden können.
 
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Das Paper beschreibt ein Verfahren für Desktop Systeme.
 Eigenarten von Mobilen Geraten wie Netzwerkverkehr sind nicht berücksichtigt.
\end_layout

\begin_layout Subsection
Knn-Tree iOS
\end_layout

\begin_layout Standard
Eine weitere Möglichkeit ist ein Knn-Tree zu verwenden 
\begin_inset CommandInset citation
LatexCommand cite
key "VAST:VAST12:057-064"

\end_inset

.
 Allerdings mit der Beschränkung, dass die Punktmenge von Anfang an vollständig
 ist.
\end_layout

\begin_layout Standard
Diese Arbeit richtet sich besonders an die Darstellung auf mobilen Geräten.
 Die Datenstruktur selbst wird auf einem Server gespeichert.
 Knoten werden auf Anfrage eines Klienten übertragen.
\end_layout

\begin_layout Standard
Übertragende Knoten werden mit Hilfe eines LRU-Cache gespeichert.
 Die Implementierung erfolgte in C++ und OpenGl ES.
 Für die Netzwerkkommunikation wir 'http pipelining' sowie eine Wavletkompressio
n verwendet.
 
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Die Datenstruktur ist nicht dynamisch, also die Menge der Punkte muss von
 Anfang an fest stehen.
 Implementierung erfolgte in C++ und für iOS.
 Die Datenstruktur bietet den Vorteil das sie eine geringe Tiefe besitzt.
\end_layout

\begin_layout Section
Grundlagen und Frameworks
\end_layout

\begin_layout Standard
Im folgendem werden die Technologien, Begriffe und Frameworks vorgestellt
 welche in der Arbeit verwendet werden.
\end_layout

\begin_layout Itemize
wip design patterns
\end_layout

\begin_layout Subsection
Representational state transfer(REST)
\end_layout

\begin_layout Standard
wip
\end_layout

\begin_layout Subsection
Google Protocol Buffers
\end_layout

\begin_layout Standard
Dabei handelt es sich um eine plattform unabhängige Datenstruktur von Google.
 Die Datenstruktur wird in einem einheitlichen Format festgelegt.
 Nun kann für jede unterstützte Sprache Klassen generiert werden welche
 die Daten (de)serializieren.
 Das macht es möglich Clienten in anderen Sprachen zu schreiben.
 Ausserdem verringert es den Overhead merklich im Vergleich zu JSON oder
 XML.
 Nachteilig ist das die übertragenden Daten nicht ohne weiteres für einen
 Menschen lesbar sind.
\end_layout

\begin_layout Subsection
Open Graphics Library for Embedded Systems(OpenGL ES)
\end_layout

\begin_layout Standard
OpenGL Es ist eine sprachenunabhängige Programmierschnittstelle zur Entwicklung
 von 3D-Computergrafik.
 Die Spezifikation beschreibt eine vereinfachte Version der OpenGL-Spezifikation
, welche sich besonders für den Einsatz im Bereich von eingebetteten Systemen
 eignet.
 
\begin_inset CommandInset citation
LatexCommand cite
key "OpenGLESWiki"

\end_inset


\end_layout

\begin_layout Subsection
NanoHTTPD
\end_layout

\begin_layout Standard
NanoHTTPD ist ein schlanker HTTP Server.
 Da wir nur eine simple REST Api implementieren wollen ist Nano eine besser
 Wahl als zum Beispiel das überladene Apache Tomcat.
\end_layout

\begin_layout Standard
Das Project ist Open Source und wird aktiv auf github entwickelt.
\end_layout

\begin_layout Subsection
la4j
\end_layout

\begin_layout Standard
La4j ist eine offene Bibliothek für Lineare Algebra.
 Die Vektor Klasse der Bibliothek wird von dem Server verwendet.
\end_layout

\begin_layout Subsection
DEFLATE
\end_layout

\begin_layout Standard
wip
\end_layout

\begin_layout Itemize
günstige Kompression
\end_layout

\begin_layout Subsection
Volley
\end_layout

\begin_layout Standard
wip
\end_layout

\begin_layout Itemize
asynchrone http Anfragen für android
\end_layout

\begin_layout Section
Gewählter Lösungsansatz [WIP]
\end_layout

\begin_layout Subsection
Datenstrukturen
\end_layout

\begin_layout Subsubsection
Dynamic Octree
\end_layout

\begin_layout Standard
Octrees sind eine Datenstruktur um dreidimensionale Daten hierarchisch zu
 untergliedern.
 Sie wurde 1980 von Donal Maegher beschrieben.
 Octrees sind im dreidimensionalen das was im eindimensionalen Binarytrees
 oder im zweidimensionalen die Quadtrees sind.
\end_layout

\begin_layout Standard
Jeder Knoten repräsentiert einen Würfel welcher alle eingefügten 3D Punkte
 beinhaltet.
 Jeder innere Knoten besitzt immer 8 Kinder.
 Diese unterteilen den Raum des Knoten in 8 gleichgroße Octanten usw.
\end_layout

\begin_layout Standard
Die eigentlichen Punktdaten sind in den äußeren Knoten gespeichert.
 Äußeren Knoten können auch leer sein.
\end_layout

\begin_layout Standard
Der dynamische Octree unterstützt das inkrementelle einfügen von Punkten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename picture/Octree2.svg
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schematische Darstellung eines Octrees
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Multiresolution Octree(MRT)
\end_layout

\begin_layout Standard
Die Datenstruktur entstammt aus der Arbeit 
\begin_inset Quotes eld
\end_inset

Interactive Editing of Large Point Clouds
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Wand:2008:SSP:1363373.1363581"

\end_inset


\end_layout

\begin_layout Standard
Die Datenstruktur unterstützt einfügen, löschen und bietet unterschiedlich
 detaillierte Darstellungen des Ausgangsmodells.
 
\end_layout

\begin_layout Standard
Im folgendem wird die Datenstruktur vorgestellt.
\end_layout

\begin_layout Standard
Der Multiresolution Octree kann als eine spezielle Form des Octree verstanden
 werden.
 Wie beim Octree enthalten die äußeren Knoten alle Punkte.
\end_layout

\begin_layout Standard
Die Tiefe ergibt sich aus der Eigenschaft das kein Blatt mehr als 
\begin_inset Formula $n_{max}$
\end_inset

 Punkte beinhalten darf.
 Ist 
\begin_inset Formula $n_{max}$
\end_inset

 nach einer Einfüge Operation überschritten wird das Kind geteilt und die
 bestehenden Punkte werden auf die 8 neuen Kinder verteilt.
\end_layout

\begin_layout Standard
Die inneren Knoten sollen eine vereinfachte bzw.
 gröbere Version ihrer Kinder liefern.
\end_layout

\begin_layout Standard
Dafür haben diese eine dreidimensionale Rasterung gespeichert.
 Das Raster unterteilt den Würfel in 
\begin_inset Formula $k^{3}$
\end_inset

 gleichgroße Rasterzellen (z.B.
 
\begin_inset Formula $k\text{=128}$
\end_inset

).
 Jeder Rasterzelle hat zusätzlich ein Gewicht und ein Farbe als RGB Wert
 gespeichert.
 Das Raster selbst ist nicht als einfaches Array gespeichert, sondern als
 Hashtabelle um Speicherplatz zu sparen.
 Auf diese Art werden nur die Zellen gespeichert welche Punkte enthalten.
 Die Hashfunktion lautet
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
H(p)=(\left\lfloor \frac{x(p)}{cellLength}\right\rfloor ,\left\lfloor \frac{y(p)}{cellLength}\right\rfloor ,\left\lfloor \frac{z(p)}{cellLength}\right\rfloor )
\]

\end_inset


\end_layout

\begin_layout Standard
wobei die Koordinate von 
\begin_inset Formula $p$
\end_inset

 relativ zu Ursprung des Würfel ist.
 Die Variable
\begin_inset Formula $cellLength$
\end_inset

 entspricht der Länge einer Gitterzelle.
 Also:
\begin_inset Formula 
\[
cellLength=\frac{cube.length}{k}
\]

\end_inset


\end_layout

\begin_layout Standard
Zellen mit hohem Gewicht werden beim rendern größer gezeichnet.
 Sobald ein weiterer Punkt in die gleiche Zelle fällt wird das Gewicht inkrement
iert.
 
\end_layout

\begin_layout Standard
Der Farbwert entspricht dem des zuerst hinzugefügten Punktes der Zelle.
 Als Koordinate wird der Wert der Hashfunktion benutzt.
\end_layout

\begin_layout Paragraph
Einfügen eines Punktes
\end_layout

\begin_layout Standard
Beim Einfügen können 2 Fälle auftreten.
\end_layout

\begin_layout Subparagraph
1.
 Fall : Der Punkt liegt außerhalb der Wurzel.
 
\end_layout

\begin_layout Standard
Nun muss die bestehende Wurzel so lange erweitert werden bis sie den neuen
 Punkt mit einschließt.
\end_layout

\begin_layout Standard
Die Größe der Wurzel verdoppelt sich dabei bei jedem Schritt.
\end_layout

\begin_layout Standard
Sobald der Punkt in der Wurzel liegt tritt der 2.
 Fall ein.
\end_layout

\begin_layout Subparagraph
2.
 Fall : Der Punkt liegt innerhalb der Wurzel
\end_layout

\begin_layout Standard
Zuerst wird der Punkt der Rasterung hinzugefügt.
 Sprich das Gewicht in der entsprechende Rasterzelle wird um 1 erhöht und
 die Farbe des Punkten wird gegebenenfalls gespeichert.
 Dann wird ermittelt in welchem der Kinder der Punkt liegt.
 Nun wird der Vorgang beim Kind wiederholt bis ein äußerer Knoten erreicht
 wird.
 Falls die maximale Anzahl Punkte 
\begin_inset Formula $n_{max}$
\end_inset

 überschritten wurde muss der Knoten gespalten werden.
 Alle bisher gespeicherten Punkte und der neue Punkt werden nun auf die
 neuen Kinder verteilt.
\end_layout

\begin_layout Subsection
Architektur
\end_layout

\begin_layout Standard
Die Applikation folgt der Client-Server Architektur.
\end_layout

\begin_layout Subsubsection
Server
\end_layout

\begin_layout Standard
Der Http-Server bietet ein einfaches REST-Interface für den Klienten an.
 Allgemein hat er zwei Aufgaben.
 Einmal den MRT Proxy(siehe REST API) mit dem Klienten zu synchronisieren
 und zum anderen angefragte Punktmengen bereitzustellen.
\end_layout

\begin_layout Paragraph
REST API
\end_layout

\begin_layout Standard
Die API wurde mit Hilfe des NanoHTTPD Frameworks implementiert.
\end_layout

\begin_layout Standard
Prinzipiell wird bei jeder Anfrage eine Fallunterscheidung an dem 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 Parameter gemacht.
 Es gibt 2 Typen von Anfragen.
 Einmal kann nach dem MRT-Proxy gefragt werden.
\end_layout

\begin_layout Standard
Der MRT-Proxy ist im Prinzip ein Multuresolution Octree allerdings haben
 seine Knoten keine Punkte gespeichert, sondern Ids um beim Server die entsprech
enden Punkte anzufragen.
 Diese können entweder Original Punkte sein oder Punkte aus der Rasterung.
\end_layout

\begin_layout Standard
In diesem Fall wird ein Protocol Buffer Objekt von dem MRT erstellt.
 Die Spezifikation lautet wie folgt:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package DataAccesLayer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

option java_outer_classname = "MultiResTreeProtos";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

message MRTree{
\end_layout

\begin_layout Plain Layout

	required MRNode root = 1;
\end_layout

\begin_layout Plain Layout

	message MRNode {
\end_layout

\begin_layout Plain Layout

		required string id = 1;    
\end_layout

\begin_layout Plain Layout

		repeated double center = 2 [packed=true];         
\end_layout

\begin_layout Plain Layout

		required double cellLength = 3;         
\end_layout

\begin_layout Plain Layout

		required int32 pointCount = 4;         
\end_layout

\begin_layout Plain Layout

		required bool isLeaf = 5;         
\end_layout

\begin_layout Plain Layout

		repeated MRNode octant = 6;     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der 2.
 Typ Anfragen liefert Punkte an den Klienten aus.
 Bei dieser Anfrage wird vom Klienten immer ein Id mitgesendet.
\end_layout

\begin_layout Standard
Der Server greift über die MultiResolutionTree Klasse auf den entsprechende
 Knoten zu und generiert ein Protocol Buffer Objekt.
 Die Spezifikation des Objektes lautet:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package DataAccesLayer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

option java_outer_classname = "RasterProtos";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

message Raster{     
\end_layout

\begin_layout Plain Layout

	repeated Point3DRGB sample = 1;
\end_layout

\begin_layout Plain Layout

	message Point3DRGB{         
\end_layout

\begin_layout Plain Layout

		repeated float position = 1;         
\end_layout

\begin_layout Plain Layout

		repeated float color = 2;         
\end_layout

\begin_layout Plain Layout

		required int32 size = 3;     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es handelt sich also um eine Liste von Punkten mit Positions-, Farb- und
 einer Gewichtswerten (size).
\end_layout

\begin_layout Standard
Alle Daten werden bevor sie über das Netzwerk versendet werden, durch den
 DEFLATE Algorithmus komprimiert um den Netzwerkverkehr möglichst niedrig
 zu halten.
\end_layout

\begin_layout Paragraph
MultiResolution Tree(WIP)
\end_layout

\begin_layout Standard
Der MultiResolution Tree besteht aus 4 Klassen.
 Die Klasse 
\begin_inset Quotes eld
\end_inset

MultiResolutionTree
\begin_inset Quotes erd
\end_inset

 dient als Schnittstelle für alle äußeren Komponenten.
 Sie beherbergt einen Zeiger auf den Wurzelknoten des MRT.
 Des weiteren legt sie einen Index von den Knoten an um schnellen Zugriff
 zu ermöglichen.
 Zusätzlich existiert einer Factory Methode zum erstellen von Google Protocol
 Buffer Objekten.
\end_layout

\begin_layout Standard
Der Index wird in regelmäßigen Abständen aktualisiert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename picture/MultiResolutionTreeUML.png
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Multiresolution Tree UML
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Client(WIP)
\end_layout

\begin_layout Itemize
Programmiersprache Java
\end_layout

\begin_layout Itemize
'Volley'
\begin_inset CommandInset citation
LatexCommand cite
key "Volley"

\end_inset

 for asynchrone http Anfragen
\end_layout

\begin_layout Itemize
OpenGl ES für das Rendering
\end_layout

\begin_layout Itemize
UI
\end_layout

\begin_layout Section
Schwierigkeiten
\end_layout

\begin_layout Standard
-
\end_layout

\begin_layout Section
Auswertung
\end_layout

\begin_layout Standard
-
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "sources"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
