#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
\usepackage{url}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{pdfpages}



\title{\includegraphics[width=0.6\textwidth]{img/logo}\\
{\normalsize Bachelorarbeit am Institut für Informatik der Freien Universität Berlin}\\ DotViewer: Darstellung gigantischer Punktwolken auf Android Geräten}

\author{Jakob Krause\\
Matrikelnummer: xxxxxxx \\
jakobkrause@zedat.fu-berlin.de\\\\
Betreuung und Erstgutachten:\\ Prof. Dr. Marco Block-Berlitz\\
Zweitgutachten:\\ }
\date{\today}
\urlstyle{same}
\end_preamble
\options ngerman
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Java,frame=lrbt,numbers=left,showstringspaces=false,breaklines=true,xleftmargin=15pt,tabsize=2,basicstyle={\fontsize{9}{11}\ttfamily},keywordstyle={\color{blue}\ttfamily},stringstyle={\color{red}\ttfamily},commentstyle={\color{green}\ttfamily}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
maketitle 
\end_layout

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
vfill{}
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
includepdf[pages={1}]{pdf/erklaerung.pdf}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{page}{1} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Einleitung und Motivation
\end_layout

\begin_layout Standard
Das Interesse an der Darstellung von großen Punktwolken ist durch das Aufkommen
 von günstigen 3D-Scannern und der 3D-Rekonstruktion in den letzten Jahrzehnten
 stark gewachsen.
 Aufgrund der technologischen Entwicklungen in diesem Bereich ist es möglich,
 von kleinen Objekten wie einem Dinosaurier Schädel bis hin zu ganzen Städten
 Modelle in hoher Detailstufe digital zu erfassen.
 In der Denkmalpflege werden Objekte mittlerweile aus Routine abgescannt
 und archiviert.
 
\end_layout

\begin_layout Standard
Für gewöhnlich sind die erzeugten Modelle enorm groß und daher nicht ohne
 weiteres darstellbar.
 Die Modelle bestehen meist aus einer ungeordneten Sammlung von dreidimensionale
n Punkten mit Farbinformationen.
 Desktop-Lösungen verlassen sich zur Lösung des Problems auf Level-of-Detail
 (LOD) Konzepte kombiniert mit Out-of-core Verfahren und klugen Caching
 Strategien, um der hohen Datenmenge Herr zu werden.
 Durch das Aufkommen von leistungsstarken Smartphones entstand eine neue
 Plattform zum Darstellen von Modellen.
\end_layout

\begin_layout Standard
Daraus entstand eine Nachfrage durch Forschungsgruppen für eine mobile Applikati
on zum Betrachten großer Modelle.
 Die Applikation kann beispielsweise bei 3D-Rekonstruktion schnelles Feedback
 liefern, vereint mit den Vorzügen eines mobilen Gerätes.
 Dadurch können schnell unvollständige oder schwer zu erfassende Bereiche
 des Modells beim Scannen erkannt werden.
 Des Weiteren kann die Applikation zur Präsentation von Modellen eingesetzt
 werden.
\end_layout

\begin_layout Standard
Die Herausforderung bestand darin, trotz der Limitierungen eines Tablets
 durch seinen geringen Arbeitsspeicher und der relativ schwachen GPU, Punktwolke
n mit mehreren Millionen Punkten flüssig darzustellen.
 Dabei sollte es möglich sein, jederzeit neue Punkte in die bestehende Darstellu
ng hinzuzufügen.
 Zur Zeit existieren nur bedingt geeignet Softwarelösungen für das Problem.
\end_layout

\begin_layout Section
Archaeocopter und Archaeonautic Projekt
\begin_inset CommandInset label
LatexCommand label
name "sub:Archaeocopter-Projekt"

\end_inset


\end_layout

\begin_layout Standard
Das Archaeocopter Projekt, welches 2012 von Dr.
 Benjamin Ducke und Prof.
 Dr.
 Marco Block-Berlitz ins Leben gerufen wurde, hat es sich zum Ziel gesetzt,
 eine unbemanntes Flugobjekt (UAV) zu entwickeln, welches durch halb-autonome
 Flüge Archäologen bei ihrer Arbeit durch Luftaufnahmen unterstützt.
 Aus diesen Aufnahmen lassen sich durch 3D- Rekonstruktion Modelle generieren.
 Diese Technik wird auch zum Denkmalschutz angewandt.
\end_layout

\begin_layout Standard
Die Idee war es, aktuelle Verfahren aus der Computervision und künstlichen
 Intelligenz zusammen mit UAVs mit Kameras für die Datenerhebung einzusetzen.
 Das innovative Verfahren lässt sich auch unter Wasser einsetzen.
 Offiziell ging das Projekt im September 2012 mit Unterstützung von Prof.
 Dr.
 Raúl Rojas von Berlin's Freier Universität an den Start.
\end_layout

\begin_layout Standard
Diese Arbeit ist in Zusammenarbeit mit dem Projekt entstanden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/slider008.jpg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ein UAV scannt die Umgebung von ??? ab
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Bilder
\end_layout

\end_inset


\end_layout

\begin_layout Section
Ziele
\end_layout

\begin_layout Standard
Ziel dieser Arbeit ist es, eine mobile Applikation für das Android Betriebssyste
m zu entwickeln, welche in der Lage ist, Punktwolken mit mehreren Millionen
 Punkten performant darzustellen.
 Dabei soll es möglich sein, Punkte in die bestehende Darstellung zur Laufzeit
 hinzuzufügen.
\end_layout

\begin_layout Standard
Ein weiteres Ziel der Arbeit ist es, die Architektur möglichst modular und
 plattformunabhängig zu gestalten, um dadurch Austauschbarkeit und Wartbarkeit
 der einzelnen Komponenten zu gewährleisten.
 Es sollte möglichst einfach sein, eine Applikation für iOS oder ein anderes
 mobiles Betriebssystem nachzureichen.
 Des Weiteren soll eine moderne Auswahl von Frameworks getroffen werden.
 Dabei soll die Applikation möglichst intuitiv benutzbar sein.
\end_layout

\begin_layout Standard
Der Quellcode soll nach Abschluss dieser Arbeit über die Entwicklungsplattform
 github
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

www.github.com
\end_layout

\end_inset


\end_layout

\end_inset

 frei zugänglich gemacht werden.
\end_layout

\begin_layout Chapter
Theorie und verwandte Arbeiten
\begin_inset CommandInset label
LatexCommand label
name "sec:Theorie"

\end_inset


\end_layout

\begin_layout Standard
In diesem Kapitel werden Grundlagen zum Verstehen der Arbeit und des Kontextes
 vorgestellt.
 Es wird eine kurze Einführung in die 3D-Rekonstruktion gemacht.
 Des Weiteren werden Punktwolken sowie deren Repräsentationen diskutiert.
 Anschließend werden bestehende Arbeiten diskutiert.
 Zum Abschluss werden genutzte Entwurfsmuster und Architekturstille vorgestellt.
\end_layout

\begin_layout Section
Einführung in die 3D-Rekonstruktion
\end_layout

\begin_layout Standard
Die Idee, aus einer Folge von Bildern ein 3D-Modell zu errechnen, ist eines
 der Kernthemen der Computervision.
 Verwendungen dieser Technik sind vielfältig und finden sich in der Wissenschaft
 und Wirtschaft wieder.
 Anwendungen existieren zum Beispiel in der Robotik 
\begin_inset CommandInset citation
LatexCommand cite
key "klimentjew2008grundlagen"

\end_inset

, in welcher mit Hilfe eines Stereokamerasystems die Position des Roboters
 innerhalb seiner Umgebung feststellbar ist.
 Ein weiteres Feld ist die Archäologie und der Denkmalsschutz.
 Ein Beispiel dafür ist das Archaeocopter Projekt.
\end_layout

\begin_layout Standard
Allgemein kann man zwischen aktiver und passiver Rekonstruktion 
\begin_inset CommandInset citation
LatexCommand cite
key "ladikos2011real"

\end_inset

 unterscheiden.
 Die beiden Verfahren werden im Anschluss kurz vorgestellt.
\end_layout

\begin_layout Subsection
Aktive Rekonstruktion
\end_layout

\begin_layout Standard
Bei aktiver Rekonstruktion wird aktiv mit einem Sensor das Objekt abgetastet,
 um die Struktur zu ermitteln.
 3D-Scanner sind ein Vertreter dieser Gattung.
 Im Grunde sind sie der Kamera ähnlich.
 Genau wie diese besitzen sie ein Sichtfeld.
 Allerdings liefern sie statt Farbwert Abstandswert von ihrem Sichtfeld.
 Die Abstandswerte können unter anderem mit Hilfe einer Time-of-Flight Camera
 oder der Triangulierungsmethode ermittelt werden.
\end_layout

\begin_layout Standard
Bei einer Time-of-Flight Kamera 
\begin_inset CommandInset citation
LatexCommand citep
key "li2014time"

\end_inset

 wird ein modulierter Lichtstrahl versendet.
 Aus der Dauer bis der Strahl nach der Reflexion ihren Ausgangspunkt erreicht,
 kann die Entfernung ermittelt werden.
 Diese Methode ist bei nahen und feinen Objekten ungenau, weil die Zeit
 nur zu einer gewissen Genauigkeit gemessen werden kann.
 Die Auflösung erreichen in etwa 320x240 Pixel.
 Vorteilhaft sind die hohen Bildraten von bis zu 160 Bildern pro Sekunde.
\end_layout

\begin_layout Standard
Bei der Triangulierungsmethode wird von einem Laser ein Punkt auf das Objekt
 projizieren.
 Dieser Punkt wird von einer Kamera erfasst.
 In Abhängigkeit von der Entfernung erscheint der Laserpunkt im Sichtfeld
 der Kamera.
 Um das Verfahren zu beschleunigen, kann statt einem Punkt eine Linie verwendet
 werden (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TriangulierungBild"

\end_inset

).
\end_layout

\begin_layout Standard
Die Methode ist sehr genau und daher für Skulpturen gut geeignet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/scanner-head-and-david-head-s.jpg
	width 63text%

\end_inset


\begin_inset Graphics
	filename img/david-classic-leftlight-s.jpg
	width 36text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:TriangulierungBild"

\end_inset

Links: Anwendung der Triangulierungsmethode mit Hilfe einer Scanline beim
 
\begin_inset Quotes gld
\end_inset

The Digital Michelangelo
\begin_inset Quotes grd
\end_inset

 Projekt, Rechts: Das Ergebnis des Scanvorganges (Abb.
 aus 
\begin_inset CommandInset citation
LatexCommand citep
key "MichelangeloProject"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Passive Rekonstruktion
\end_layout

\begin_layout Standard
Unter passiver Rekonstruktion versteht man Methoden, welche nicht aktiv
 eine Szene abtasten, sondern vorhandene photometrische Informationen (z.B.
 Fotos) nutzen, um die Tiefe zu berechnen.
 Das Stereo-Verfahren 
\begin_inset CommandInset citation
LatexCommand citep
key "ladikos2011real"

\end_inset

 ist eines der ersten in diesem Feld.
 Ausgehend von zwei auf der x-Achse verschobenen Bildern einer Szene gilt
 es Punktpaare zwischen den beiden Bildern zu finden.
 Um das zu vereinfachen sucht man nach einer Abbildung von Punkten aus Bild
 1 zu Bild 2.
 Aufgrund der Verschiebung der Bilder auf der x-Achse kann man durch Epipolargeo
metrie die Tiefe der Punkte berechnen.
\end_layout

\begin_layout Subsection
VisualSFM
\end_layout

\begin_layout Standard
Bei VisualSFM
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://ccwu.me/vsfm/
\end_layout

\end_inset

.
 Aufg.
 am 24.05.2016
\end_layout

\end_inset

 handelt es sich um ein 3D-Rekonstruktionssystem.
 Es verfügt über eine grafische Benutzeroberfläche und zeichnet sich durch
 Skalierbarkeit aus auf Grundlage der Nutzung von nVidia oder ATI Grafikkarten
 des Computers.
 Entwickelt wurde das Programm von dem Studenten Changchang Wu
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://ccwu.me/
\end_layout

\end_inset

.
 Aufg.
 am 24.05.2016
\end_layout

\end_inset

, welcher mittlerweile bei Google beschäftigt ist.
 VisualSFM wird von dem Archaeocopter Projekt zur 3D-Rekonstruktion verwendet.
\end_layout

\begin_layout Section
Minimum Bounding-Box
\end_layout

\begin_layout Standard
In der Geometrie versteht man unter einer Minimum Bounding-Box ein Rechteck(2D)
 oder Box(3D) welches eine Menge von Punkten umschließt.
 Dabei ist der die Fläche bzw.
 das Volumen minimal.
\end_layout

\begin_layout Section
Repräsentationen von Punktwolken
\end_layout

\begin_layout Standard
Punkt basierende geometrische Oberflächen können als Stichprobenmenge einer
 kontinuierlichen Oberfläche verstanden werden.
 Dabei entstehen dreidimensionale Raumkoordinaten 
\begin_inset Formula $p_{i}\text{\in\mathbb{R}}^{3}$
\end_inset

.
 Oft existieren noch weitere Daten zu dem Punkt, wie eine Normale 
\begin_inset Formula $n_{i}$
\end_inset

 oder eine Farbe 
\begin_inset Formula $c_{i}$
\end_inset

.
 Eine Punktwolke 
\begin_inset Formula $S$
\end_inset

 ist eine Menge solcher Punkte.
 Im folgenden wird eine Auswahl von Ansätze vorgestellt und für das Projekt
 evaluiert.
\end_layout

\begin_layout Subsection
QSplat Verfahren
\end_layout

\begin_layout Standard
Erste Vorschläge zur Darstellung von sehr großen Punktmengen wurden durch
 das QSplat Verfahren gemacht 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2000:QMP:344779.344940"

\end_inset

.
 Splat bedeutet Klecks wie von Farbklecks.
\end_layout

\begin_layout Standard
Die Punktmenge wird durch eine Hierarchie auf Basis von Kugeln modelliert.
 Jede Kugel repräsentiert einen Knoten in einem Binärbaum.
 Jeder Knoten enthält den Mittelpunkt seiner Kugel, den Radius, die Normale
 und die Breite des Normalen Kegels und optional eine Farbe.
 Die Datenstruktur wird zu Beginn erstellt.
 Der Konstruktionsalgorithmus kann entweder auf einer Punktwolke oder besser
 einem triangulierten Modell angewendet werden.
 Bei letzterem ist es leichter, die Normalen zu berechnen.
 Für den Radius der Kugeln wird die Länge der längsten anliegenden Kante
 gewählt.
 Mit Hilfe folgendem Algorithmus kann nun die Datenstruktur erstellt werden:
\end_layout

\begin_layout Standard
\align left
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

BuildTree(vertices[begin..end]) { 
\end_layout

\begin_layout Plain Layout

	if (begin == end) 
\end_layout

\begin_layout Plain Layout

		return Sphere(vertices[begin]) 
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout
\align left

		midpoint = PartitionAlongLongestAxis(vertices[begin..end]) 		
\end_layout

\begin_layout Plain Layout
\align left

		leftsubtree  = BuildTree(vertices[begin..midpoint]) 
\end_layout

\begin_layout Plain Layout
\align left

		rightsubtree = BuildTree(vertices[midpoint+1..end]) 
\end_layout

\begin_layout Plain Layout
\align left

		return BoundingSphere(leftsubtree, rightsubtree) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sobald die Datenstruktur aufgebaut ist, kann die Punktmenge gezeichnet werden
 mit folgendem Algorithmus:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

TraverseHierarchy(node) { 
\end_layout

\begin_layout Plain Layout

	if (node not visible) 
\end_layout

\begin_layout Plain Layout

		skip this branch of the tree 
\end_layout

\begin_layout Plain Layout

	else if (node is a leaf node) 
\end_layout

\begin_layout Plain Layout

		draw a splat 
\end_layout

\begin_layout Plain Layout

	else if (benefit of recursing further is too low) 
\end_layout

\begin_layout Plain Layout

		draw a splat 
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		for each child in children(node) 
\end_layout

\begin_layout Plain Layout

			TraverseHierarchy(child) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zuerst wird getestet, ob die Kugel des Knotens sichtbar ist.
 Dafür wird getestet, ob die Kugel in dem View-Frustum liegt.
 Falls nicht, muss der Knoten samt seiner Kinder nicht beachtet werden und
 die Rekursion wird abgebrochen.
 QSplat führt auch Backface-Culling aus mit Hilfe der Normalen Kegel.
\end_layout

\begin_layout Standard
Anhand der Größe der projizierten Kugel auf die View-Ebene wird entschieden,
 ob die Rekursion fortgesetzt wird.
 Überschreitet diese einen gewissen Schwellenwert, wird die Rekursion beendet
 und der aktuelle Knoten wird gezeichnet.
 
\end_layout

\begin_layout Standard
Das Verfahren kann modifiziert auch zum Streaming von Punktwolken genutzt
 werden 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2001:SQV:364338.364350"

\end_inset

 .
 
\end_layout

\begin_layout Standard
Für HD-Displays ist der Algorithmus zu rechenintensiv, weil die Berechnung
 pro Pixel von der CPU erledigt wird.
\end_layout

\begin_layout Subsection
Octree
\end_layout

\begin_layout Standard
Octrees sind eine Datenstruktur, um dreidimensionale Daten hierarchisch
 zu untergliedern.
 Sie wurde 1980 von Donal Maegher beschrieben 
\begin_inset CommandInset citation
LatexCommand citep
key "meagher1982geometric"

\end_inset

.
 Octrees sind analog im Dreidimensionalen zu Quadtrees im Zweidimensionalen.
\end_layout

\begin_layout Standard
Jeder Knoten repräsentiert einen Würfel, welcher alle in den Knoten eingefügten
 3D-Punkte beinhaltet.
 Jeder innere Knoten besitzt immer 8 Kinder.
 Diese unterteilen den Würfel des Knotens in 8 gleich große Oktanten usw.
 (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Octree"

\end_inset

)
\end_layout

\begin_layout Standard
Die eigentlichen Punktdaten sind in den äußeren Knoten gespeichert.
 Äußere Knoten können auch leer sein.
\end_layout

\begin_layout Standard
Der Octree unterstützt das Einfügen von Punkten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/Octree2.svg
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Octree"

\end_inset

Schematische Darstellung eines Octrees (Abb aus.
 
\begin_inset CommandInset citation
LatexCommand citep
key "OctreeWiki"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Multiresolution Octree
\begin_inset CommandInset label
LatexCommand label
name "sub:Multiresolution-Octree"

\end_inset


\end_layout

\begin_layout Standard
Die Datenstruktur entstammt aus der Arbeit 
\begin_inset Quotes eld
\end_inset

Interactive Editing of Large Point Clouds
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Wand:2008:SSP:1363373.1363581"

\end_inset

.
 Die Datenstruktur unterstützt Einfügen, Löschen und bietet unterschiedlich
 detaillierte Darstellungen des Ausgangsmodells.
 Im Folgenden wird die Datenstruktur vorgestellt.
\end_layout

\begin_layout Standard
Der Multiresolution Octree(MRT) kann als eine spezielle Form des Octree
 verstanden werden.
 Wie beim Octree enthalten die äußeren Knoten alle Punkte.
 Die Tiefe ergibt sich aus der Eigenschaft, dass kein Blatt mehr als 
\begin_inset Formula $n_{max}$
\end_inset

 Punkte beinhalten darf.
 Ist 
\begin_inset Formula $n_{max}$
\end_inset

 nach einer Einfüge-Operation überschritten, wird das Kind geteilt und die
 bestehenden Punkte werden auf die 8 neuen Kinder verteilt.
\end_layout

\begin_layout Standard
Die inneren Knoten sollen eine vereinfachte bzw.
 gröbere Version ihrer Kinder liefern.
 Dafür haben diese eine dreidimensionale Rasterung gespeichert.
 Das Raster unterteilt den Würfel in 
\begin_inset Formula $k^{3}$
\end_inset

 gleich große Rasterzellen (z.B.
 
\begin_inset Formula $k\text{=128}$
\end_inset

).
 Jede Rasterzelle hat zusätzlich ein Gewicht und eine Farbe als RGB-Wert
 gespeichert.
 Das Raster selbst ist nicht als einfaches Array gespeichert, sondern als
 Hashtabelle, um Speicherplatz zu sparen.
 Auf diese Art werden nur die Zellen gespeichert, welche Punkte enthalten.
 
\end_layout

\begin_layout Standard
Zellen mit hohem Gewicht werden beim Rendern größer gezeichnet.
 Sobald ein weiterer Punkt in die gleiche Zelle fällt, wird das Gewicht
 inkrementiert.
 
\end_layout

\begin_layout Standard
Der Farbwert entspricht dem des zuerst hinzugefügten Punktes der Zelle.
 
\end_layout

\begin_layout Paragraph
Einfügen eines Punktes
\end_layout

\begin_layout Standard
Beim Einfügen können zwei Fälle auftreten.
\end_layout

\begin_layout Subparagraph
1.
 Fall : Der Punkt liegt außerhalb der Wurzel.
 
\end_layout

\begin_layout Standard
Nun muss die bestehende Wurzel so lange erweitert werden, bis sie den neuen
 Punkt mit einschließt.
 
\end_layout

\begin_layout Standard
Die Breite sowie Höhe der Wurzel verdoppelt sich dabei in jedem Schritt.
\end_layout

\begin_layout Standard
Sobald der Punkt in der Wurzel liegt, tritt der 2.
 Fall ein.
\end_layout

\begin_layout Subparagraph
2.
 Fall : Der Punkt liegt innerhalb der Wurzel
\end_layout

\begin_layout Standard
Zuerst wird der Punkt der Rasterung hinzugefügt.
 Sprich, das Gewicht in der entsprechende Rasterzelle wird um 1 erhöht und
 die Farbe des Punkten wird gegebenenfalls gespeichert.
 Dann wird ermittelt, in welchem der Kinder der Punkt liegt.
 Nun wird der Vorgang beim Kind wiederholt, bis ein äußerer Knoten erreicht
 wird.
 Falls die maximale Anzahl Punkte 
\begin_inset Formula $n_{max}$
\end_inset

 überschritten wurde, muss der Knoten gespalten werden.
 Alle bisher gespeicherten Punkte und der neue Punkt werden nun auf die
 neuen Kinder verteilt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/img-003.ppm
	width 70text%
	scaleBeforeRotation

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/img-004.ppm
	width 70text%

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Abb.
 Links: Die Rasterung ist schematisch dargestellt, Rechts: Das Schema nach
 dem einfügen eines weiteren Punkten (Abb.
 aus 
\begin_inset CommandInset citation
LatexCommand citep
key "Wand:2008:SSP:1363373.1363581"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Moving Least-Squares Surfaces
\end_layout

\begin_layout Standard
Das Moving-Least-Squares (MLS) Verfahren wurde von Levin 1998 vorgestellt
 
\begin_inset CommandInset citation
LatexCommand citep
key "levin1998approximation"

\end_inset

.
 Das Verfahren wurde erstmals 2001 durch Alexa zur Darstellung von Punktwolken
 benutzt 
\begin_inset CommandInset citation
LatexCommand citep
key "Alexa:2001:PSS:601671.601673"

\end_inset

.
 Die Arbeit wird im Folgenden kurz vorgestellt.
 Die Grundidee der Arbeit ist, dass die gegebene Menge Punkte 
\begin_inset Formula $S$
\end_inset

 indirekt eine Oberfläche 
\begin_inset Formula $S_{A}$
\end_inset

 definiert.
 Es wird eine Projektion 
\begin_inset Formula $\phi:U\rightarrow\mathbb{R}^{3}$
\end_inset

 vorgestellt, welche einen beliebigen Punkt aus der Umgebung 
\begin_inset Formula $U$
\end_inset

 von 
\begin_inset Formula $S$
\end_inset

 auf eine Oberfläche 
\begin_inset Formula $S_{A}$
\end_inset

, welche das Objekt lokal beschreibt, projiziert.
 Alle Punkte, die auf sich selbst abbilden, ergeben die abgeschätzte Oberfläche
 
\begin_inset Formula $S_{A}$
\end_inset

: 
\begin_inset Formula 
\[
S_{A}:=\{x\in\mathbb{R}^{3}|\phi(x)=x\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $U$
\end_inset

 kann man als eine Vereinigung von Kugeln mit Radius 
\begin_inset Formula $r_{k}$
\end_inset

, dessen Mittelpunkt ein Punkt aus 
\begin_inset Formula $S$
\end_inset

 ist, beschreiben:
\begin_inset Formula 
\[
U:=\bigcup_{i}\{x\in\mathbb{R}^{3}|\lVert x-p_{i}\rVert<r_{K}\}
\]

\end_inset


\end_layout

\begin_layout Standard
Die Projektion eines Punktes 
\begin_inset Formula $r$
\end_inset

 wird in 3 Schritten ermittelt.
\end_layout

\begin_layout Enumerate
Ermittle eine Referenzebene 
\begin_inset Formula $H=\{x|\langle n,x\rangle-D=0,x\in\mathbb{R}^{3}\},n\in\mathbb{R}^{3},\lVert n\rVert=1$
\end_inset

 durch Minimierung des Ausdrucks,
\begin_inset Formula 
\[
\sum_{i=1}^{N}(\langle n,p_{i}\rangle-D)^{2}\Theta(\lVert p_{i}-q\rVert)
\]

\end_inset

 wobei 
\begin_inset Formula $q$
\end_inset

 die Projektion von 
\begin_inset Formula $r$
\end_inset

 auf 
\begin_inset Formula $H$
\end_inset

 ist.
 Bei 
\begin_inset Formula $\Theta$
\end_inset

 handelt es sich um eine monoton, radial, fallende Funktion mit positivem
 Wertebereich.
 Typischerweise 
\begin_inset Formula $\Theta(d)=e^{\frac{d^{2}}{h^{2}}}$
\end_inset

.
 
\begin_inset Formula $h$
\end_inset

 ist typischer weise der durchschnittliche Abstand von benachbarten Punkten
 und hat einen direkten Einfluss darauf, wie glatt die Oberfläche erscheint.Typis
cherweise
\end_layout

\begin_layout Enumerate
Mit Hilfe von 
\begin_inset Formula $H$
\end_inset

 kann nun ein zweidimensionales Polynom zum Abschätzen der Umgebung von
 
\begin_inset Formula $S_{A}$
\end_inset

 in der Nähe von 
\begin_inset Formula $r$
\end_inset

 gefunden werden.
\begin_inset Formula 
\[
\sum_{i=1}^{N}(g(x_{i},y_{i})-f_{i})^{2}\Theta(\lVert p_{i}-q\rVert))
\]

\end_inset

Hier ist 
\begin_inset Formula $f_{i}$
\end_inset

 der kürzeste Weg von 
\begin_inset Formula $H$
\end_inset

 zu 
\begin_inset Formula $p_{i}$
\end_inset

.
 Bei 
\begin_inset Formula $x_{i}$
\end_inset

und 
\begin_inset Formula $y_{i}$
\end_inset

handelt es sich um die Koordinaten von Punkt 
\begin_inset Formula $q_{i}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Die Projektion von 
\begin_inset Formula $r$
\end_inset

 ist schlussendlich wie folgt definiert:
\begin_inset Formula 
\[
\phi(r)=q+g(0,0)n
\]

\end_inset


\end_layout

\begin_layout Standard
Neben dem Darstellen von Punkten kann das Verfahren auch eingesetzt werden,
 um weitere Punkte zu generieren.
 
\end_layout

\begin_layout Standard
Beim Rendern wird eine Datenstruktur wie bei dem QSplat-Verfahren verwendet.
 Es unterscheiden sich die Blätter, in denen zusätzlich zur Position, Radius,
 Normalen und Farbe auch eine Referenzebene 
\begin_inset Formula $H$
\end_inset

 sowie die Koeffizienten des Polynoms gespeichert werden.
\end_layout

\begin_layout Standard
Wenn bei dem Rendervorgang ein Blatt erreicht wird und wenn mehr als ein
 Punkt benötigt wird, werden mit Hilfe des Polynoms weiter Punkte für die
 Umgebung generiert.
\end_layout

\begin_layout Subsection
Tetraedertree
\begin_inset CommandInset label
LatexCommand label
name "sub:Tetraedertree"

\end_inset


\end_layout

\begin_layout Standard
Die Arbeit 
\begin_inset CommandInset citation
LatexCommand citep
key "rodriguez2013compressionDiamond"

\end_inset

 stellt eine weiter offline Datenstruktur zum Verwalten von Triangulierten
 Punkten vor.
 Die Datenstruktur unterteilt den Raum in einzelne Tetraeder.
 Durch die Tetraeder können Punkte durch baryzentriche Koordinaten repräsentiert
 werden.
\end_layout

\begin_layout Standard
In der Vorverarbeitung wird top-down eine Diamanten Hierarchie aufgebaut.
 Wobei jeder Diamant aus einer Menge von Tetraedern besteht.
 Die Eingabe erfolgt offline als eine Menge von Dreiecken.
 Zu Beginn wird die Bounding-Box in 6 Tetraeder unterteilt wobei die Diagonale
 von allen Tetraedern geteilt wird.
 Sobald ein eingefügtes Dreieck zwischen mehrere Tetraeder (Blätter) fällt,
 wird es an dem Rand des Tetraeder abgeschnitten.
 Die neuen Dreiecke werden dann in sein entsprechendes Blatt hinzugefügt.
 Sobald in einem Blatt mehr als eine vorher festgelegte Menge Dreiecke enthalten
 sind, wird es anhand einer Ebene, welche durch den Mittelpunkt der längsten
 Kante und seiner gegenüberliegenden Kante verläuft, geteilt.
 Im Anschluss werden die Dreiecke auf die zwei Kinder verteilt.
 Der nächste Schritt vereinfacht die Kinder Button-Up.
 Jeder Diamant wird dabei unabhängig abgearbeitet.
 Dafür muss beachtet werden das Vertices welche an den Außenwänden liegen
 nicht Verändert werden dürfen.
 Bei Vertices an den Innenwänden muss auch der korrespondierende Vertex
 beim Nachbarn mit einbezogen werden.
 Ist beides nicht der Fall kann beliebig vereinfacht werden.
 Da die Diamanten unabhängig vereinfacht werden ist es einfach die Datenstruktur
 zu parallelisieren.
\end_layout

\begin_layout Section
Bestehende Applikationen
\begin_inset Note Note
status open

\begin_layout Plain Layout
Silke Ende
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Idee, Punktwolken auf mobilen Geräten zu betrachten, ist nicht neu.
 Daher existieren schon einige Vorschläge zum Lösen des Problems.
 Im Folgenden werden einige dieser Arbeiten vorgestellt.
 
\end_layout

\begin_layout Subsection
KiwiViewer
\end_layout

\begin_layout Standard
KiwiViewer
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.kiwiviewer.org/
\end_layout

\end_inset

.
 Besucht am 19.05.2016
\end_layout

\end_inset

 ist eine freie quelloffene Applikation zur Erkundung von Punktwolken.
 Die App ist für Android sowie iOS verfügbar.
 Multi-Touch Gestensteuerung wird unterstützt.
 KiwiViewer bedient sich der Point-Cloud-Library
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://pointclouds.org/
\end_layout

\end_inset

.
 Besucht am 22.05.2016
\end_layout

\end_inset

 für seine Kernfunktionen.
 Die Punktmenge wird entweder über eine SD-Karte, E-Mail oder URL geladen.
\end_layout

\begin_layout Paragraph

\emph on
Abgrenzung 
\end_layout

\begin_layout Standard
Die App speichert die geladenen Punkte direkt auf dem Tablet.
 Modelle werden nicht vereinfacht.
 Daher treffen Modelle mit mehreren Millionen Punkten schnell an die Grenzen
 der GPU.
\end_layout

\begin_layout Subsection
LiMo
\end_layout

\begin_layout Standard
Bei LiMo handelt es sich um eine von OGSystems entwickelte Android Applikation
 zum Betrachten von LiDAR Daten.
 LiMo wurde für den professionellen Gebrauch entwickelt und ermöglicht das
 Beobachten von Gebäuden sowie Naturszenen.
 Daten können auch über einen eigenen Webservice gestreamt werden, weshalb
 die App auch zu Monitoring Zwecken eingesetzt werden kann.
 Die Applikation unterstützt bis zu 5 Millionen Punkte.
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Die Anwendung ist auf LiDAR Daten beschränkt.
 LiDAR ist primär zum Scannen von großen Objekten, wie Brücken geeignet
 und verfügt daher nicht über die Genauigkeit, welche beispielsweise bei
 einer Skulptur benötigt wird.
\end_layout

\begin_layout Subsection
Knn Baum
\begin_inset CommandInset label
LatexCommand label
name "sub:Knn-Baum"

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Mehr
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Eine weitere Möglichkeit ist ein Knn-Tree zu verwenden 
\begin_inset CommandInset citation
LatexCommand cite
key "VAST:VAST12:057-064"

\end_inset

.
 Allerdings mit der Beschränkung, dass die Punktmenge von Anfang an vollständig
 ist.
\end_layout

\begin_layout Standard
Diese Arbeit richtet sich besonders an die Darstellung auf mobilen Geräten.
 Die Datenstruktur selbst wird auf einem Server gespeichert.
 Knoten werden auf Anfrage eines Clients übertragen.
 Übertragende Knoten werden mit Hilfe eines LRU-Cache gespeichert.
 Die Implementierung erfolgte in C++ und OpenGl ES.
 Für die Netzwerkkommunikation wird Http- Pipelining sowie eine Wavletkompressio
n verwendet.
 
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Die Datenstruktur ist nicht dynamisch, also die Menge der Punkte muss von
 Anfang an feststehen.
 Implementierung erfolgte in C++ und für iOS.
 Die Datenstruktur bietet den Vorteil, dass sie eine geringe Tiefe besitzt.
\end_layout

\begin_layout Subsection
HuMoRS
\end_layout

\begin_layout Standard
Das HuMoRs (Huge models Mobile Rendering System) wurde von der Visual Computing
 Gruppe
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.crs4.it/vic/
\end_layout

\end_inset


\end_layout

\end_inset

 des CRS4 (Center for Advanced Studies, Research and Development in Sardinia)
 entwickelt.
 Die Applikation beherrscht das Darstellen von Modellen mit mehr als 70
 Millionen Punkten bzw.
 Dreiecken.
 Die Anwendung läuft auf Android und wurde mit mehreren Geräten sowie Versionen
 getestet.
 Besonderes Augenmerk wurde in der Arbeit auf Navigation gelegt.
 Der Rotationspunkt wird dynamisch berechnet.
 Des Weiteren  werden zu jedem Modell Thumbnails generiert, um zu interessanten
 Abschnitten des Modells springen zu können.
 Die Anwendung folgt dem gleichen Client-Server Ansatz wie die iOS Applikation
 aus Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Knn-Baum"

\end_inset

.
 Als Datenstruktur wird ein Tetraederbaum verwendet.
 Diese ermöglicht eine Kompression, welche einen Vertex mit Position, Farbe
 und Normale auf 64Bit komprimiert.
\end_layout

\begin_layout Standard
Auf der Client Seite wird ein LRU-Cache verwendet, um den Netzwerkverkehr
 niedrig zu halten.
 Die Applikation wurde in C++ mit Hilfe des Qt-Frameworks 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
verweis
\end_layout

\end_inset

programmiert.
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Die Arbeit bietet gute Ansätze, besonders in Bezug auf die Bedienung.
 Die verwendete Datenstruktur bietet eine detaillierte Darstellung samt
 hoher Bildfrequenz.
 Allerdings ist auch hier Datenstruktur offline, weshalb keine Punkte nach
 dem Erstellen mehr hinzugefügt werden können.
\end_layout

\begin_layout Section
Proxy Entwurfsmuster
\begin_inset CommandInset label
LatexCommand label
name "sub:Proxy-Design-Pattern"

\end_inset


\end_layout

\begin_layout Standard
Bei einem Proxy (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UML-Proxy-Pattern"

\end_inset

) 
\begin_inset CommandInset citation
LatexCommand citep
key "Gamma:1995:DPE:186897"

\end_inset

 handelt es sich um ein Objekt, welches als Schnittstelle zu etwas Anderem
 agiert.
 Typische Beispiele wären eine große Datei oder eine andere teure Ressource.
\end_layout

\begin_layout Standard
Ein klassisches Beispiel sind Platzhalter für noch nicht fertig geladen
 Bilder auf Webseiten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename uml/proxy.svg
	height 4.5cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Das Diagramm zeigt wie das reale Subjekt durch ein Proxy Objekt Repräsentiert
 wird, auf das der Client zugreift 
\begin_inset CommandInset label
LatexCommand label
name "fig:UML-Proxy-Pattern"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Singleton Entwurfsmuster
\begin_inset CommandInset label
LatexCommand label
name "sec:Singleton-Pattern"

\end_inset


\end_layout

\begin_layout Standard
Man spricht von einem Singleton, wenn von einer Klasse nur eine einzige
 oder beschränkte Anzahl Instanzen erlaubt sind.
 Typische Vertreter sind Objekte, die einen Zustand oder globale Variablen
 speichern wie das Android Kontext Objekt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename uml/singleton.svg
	height 2cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
UML Diagram eins Singleton Objektes, welches die einzige Instanz beherbergt
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Representational State Transfer
\begin_inset CommandInset label
LatexCommand label
name "sub:Representational-state-transfer"

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Zitierstil prüfen
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Representational state transfer (REST) ist ein Programmierparadigma für
 serviceorientierte verteilte Systeme.
 REST wurde im Jahr 2000 von Roy Fielding in seiner Doktorarbeit 
\begin_inset CommandInset citation
LatexCommand cite
key "Fielding:2000:ASD:932295"

\end_inset

 wie folgt beschrieben.
\end_layout

\begin_layout Standard
REST definiert sich über eine Menge von Beschränkungen bei der Kommunikation
 von Komponenten.
 Das prominenteste Beispiel ist das World Wide Web.
 Die Beschränkungen werden im Folgenden kurz vorgestellt.
\end_layout

\begin_layout Subsubsection*
Client-Server Modell
\end_layout

\begin_layout Standard
Nach Andrews 
\begin_inset CommandInset citation
LatexCommand cite
key "Andrews:1991:PPI:103162.103164"

\end_inset

 ist der Client ein auslösender Prozess und der Server ein reagierender
 Prozess.
 Clienten stellen Anfragen, auf welcher der Server reagiert.
 Der Client kann entscheiden, wann er mit dem Server interagiert.
 Der Server wiederum muss auf Anfragen warten und dann auf diese reagieren.
 Oft ist ein Server ein nicht endender Prozess, welcher auf mehrere Clienten
 reagiert.
\end_layout

\begin_layout Subsubsection*
Zustandslosigkeit
\end_layout

\begin_layout Standard
Jede Anfrage vom Client muss alle Informationen enthalten, welche notwendig
 sind, um die Anfrage zu verarbeiten.
 Des Weiteren darf kein gespeicherter Kontext auf dem Server vorliegen,
 auf welchen Bezug genommen wird.
 Alle Zustände werden auf dem Client gespeichert.
\end_layout

\begin_layout Subsubsection*
Caching
\end_layout

\begin_layout Standard
Serverantworten müssen implizit oder explizit als cachebar gekennzeichnet
 sein.
 Die Idee ist, den Netzwerkverkehr effizienter zu machen.
 Bemerkenswert dabei ist, dass dadurch ganze Interaktionen wegfallen können.
\end_layout

\begin_layout Subsubsection*
Einheitliche Schnittstelle
\end_layout

\begin_layout Standard
Ein integraler Bestandteil einer REST-Architektur ist eine einheitliche
 Schnittstelle.
 Das vereinfacht die Systemarchitektur und die Sichtbarkeit von Interaktionen
 ist verbessert.
 Sie ist durch 4 weitere Eigenschaften beschrieben.
\end_layout

\begin_layout Subparagraph
Adressierbarkeit von Ressourcen
\end_layout

\begin_layout Standard
Jede Information, die über einen URI kenntlich gemacht wurde, wird als Ressource
 gekennzeichnet.
 Die Ressource selbst wird in einer Repräsentation übertragen, welche sich
 von der internen Repräsentation unterscheidet.
 Jeder REST-konforme Dienst hat eine eindeutige Adresse, den Uniform Resource
 Locator (URL).
\end_layout

\begin_layout Subparagraph
Repräsentationen zur Veränderung von Ressourcen
\end_layout

\begin_layout Standard
Wenn ein Client die Repräsentation einer Ressource mitsamt seinen Metadaten
 kennt, reicht dies aus, um die Ressource zu modifizieren bzw.
 zu löschen.
 
\end_layout

\begin_layout Subparagraph
Self-descriptive messages
\end_layout

\begin_layout Standard
Jede Nachricht beschreibt, wie seine Informationen zu verarbeitet sind,
 z.B durch Angabe seines Internet Media Types (MIME-Type).
\end_layout

\begin_layout Subparagraph
Hypermedia as the Engine of Application State
\end_layout

\begin_layout Standard
Bei Hypermedia as the Engine of Application State (HATEOAS) navigiert der
 Client einer
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
überarbeiten
\end_layout

\end_inset

 REST-Schnittstelle ausschließlich über URLs, welche vom Server bereitgestellt
 werden.
 Abhängig von der gewählten Repräsentation geschieht die Bereitstellung
 der URIs über Hypermedia.
 Abstrakt betrachtet stellen HATEOAS-konforme REST-Services einen endlichen
 Automaten dar, dessen Zustandsveränderungen durch die Navigation mittels
 der bereitgestellten URIs erfolgt.
 Durch HATEOAS ist eine lose Bindung gewährleistet und die Schnittstelle
 kann verändert werden.
 
\end_layout

\begin_layout Subsubsection*
Mehrschichtige Systeme
\end_layout

\begin_layout Standard
Der Client soll lediglich die Schnittstelle kennen.
 Schichten dahinter bleiben ihm verborgen.
\end_layout

\begin_layout Chapter
Frameworks und Architektur
\end_layout

\begin_layout Standard
Im Folgenden werden die Technologien, Begriffe und Frameworks vorgestellt,
 welche in der Arbeit verwendet werden.
\end_layout

\begin_layout Section
Java und Android
\end_layout

\begin_layout Standard
Bei Java 
\begin_inset CommandInset citation
LatexCommand citep
key "gosling1995java"

\end_inset

 handelt es sich um eine 1995 von Sun Microsystems veröffentliche Programmierspr
ache.
 Entwickelt wurde die Sprache von James Gosling.
 Java ist objektorientiert, nebenläufig und plattformunabhängig.
 Letzteres wird erreicht, indem Java Code, genauer gesagt Java Byte Code,
 auf einer virtuellen Maschine (JVM) interpretiert wird.
 Moderne Implementierungen der JVM unterstützen sogenannte Just-in-Time
 Kompilierung.
 Das bedeutet, dass eine Übersetzung in den Maschinencode während der Laufzeit
 vorgenommen wird.
 Des Weiteren kümmert sich die Laufzeitumgebung von Java um das Speichermanageme
nt.
 Nach dem Tiobe-Index zu urteilen ist Java eine der populärsten Programmiersprac
hen der Welt
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.tiobe.com/tiobe_index?page=Java
\end_layout

\end_inset

.
 Besucht am 17.05.2016
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Android
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.android.com/
\end_layout

\end_inset

.
 Besucht am 19.05.2016
\end_layout

\end_inset

 ist ein mobiles Betriebssystem, welches momentan von Google entwickelt
 wird.
 Es wurde mit 33 Mitgliedern der Open Handset Alliance entwickelt.
 Ziel war es, einen offenen Standard für mobile Geräte zu schaffen
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.openhandsetalliance.com/press_110507.html
\end_layout

\end_inset

.
 Besucht am 23.05.2016
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Android baut auf dem Linux Kernel auf und ist für eine Bedienung über Touchdispl
ays ausgelegt.
 Daher werden Eingaben hauptsächlich über Gesten und Tippen am Display vorgenomm
en.
 Android verfügt über Ableger für Fernseher (Android TV), Autos (Android
 Auto) sowie Smartwatches (Android Wear).
 Android hat seit mehreren Jahren einen dominanten Marktanteil
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.idc.com/prodserv/smartphone-os-market-share.jsp
\end_layout

\end_inset

.
 Besucht am 21.05.2016
\end_layout

\end_inset

 bei mobilen Geräten und ist das mit Abstand meist genutzt Betriebssystem
 weltweit
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Usage_share_of_operating_systems
\end_layout

\end_inset

.
 Besucht am 21.05.2016
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Java ist die bevorzugte, wenn auch nicht einzig mögliche Programmiersprache
 für Android.
 Allerdings kommt bei Android keine Standard JVM zum Einsatz, sondern eine
 modifizierte Version.
 Bis Android 4.4 kam die virtuelle Maschine Dalivk zum Einsatz.
 Diese wurde vollständig in Android 5.0 ersetzt durch Android Runtime (ART)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://developer.android.com/about/versions/android-5.0-changes.html
\end_layout

\end_inset

.
 Besucht am 23.05.2016
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Google Protocol Buffers
\end_layout

\begin_layout Standard
Bei Google Protocol Buffers
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://developers.google.com/protocol-buffers/
\end_layout

\end_inset


\end_layout

\end_inset

 handelt es sich um eine plattformunabhängige Datenstruktur zum Serialisieren
 von Daten.
 
\end_layout

\begin_layout Standard
Die Datenstruktur wird in einem einheitlichen Schema festgelegt, zum Beispiel:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

message Person {   
\end_layout

\begin_layout Plain Layout

	required string name = 1;   
\end_layout

\begin_layout Plain Layout

	required int32 id = 2;   
\end_layout

\begin_layout Plain Layout

	optional string email = 3;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Schema definiert einen Namespaces, über welchen dann die eigentlichen
 Daten ausgelesen werden können.
 In dem Beispiel hat der Datentyp Person drei Felder.
 Jedes dieser Felder ist getypt und mit einem Schlüsselwort versehen, welches
 angibt, ob das Feld Pflicht ist.
\end_layout

\begin_layout Standard
Es besitzt also jede Person einen String für den Namen, aber nicht immer
 einen String für die Mail.
\end_layout

\begin_layout Standard
Aus dem Schema können für jede unterstützte Programmiersprache (Java, C++,
 Python, JavaNano, Ruby, Objective-C und C#) Klassen generiert werden, welche
 die Daten (de)serialisieren.
 Das macht es möglich, Clienten in anderen Sprachen zu schreiben.
\end_layout

\begin_layout Standard
Protocol Buffers sind komplett abwärtskompatibel.
 Die Schemata können problemlos erweitert werden.
\end_layout

\begin_layout Standard
Ein weiterer Vorteil ist der merklich verringerte Overhead im Vergleich
 zu JSON oder XML.
 Nachteilig ist, dass die übertragenden Daten nicht ohne Weiteres für einen
 Menschen lesbar sind.
 Protocol Buffers werden intensiv intern bei Google selbst eingesetzt.
 Ein weiterer prominenter Nutzer ist Blizzard beim BATTLE.NET 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://news.ycombinator.com/item?id=11444846 .
 Besucht am 23.05.2016
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Open-Graphics-Library for Embedded-Systems
\end_layout

\begin_layout Standard
Open-Graphics-Library for Embedded-Systems (OpenGL ES) 
\begin_inset CommandInset citation
LatexCommand citep
key "openGlES"

\end_inset

 bietet ein offenes Interface für Grafikhardware.
 Dieses besteht aus einer Sammlung von Prozeduren und Funktionen, die es
 dem Programmierer ermöglichen, Shaderprogramme, Objekte und Operationen
 zu spezifizieren, um dreidimensionale Farbbilder zu produzieren.
 Viele der Funktionen von OpenGL ES implementieren das Zeichnen von geometrische
n Objekten wie Punkte oder Linien.
 OpenGL ES setzt voraus, dass die Grafikhardware über einen Framebuffer
 verfügt.
\end_layout

\begin_layout Subsection
Vertex
\end_layout

\begin_layout Standard
Unter einem Vertex versteht man eine Datenstruktur, welche einen zwei- oder
 dreidimensionalen Punkt im Raum beschreibt.
\end_layout

\begin_layout Subsection
Shader 
\end_layout

\begin_layout Standard
Bei Shadern handelt es sich um vom Nutzer geschriebene Programme, welche
 an unterschiedlichen Stationen der Rendering-Pipeline aufgerufen werden.
 Shader werden in der C nahen OpenGL Shading Language geschrieben.
\end_layout

\begin_layout Subsection
Pipeline
\end_layout

\begin_layout Standard
Der Vorgang des Renderings lässt sich vereinfacht als Datenverarbeitung
 von aufeinanderfolgenden Stufen darstellen 
\begin_inset CommandInset citation
LatexCommand citep
key "OpenGlPipeline"

\end_inset

.
 Die Stufen werden im Folgenden kurz vorgestellt.
\end_layout

\begin_layout Standard
Den Anfang macht die Vertex Spezifikation.
 In diesem Schritt wird ein Stream von Vertices für OpenGL ES vorbereitet.
 Dazu muss festgelegt werden, was für ein Grundobjekt (Primitive) die Daten
 darstellen.
 Beispiele wären Punkte, Linien oder Dreiecke.
 Darauf folgt der Vertex Shader.
 Dieser erhält einzelne Elemente aus dem Vertexstream und gibt nach dem
 Ausführen des Shaders ein einzelnes Vertex zurück.
 Der Shader wird vom Benutzer programmiert.
 Typischerweise wird in diesem Schritt die Projektionsmatrix auf die Punkte
 angewendet.
\end_layout

\begin_layout Standard
Als nächster Schritt kann eine Tessellation angewendet werden.
 In dieser optionalen Stufe werden Patches (Primitves für Tesselation) in
 mehrere kleinere Primitives zerlegt.
\end_layout

\begin_layout Standard
Darauf folgt der Geometry Shader.
 Dieser optionale Shader erhält als Eingabe einen Primitive und gibt keine
 oder mehre Primitives zurück.
 
\end_layout

\begin_layout Standard
Im Anschluss wird das Vertex Post-Processing ausgeführt.
 In diesem Schritt werden Teile außerhalb des Kamerafensters verworfen.
 Dieser Prozess nennt sich Clipping.
 In dieser Stufe werden die dreidimensionalen Koordinaten zu zweidimensionalen
 Kamerakoordinaten umgerechnet.
\end_layout

\begin_layout Standard
In der nächsten Stufe folgt das Primitve Assembly.
 Hier werden die erstellten Primitives zu einer Sammlung von finalen kleineren
 Primitives zerteilt.
 Zum Beispiel werden aus einer Liste von Vertices vom Primitive Typ GL_LINE_STRI
P mit 8 Mitgliedern 7 neue Primitives vom Typ Line-Base.
\end_layout

\begin_layout Standard
Im Anschluss werden die Primitives in diskrete Elemente unterteilt (gerastert).
 Diese Elemente nennt man Fragmente, welche an den Fragment Shader weitergereich
t werden.
 Die Ausgabe des Shaders ist ein Farb-, Tiefen- und sogenannter Stencilwert.
 Im letzten Schritt werden für die Ausgabewerte des Shaders eine Handvoll
 Tests durchgeführt.
 Ein Beispiel ist der Tiefen Test (Depth-Test), um zu vermeiden, dass verdeckte
 Objekte gezeichnet werden.
 Andere Test sind Scissor-Test, Stencil-Test und der Pixel-Ownership-Test.
\end_layout

\begin_layout Section
NanoHTTPD
\begin_inset CommandInset label
LatexCommand label
name "sub:NanoHTTPD"

\end_inset


\end_layout

\begin_layout Standard
NanoHTTPD
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/NanoHttpd/nanohttpd
\end_layout

\end_inset


\end_layout

\end_inset

 bezeichnet sich selbst als einen schlanker HTTP Server welche darauf ausgericht
et ist, sich einfach in bestehende Anwendungen einbetten zu lassen.
\end_layout

\begin_layout Standard
Das Project ist Open Source und wird aktiv auf Github entwickelt.
\end_layout

\begin_layout Section
la4j
\end_layout

\begin_layout Standard
La4j
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://la4j.org/
\end_layout

\end_inset


\end_layout

\end_inset

 ist eine, aus einem Studentenprojekt entstandene, offene Java Bibliothek.
 Die Bibliothek liefert Objekte (Matrizen und Vektoren) und Algorithmen
 für Lineare Algebra.
\end_layout

\begin_layout Section
DEFLATE
\end_layout

\begin_layout Standard
Bei DEFLATE 
\begin_inset CommandInset citation
LatexCommand citep
key "Deutsch:1996:DCD:RFC1951"

\end_inset

 handelt es sich um einen Kompression Algorithmus von Phil Katz aus dem
 Jahre 1993.
 Er kombiniert die die Kompressions Algorithmen LZ77 oder LZSS mit einer
 Huffman Kodierung.
 Der Algorithmus zeichnet such durch eine solide Kompression in kurzer Zeit
 aus.
 Der Algorithmus findet zum Beispiel im .png Format Anwendung.
\end_layout

\begin_layout Section
Volley 
\begin_inset CommandInset label
LatexCommand label
name "sub:Volley"

\end_inset


\end_layout

\begin_layout Standard
Bei Volley 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://developer.android.com/training/volley/index.html
\end_layout

\end_inset


\end_layout

\end_inset

 handelt es sich um ein HTTP Bibliothek zum Verwalten von Netzwerkanfragen.
 Volley bietet automatisches koordinieren von Anfragen.
 Es ermöglicht mehrere neben läufige Netzwerkverbindungen, Anfragen Priorisierun
g und einiges mehr.Die Bibliothek ist frei und wird unter diesem Link
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://android.googlesource.com/platform/frameworks/volley
\end_layout

\end_inset


\end_layout

\end_inset

 entwickelt.
\end_layout

\begin_layout Chapter
dotViewer
\end_layout

\begin_layout Standard
Mobile Geräte verfügen über vergleichsweise begrenzte Ressourcen was Rechenleist
ung von CPU und GPU und Arbeitsspeicher angeht.
 Punktwolken mit mehr als einer Million Punkte bringen die GPU schnell an
 Ihre Grenzen.
 Daher wurde ein Ansatz gewählt, der es ermöglicht Punkte nach Bedarf anzuzeigen
 und zu vereinfachen.
 Zum ermitteln der Punkte kommt ein Multi-Resolution Octree (siehe Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Multiresolution-Octree"

\end_inset

) zum Einsatz.
 Dadurch wird die GPU effizient eingesetzt.
 
\end_layout

\begin_layout Standard
Die Defizite beim Speicher werden durch eine Client-Server Architektur ausgeglic
hen (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Übersicht"

\end_inset

).
 Das eigentliche Modell wird von einem Server verwaltet.
 Der Client hat selber nur den momentan benötigten Satz Punkte gespeichert.
 Um Netzwerkverkehr niedrig zu halten werden die Punkte von Client in einem
 Cache nach dem Least-Recently-Used Prinzip gespeichert.
 Zum Rendern werden die Punkte als Vertex-Buffer-Object in den Speicher
 der GPU geschrieben und anschließend gezeichnet.
 
\end_layout

\begin_layout Standard
Als Programmiersprache wurde Java gewählt aufgrund des guten Kompromisses
 aus Portabilität und Performance sowie der guten Integration in das Android
 Betriebssystem.
\end_layout

\begin_layout Standard
Als Entwicklungsumgebung wurde für den Client Android-Studio und für den
 Server IntelliJ IDEA verwendet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename uml/dataflow.svg
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Übersicht"

\end_inset

Das Datenfluss Diagramm zeigt die Interaktion des Client mit dem Server.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Server
\end_layout

\begin_layout Standard
Der Server hat drei Aufgaben.
 Zum ersten erstellt er aus gegebenen Punkten einen MRT.
 Seine zweite Aufgabe ist es Punktanfragen zu bedienen und als letztes ein
 Proxy Objekt (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Proxy-Design-Pattern"

\end_inset

) des MRT an die Klienten zu verteilen.
\end_layout

\begin_layout Standard
Zur Interaktion stellt der Server ein RESTful Interface auf Basis des HTTP
 Protokolls bereit.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Warum nicht normaler Socketverkehr
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Multiresolution Tree
\end_layout

\begin_layout Standard
Der Multiresolution Tree besteht aus 4 Klassen (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Multiresolution-Tree-UML"

\end_inset

).
 Die Klasse MultiResolutionTree dient als Schnittstelle für alle äußeren
 Komponenten.
 Dadurch ist eine sinnvolle Kapselung gewährleistet.
 Sie beherbergt einen Zeiger auf den Wurzelknoten des MRT.
 Des Weiteren legt sie einen Index von den Knoten an um schnellen Zugriff
 zu ermöglichen.
 Zusätzlich existiert einer Factory Methode zum erstellen von Protocol Buffer
 Objekten.
\end_layout

\begin_layout Standard
Die Implementierung des MRT ist analog zu der Beschreibung in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Multiresolution-Octree"

\end_inset

.
 Jeder Knoten hat die absolute Koordinate seines Mittelpunktes als ID gespeicher
t.
 Erwähnenswert sind die Entscheidungen bei der Raster Klasse.
 Die Rasterwerte sind in einer internen Default Hash Map vermerkt.
 Diese bildet einen dreidimensionalen Vektor auf einen Farbwert und Gewicht
 ab.
 Charakteristisch ist bei einer Default Hash Map, dass bei Abfrage von nicht
 existierender Einträge ein Standartwert zurück gegeben wird.
 Dadurch wird im Vergleich zu einem 
\begin_inset Formula $n^{3}$
\end_inset

Array Speicherplatz gespart.
 Der eigentliche Rastervorgang wird durch die folgende Hashfunktion erreicht:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
H(p)=(\left\lfloor \frac{x(p)}{cellLength}\right\rfloor ,\left\lfloor \frac{y(p)}{cellLength}\right\rfloor ,\left\lfloor \frac{z(p)}{cellLength}\right\rfloor )
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $p$
\end_inset

 ist hier die Positionsvektor des Punktes relativ zu Ursprung des Würfel.
 Die Variable
\begin_inset Formula $cellLength$
\end_inset

 entspricht der Länge einer Gitterzelle.
 Also:
\begin_inset Formula 
\[
cellLength=\frac{cube.length}{k}
\]

\end_inset


\end_layout

\begin_layout Standard
Einfach gesprochen, werden die Koordinaten auf ein Vielfaches der 
\begin_inset Formula $cellLength$
\end_inset

 abgerundet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/MultiResolutionTreeUML.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Multiresolution-Tree-UML"

\end_inset

Das UML Diagramm zeigt den Aufbau des Multiresolution Trees.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit schnelle Zugriffe bei Anfragen auf die entsprechenden Knoten bzw.
 Punkte möglich sind existiert eine weitere Hashmap als Index.
 Dieser bildet Ids auf die entsprechenden Knoten ab.
 Der Index wird in nach einer festen Anzahl Einfüge Operationen aktualisiert.
\end_layout

\begin_layout Subsection
RESTful API
\end_layout

\begin_layout Standard
Unter einer RESTful API versteht man ein Webinterface welches die Beschränkungen
 von REST (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Representational-state-transfer"

\end_inset

) einhält.
\end_layout

\begin_layout Standard
Die API wurde mit Hilfe des NanoHTTPD Frameworks (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:NanoHTTPD"

\end_inset

) implementiert.
 NanoHTTPD wurde ausgewählt weil es schlank und einfach ist.
\end_layout

\begin_layout Standard
Ressourcen werden über GET-Anfragen mit folgender Form abgerufen:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

GET SERVER_IP:PORT/?parameter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Werte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Erklärung
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes gld
\end_inset

proxy
\begin_inset Quotes grd
\end_inset

, 
\begin_inset Quotes gld
\end_inset

samples
\begin_inset Quotes grd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Definiert den Typ der Anfrage
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Id für Punktdaten
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Prinzipiell wird bei jeder Anfrage eine Fallunterscheidung an dem mode Parameter
 gemacht.
 Die Anfragetypen werden im Folgenden vorgestellt.
\end_layout

\begin_layout Subsubsection
MRT-Proxy Anfrage
\begin_inset CommandInset label
LatexCommand label
name "sub:MRT-Proxy-Anfrage"

\end_inset


\end_layout

\begin_layout Standard
Da die Ermittlung gebrauchten Punkte auf dem Klienten statt findet muss
 auch dieser in Kenntnis über die Struktur des MRTs sein.
 Aus diesem Grund Stellt der Server ein MRT-Proxy zur Verfügung.
 Der MRT-Proxy ist im Prinzip gleich dem Multiresolution Octree, allerdings
 haben seine Knoten keine Punkte oder Rasterung gespeichert, sondern nur
 Ids um beim Server die entsprechenden Punkte anzufragen.
 Diese können entweder Original Punkte aus Blättern sein oder Punkte aus
 der Rasterung.
\end_layout

\begin_layout Standard
Eine Anfrage wäre zum Beispiel:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

GET 192.168.2.1:8080/?mode=tree
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zum versendet wird aus der Datenstruktur ein Protocol Buffer Objekt erstellt.
 Diese kann dann problemlos serialisiert werden.
 Das Protocol Buffer Objekt ist wie folgt definiert.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package DataAccesLayer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

option java_outer_classname = "MultiResTreeProtos";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

message MRTree{
\end_layout

\begin_layout Plain Layout

	required MRNode root = 1;
\end_layout

\begin_layout Plain Layout

	message MRNode {
\end_layout

\begin_layout Plain Layout

		required string id = 1;    
\end_layout

\begin_layout Plain Layout

		repeated double center = 2 [packed=true];         
\end_layout

\begin_layout Plain Layout

		required double cellLength = 3;         
\end_layout

\begin_layout Plain Layout

		required int32 pointCount = 4;         
\end_layout

\begin_layout Plain Layout

		required bool isLeaf = 5;         
\end_layout

\begin_layout Plain Layout

		repeated MRNode octant = 6;     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Punktanfrage
\end_layout

\begin_layout Standard
Der 2.
 Typ Anfragen liefert Punkte an den Klienten aus.
 Bei dieser Anfrage wird vom Klienten immer eine Id als Parameter mitgesendet.
 Diese Id passt auf einen Knoten des MRT.
\end_layout

\begin_layout Standard
Falls es sich um ein inneren Knoten handelt wird die Rasterung zu einer
 Liste von Punkten exportiert.
 Beim einem Blatt wird lediglich auf die vorhandene Punktliste zugegriffen.
 
\end_layout

\begin_layout Standard
Der Server greift über die MultiResolutionTree Klasse auf den entsprechende
 Knoten zu und generiert ein Protocol Buffer Objekt.
 Die Spezifikation des Objektes lautet:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package DataAccesLayer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

option java_outer_classname = "RasterProtos";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

message Raster{     
\end_layout

\begin_layout Plain Layout

	repeated Point3DRGB sample = 1;
\end_layout

\begin_layout Plain Layout

	message Point3DRGB{         
\end_layout

\begin_layout Plain Layout

		repeated float position = 1;         
\end_layout

\begin_layout Plain Layout

		repeated float color = 2;         
\end_layout

\begin_layout Plain Layout

		required int32 size = 3;     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es handelt sich also um eine Liste von Punkten mit Positions-, Farb- und
 einer Gewichtswerten (size).
\end_layout

\begin_layout Standard
Alle Protocol Buffer Objekte werden, bevor sie über das Netzwerk versendet
 werden, serialisiert und durch den DEFLATE Algorithmus komprimiert, um
 den Netzwerkverkehr möglichst niedrig zu halten.
 
\end_layout

\begin_layout Section
Client
\end_layout

\begin_layout Standard
Bei dem Client handelt es um eine Android Anwendung.
 Der Client ist verantwortlich für das Darstellen der Punktwolke und reagiert
 auf Eingaben des Users.
\end_layout

\begin_layout Standard
Der Client verfolgt eine eventbasierte Architektur.
 Wird vom Nutzer eine Translation(2-Finger Geste) oder Rotation(Slide Geste)
 an dem Punktmodel ausgeführt kann sich die Menge der zu zeichnenden Punkte
 ändern.
\end_layout

\begin_layout Standard
Die Menge der momentan zu zeichnenden Punkte wird im folgenden als aktive
 Punkte bezeichnet.
 Die Knoten, welche die aktiven Punkte beinhalten, werden als aktive Knoten
 bezeichnet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename uml/Client.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Das UML Diagramm zeigt den Aufbau des Multiresolution Trees.
\begin_inset CommandInset label
LatexCommand label
name "fig:Client-UML"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Netzwerkverkehr
\end_layout

\begin_layout Standard
Bei der DataAcessLayer Klasse handelt es sich um ein Singleton (siehe Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Singleton-Pattern"

\end_inset

), welches als Schnittstelle für jeglichen Netzwerkverkehr fungiert.
 Sie verfügt über Funktion zum Anfordern von Punkten oder des Proxys.
 Für die asynchronen Anfragen wird das Volley Framework verwendet (siehe
 Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Volley"

\end_inset

).
 Das Framework stellt eine Prioritätswarteschlange für HTTP Anfragen zur
 Verfügung.
 Volley ermöglicht es die Callback Funktion, welche nach Eintreffen einer
 Antwort aufgerufen wird, zu überschreiben, um eigene Logik zu definieren.
\end_layout

\begin_layout Standard
Die zwei Methoden der Klasse werden im folgendem vorgestellt.
\end_layout

\begin_layout Paragraph
buildMultiResTreeProtos(owner:MultiResTreeOwner)
\end_layout

\begin_layout Standard
Die Methode dekoriert eine Instanz welche das MultiResTreeOwner Interface
 implementiert (z.B RemotePointClusterGL) mit dem MRT-Proxy.
 
\end_layout

\begin_layout Standard
Als erster Schritt wird eine HTTP-Anfrage für den MRT Proxy an den Server
 gestellt.
 Beim Empfangen der Antwort werden die Daten deserialisiert und im Anschluss
 mit Hilfe einer Factory Methode zum MRT-Proxy umgewandelt.
 Die als Parameter übergebene Instanz erhält einen Zeiger auf den Proxy.
\end_layout

\begin_layout Paragraph
getSamples(id:String, cache:LRUDrawableCache)
\end_layout

\begin_layout Standard
Die Methode fordert Punktdaten vom Server an und speichert diese in einem
 Cache Objekt welches später zum Zeichnen der Punkte verwendet wird.
 Beim erhalten der Antwort werden die Daten zuerst dekomprimiert (DEFLATE)
 und deserialisiert.
 Im Anschluss werden die Farb-, Positions- und Gewichtswerte in einen nativen
 Buffer geschrieben, damit OpenGL bei Bedarf darauf zugreifen kann.
\end_layout

\begin_layout Subsection
Rendering
\end_layout

\begin_layout Standard
In diesem Abschnitt wird beschrieben, wie die Punktdaten ausgewählt und
 verarbeitet werden.
\end_layout

\begin_layout Subsubsection
Shader
\end_layout

\begin_layout Standard
Die Shader sind als Textdatei in dem Android Ressourcen gespeichert.
 Bei der Initialisierung der OpenGL View Instanz werden sie kompiliert und
 gelinkt.
 Im folgendem werden die Shader vorgestellt.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# vertex_shader.glsl
\end_layout

\begin_layout Plain Layout

attribute vec3 a_Position; 
\end_layout

\begin_layout Plain Layout

attribute vec3 a_Color; 
\end_layout

\begin_layout Plain Layout

attribute float a_Size; 
\end_layout

\begin_layout Plain Layout

uniform mat4 u_Matrix; 
\end_layout

\begin_layout Plain Layout

varying vec4 v_Color;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void main() {     
\end_layout

\begin_layout Plain Layout

	v_Color = vec4(a_Color, 1.0);     
\end_layout

\begin_layout Plain Layout

	gl_Position = u_Matrix * (vec4(a_Position, 1.0));     
\end_layout

\begin_layout Plain Layout

	gl_PointSize = min(4.0, sqrt(a_Size)); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In dem Vertex Shader werden die Postionen der Punkte mit der Projektionsmatrix
 multipliziert und an die nächste Stufe der OpenGL Pipeline weiter gegeben.
 Des weiteren wird die Größe der zu zeichnenden Punktes berechnet.
 Es wird die Wurzel gezogen um sehr große Werte abzuschwächen.
 Durch die min() Funktion wird eine obere Grenze von 4 eingeführt.
 Das ist nötig den bei sehr detaillierten Objekten kann das Gewicht schnell
 sehr groß werden.
 Die Farbwerte werden einfach an den Fragment Shader durch eine varying
 Variable weitergereicht.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

precision mediump float;
\end_layout

\begin_layout Plain Layout

varying vec4 v_Color;
\end_layout

\begin_layout Plain Layout

void main() {     
\end_layout

\begin_layout Plain Layout

	gl_FragColor = v_Color; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Fragment Shader empfängt die Farbwerte und gibt sie weiter an die vorgegeben
e Variable gl_FragColor und legt damit den Farbwert des Fragmentes fest.
\end_layout

\begin_layout Subsubsection
Scene Klasse
\end_layout

\begin_layout Standard
Die Scene Klasse siehe(Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Client-UML"

\end_inset

)ist die Schnittstelle für alle Rendering relevanten Aktionen.
 Alle zu zeichnenden Objekte sowie die Kamera sind in dieser Klasse gespeichert.
 Nutzereingaben werden von dieser Klasse entgegengenommen und entsprechend
 verarbeitet.
\end_layout

\begin_layout Paragraph
drawScene()
\end_layout

\begin_layout Standard
Beim Aufruf der Methode wird die draw() Methode von jedem Element der Liste
 ausgelöst.
\end_layout

\begin_layout Subsubsection
RemotePointClusterGL
\end_layout

\begin_layout Standard
Die RemotePointClusterGL kümmert sich um das Ermitteln aktiver Punkte mit
 Hilfe des MRT, dafür sind Verweise auf den Cache und dem MRT-Proxy gespeichert.
 Des weiteren greift die Klasse auf die DataAccesLayer Instanz zu, um entweder
 den MRT Proxy zu aktualisieren oder neuen Punkten anzufordern.
 Bei Initialisierung der Instanz wird der Proxy vom Server erfragt.
 Der gespeicherte LRU-Cache beinhaltet die Punktdaten
\end_layout

\begin_layout Standard
Immer wenn sich die Kameraposition ändert wird die updateCache() aufgerufen
 um den aktiven Knoten zu ermitteln.
\end_layout

\begin_layout Paragraph
updateCache()
\end_layout

\begin_layout Standard
Die Methode bestimmt die momentan aktiven Punkten bzw.
 Knoten mit Hilfe des Proxy Objektes.
\end_layout

\begin_layout Standard
Knoten(mit ihren Punkten) werden zu den aktiven Knoten hinzugefügt wenn
 folgende Kriterien erfüllt sind:
\end_layout

\begin_layout Itemize
die Punkte sind sichtbar
\end_layout

\begin_layout Itemize
die Auflösung der Punkte ist ausreichen oder schon maximal
\end_layout

\begin_layout Standard
Um das zu erreichen wird der Proxy mit Hilfe des folgenden Algorithmus traversie
rt.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public List<String> getIdsViewDependent(){         
\end_layout

\begin_layout Plain Layout

	List<String> ids = new LinkedList<>();         
\end_layout

\begin_layout Plain Layout

	_getIdsViewDependent(root, ids);         
\end_layout

\begin_layout Plain Layout

	return ids; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private void _getIdsViewDependent(OctreeNodeGL currentNode, List<String>
 ids) {      
\end_layout

\begin_layout Plain Layout

	if ((currentNode.isLeaf || 
\end_layout

\begin_layout Plain Layout

	currentNode.getDetailFactor(this.owner) < DETAIL_THRESHOLD)){           
  
\end_layout

\begin_layout Plain Layout

		ids.add(currentNode.id);             
\end_layout

\begin_layout Plain Layout

		return;         
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	for (OctreeNodeGL node : currentNode.octants ) {             
\end_layout

\begin_layout Plain Layout

		if (node.isVisible(owner) && node.pointCount > 0)         
\end_layout

\begin_layout Plain Layout

			_getIdsViewDependent(node, ids);
\end_layout

\begin_layout Plain Layout

	}     
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Einfach gesagt, besuche Knoten solange sichtbar bis entweder ein Blatt erreicht
 ist oder eine ausreichende Detailstufe.
 Bei dem Test auf Sichtbarkeit wird geprüft ob die projektierte Box (von
 einem Knoten) sich mit der View-Ebene schneidet.
 In jedem Schritt wird der Detail-Factor ermitteln und mit einem festgelegten
 Schwellwert verglichen.
 Der 
\end_layout

\begin_layout Standard
Schwellwert ist experimentell ermittelt und kann abhängig von der Leistung
 des Gerätes gewählt werden.
 Sobald der Detail-Factor klein genug ist, gilt der Knoten als ausreichend
 aufgelöst und wird gezeichnet.
 Der Detail-Factor berechnet sich wie folgt:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
\align left

public float getDetailFactor(ModelGl m){             
\end_layout

\begin_layout Plain Layout
\align left

	float[] boundingBox = getBoundingBox(projectPoints(edgePoints,m.camera.projection
Matrix, m.camera.viewMatrix, m.getModelMatrix()));             
\end_layout

\begin_layout Plain Layout
\align left

	float[] centerProj = projectPoint(center, m.camera.projectionMatrix, m.camera.viewM
atrix, m.getModelMatrix());             
\end_layout

\begin_layout Plain Layout
\align left

	float zNorm = centerProj[2];             
\end_layout

\begin_layout Plain Layout
\align left

	return getArea(boundingBox) * 1/(zNorm * zNorm);        
\end_layout

\begin_layout Plain Layout
\align left

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der komplette Vorgang findet in einem eigenem Thread statt, damit der Nutzer
 nicht warten muss um neue Eingabe zu machen.
 Für die Verwaltung von Threads kommt die von Java mitgelieferte ThreadPoolExecu
tor Klasse zum Einsatz.
\end_layout

\begin_layout Standard
Nachdem alle nötigen Knoten festgestellt wurden, wird geprüft, ob sich diese
 schon im Cache befinden.
 Falls nicht werden diese vom Server angefordert.
\end_layout

\begin_layout Paragraph
draw()
\end_layout

\begin_layout Standard
Zum zeichnen des Models wird die draw Methode aller aktiven Knoten im Cache
 aufgerufen.
 
\end_layout

\begin_layout Subsubsection
DrawableCache Klasse
\end_layout

\begin_layout Standard
Diese Klasse speichert und cached die Punktdaten vom Server.
 Des Weiteren sendet sie Punktdaten als Vertex Buffer Object (VBO) an die
 GPU.
 Der Vorteil von VBOs ist, dass Punktdaten nicht bei jedem Frame neu übermittelt
 werden müssen.
 Stattdessen werden die Daten direkt auf der Grafikkarte gespeichert.
 Dadurch wird die Performance stark verbessert.
 Schlussendlich wird in dieser Klasse das Zeichnen durch OpenGL initiiert.
\end_layout

\begin_layout Standard
Der Cache besitzt eine Prioritätswarteschlange von Knoten nach dem zuletzt
 benutzt Prinzip.
 Die Knoten besitzen die Punktdaten und einen Vermerk ob diese schon im
 Speicher der GPU gelandet sind.
 Die Positions-, Farb- und Gewichtsdaten werden in einem einzigen Buffer
 pro Knoten ineinander abgespeichert um die Performance zu verbessern 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLE
S_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVe
rtexData.html
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Beim zeichnen wird zuerst geprüft ob die Daten des Knoten schon als VBO
 auf der GPU sind.
 Falls ja werden die Punkte mit der folgenden Methode gezeichnet.
 Ansonsten werd die Punkte erst übermittelt.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    public void draw(){
\end_layout

\begin_layout Plain Layout

        glDrawArrays(GL_POINTS, 0, pointCount);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Benutzer Interface
\end_layout

\begin_layout Standard
Die Applikation unterstützt drei Gesten zum erkunden der Modelle.
 Das einfache Scrollen mit einem Finger wird als Rotation interpretiert.
 Modelle pro Bewegung können nur um eine Achse rotiert werden um die Eingabe
 zu vereinfachen.
 Zwei Finger Scrollen wird als Zoom verstanden und das Zusammenziehen von
 zwei Fingern (Pinch) als Skalierung.
 
\end_layout

\begin_layout Standard
Für das Verarbeiten de Scroll Gesten mit einem oder zwei Fingern, werden
 Eingaben an Die GestureListener Klasse weitergeleitet.
 Dieser Klasse implementiert das von Android mitgelieferten GestureDetector.OnGes
tureListener Interface.
 Bei Pinch Eingaben kommt die ScaleListener Klasse zum Einsatz.
 Diese implementiert das vorgegebene ScaleGestureDetector.OnScaleGestureListener
 Interface.
 Die Listener Klassen besitzen Zeiger auf das Scene Singleton.
 Die Call-Back Methoden der Listener Klasse rufen dann die entsprechenden
 Transformationsmethoden auf.
\end_layout

\begin_layout Standard
Des Weiteren bietet die Applikation in seinem Aktionbar, dem schwarzen Menübalke
n am oberen Bildschirm, einen Zugang zum Settings Menü.
 Dort kann die IP des Servers, sowie ein Schwellenwert für die Detailstufe
 eingetragen werden.
\end_layout

\begin_layout Chapter
Experimente und Auswertungen
\begin_inset CommandInset label
LatexCommand label
name "chap:Experimente-und-Auswertungen"

\end_inset


\end_layout

\begin_layout Standard
In diesem Kapitel soll die Performance des dotViewers evaluiert werden.
 Performance ist hier definiert als die Anzahl berechneten Bilder (Frames)
 pro Sekunde (FPS).
 Umso mehr Bilder pro Sekunde berechnet werden, desto performanter und flüssiger
 ist die Darstellung.
 Zur Messung werden unterschiedliche Modelle in verschiedenen Vergrößerungsstufe
n um 360 Grad gedreht.
 Zum einem eine Felslandschaft mit ca.
 1.6 Millionen Punkten.
 Das Modell wurde vom dem Archaeocopter Projekt via 3D-Rekonstruktion errechnet.
 Das zweite Testobjekt ist eine Thailändische Statue aus dem Stanford 3D
 Scanning Repository
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://graphics.stanford.edu/data/3Dscanrep/
\end_layout

\end_inset


\end_layout

\end_inset

.
 Das Modell hat ungefähr 5 Millionen Punkte.
 Schlussendlich wird eine Baustelle und Umgebung mit 20 Millionen Punkte
 getestet.
 Das Modell stammt von der Jacobs University Bremen gGmbH und wurde von
 Dorit Borrmann, Jan Elseberg, Hamid Reza Houshiar und Andreas Nüchter aufgenomm
en.
 Angeboten wird das Model in dem Robotic 3D Scan Repository
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://kos.informatik.uni-osnabrueck.de/3Dscans/
\end_layout

\end_inset


\end_layout

\end_inset

.
 Als Server kommt ein Thinkpad T460 mit eine Intel i5 Prozessor und 16GB
 RAM zum Einsatz.
 Bei dem Client handelt es sich um LG G3 Smartphone mit einem 4-Kern Qualcomm
 Snapdragon 80 Chip.
 Das Smartphone verfügt über eine Auflösung von 1440x2560 Pixel und 2 GB
 RAM.
 Der Netzwerkverkehr läuft über das WLAN.
\end_layout

\begin_layout Standard
Die Messwerte und die Darstellungen selbst geben Aufschluss darüber, wie
 gut die Datenstruktur das Grundmodelle vereinfacht.
 
\end_layout

\begin_layout Section
Schlucht
\end_layout

\begin_layout Standard
Dieses Modell ist durch 3D-Rekonstruktion entstanden.
 Es handelt sich um eine Felsschlucht.
 Das Modell ist mit 1.5 Millionen Punkten für ein Landschaftsmodell wenig
 detailliert.
 Das Modell wird von der Applikation mit mindestens 30FPS in jeder Perspektive
 dargestellt.
 Die verschiedenen Detailstufen werden nachgeladen (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Terra_close"

\end_inset

 und Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Terra_far"

\end_inset

).
 Verzögerungen durch den Netzwerkverkehr beim Aufbau des Bildes übersteigen
 nicht die 5 Sekunden Marke.
 Sobald Flächen mit unterschiedlichen Sampleraten nebeneinander liegen,
 kann es zu sichtbaren Grenzen kommen.
 Das kann passieren, sobald eine gerasterte Fläche (innerer Knoten) neben
 einer Fläche mit rohen Punktdaten (Blatt) liegt.
 Der Effekt ist in Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Terra_close"

\end_inset

 beim oberen Bild zu beobachten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/far_terra1.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/far_terra2.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Auf aus der ferner Distanz.
 Details wurden hier vereinfacht.
 Die dicker gezeichneten Punkte repräsentieren Bereiche mit einer hohen
 Dichte an Punkten.
\begin_inset CommandInset label
LatexCommand label
name "fig:Terra_far"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/mid_terra1.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/close_terra1.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Oben: Bild aus mittlerer Perspektive.
 Eine Kante zwischen zwei Oktanten ist oben rechts im Bild erkennbar.
 Unten: Die Schlucht in naher Aufnahme.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Terra_close"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Dinosaurierschädel
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
foo bar
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Baustelle
\end_layout

\begin_layout Standard
Das Modell stellt ein weitläufige Baustelle dar.
 Das Modell enthält urbane Objekte z.B Häuser und Brücken.
 Die Darstellung durch die Applikation vereinfacht das Gelände sinnvoll.
 Die Performance bleibt bei jeder Einstellung über 18FPS.
 Auffallend sind die recht hohen Latenzen von bis zu 10 Sekunden beim nachladen
 der einzelnen Oktanten.
 Diese ist allerdings nicht verwunderlich Anbetracht der hohen Menge an
 Punkten von diesem Modell.
 Bei nahen Darstellungen werden Details sichtbar.
 Es kann auf kurzer Distanz zu verdunkelten Bereichen kommen sobald der
 Punktabstand zwischen etwas größer als 1 Pixel beträgt (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:bstelle_close"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/bstelle_far2.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/bstelle_close4.png
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Oben: Vereinfachte Darstellung der Baustelle.
 Viele Details wurden durch einfache Punkte ersetzt.
 Unten: Nahaufnahme der Sandkuhle.
 Auffallend ist die dunkle Verfärbung des hinteren Bereiches.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:bstelle_close"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/bstelle_mid1.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/bstelle_mid4.png
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Beide Bilder zeigen die Baustelle auf mittlerer Distanz.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Zusammenfassung und Ausblick
\end_layout

\begin_layout Section
Zusammenfassung
\end_layout

\begin_layout Standard
In der vorliegenden Bachelorarbeit wurde eine Implementierung zum Betrachten
 von großer Punktemenge auf Android Geräten vorgestellt.
 
\end_layout

\begin_layout Standard
Im Kapitel Grundlagen und verwandte Arbeiten wurde eine Einführung in die
 3D- Rekonstruktion gegeben.
 Des Weiteren wurden unterschiedliche Repräsentationen von Punktwolken diskutier
t und auf ihre Eignung bezüglich der gestellten Anforderungen geprüft .
 Im folgenden wurde bestehende Lösungen für mobile Geräte diskutiert.
 Aktuelle Arbeiten konnten große Punktmengen mit mehr als 100 Millionen
 Punkten bewältigen.
 Allerdings wurden offline Datenstrukturen für die Punktverwaltung verwendet.
 Daher musst die Punktwolken beim erstellen schon vollständig vorliegen.
\end_layout

\begin_layout Standard
Aufbauend auf diesen Schwachpunkt wurde im Kapitel dotViewer eine Applikation
 vorgestellt welche zu einem in der Lage ist Punktdaten online zu verarbeiten
 sowie Punktwolken mit über 10 Millionen Punkten darzustellen.
 Die theoretische Grundlage für die verwendete Datenstruktur war der in
 Kapitel 2 vorgestellt MRT.
 Als Architektur wurde das Client Server Modell mit einer RESTfull API gewählt
 um Speicher und GPU vom Tablett zu entlasten.
 
\end_layout

\begin_layout Standard
In Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Experimente-und-Auswertungen"

\end_inset

 wurde die Applikation durch messen der FPS und durch Beobachten der Darstellung
 evaluiert.
 Die Framerate ist dabei nicht unter 18FPS gesunken.
 Durch die Teils unterschiedliche aufgelösten Rasterungen kann es zu sichtbaren
 Kanten kommen.
 Des weiteren können Bereiche dunkler Wirken, wenn der Punktabstand ein
 wenig größer ist als die Pixeldichte.
 Dieser Effekt ist nicht verwunderlich, da zwischen den Punkten nicht interpolie
rt wird.
 Dadurch füllen sich die leeren Bereiche mit Schwarz und die Farbe wirkt
 verfälscht.
\end_layout

\begin_layout Section
Ausblick
\end_layout

\begin_layout Standard
Viele Bereiche der Anwendung sind einfach gehalten um den angepeilten Zeitrahmen
 nicht zu sprengen.
 Der Server ist nicht an eine Datenbank gekoppelt um Daten auf die Festplatte
 auszulagern.
 Dadurch wären die Größe Modelle theoretische nur von Festplattenspeicher
 begrenzt.
 Eine weiteres Problem ist die Kompression vor dem Netzwerkverkehr.
 Für die Punktdaten lässt sich sicherlich eine besser angepasste Kompression
 finden.
 Andere Projekte besuchten hierfür zum Beispiel eine Wavletkompression.
 Die Steuerung ist auch nicht optinal gelöst.
 Intelligentere Mechanismen wie sie bei HuMors vorhanden sind wären eine
 sinnvolle Ergänzung.
\end_layout

\begin_layout Standard
Es würde sich auch Anbieten den Server um weitere HTTP-Methoden zu erweitern.
 Die PUT Methode könnte zum Hinzufügen von Punkten genutzt werden.
 Dadurch wäre der Server gut Ansprechbar über eine plattformunabhängige
 Schnittstelle.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
Die Applikation soll nach Abgabe dieser Arbeit frei zugänglich durch die
 Entwicklungsplattform github sein.
 Aufgrund seiner modularen Architektur sind weiter Komponenten unkompliziert
 nachreichbar.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "sources"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
