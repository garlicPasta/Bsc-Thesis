#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
\usepackage{url}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{pdfpages}



\title{\includegraphics[width=0.6\textwidth]{img/logo}\\
{\normalsize Bachelorarbeit am Institut für Informatik der Freien Universität Berlin}\\ Darstellung gigantischer Punktwolken auf Android Geräten}

\author{Jakob Krause\\
Matrikelnummer: xxxxxxx \\
jakobkrause@zedat.fu-berlin.de\\\\
Betreuung und Erstgutachten:\\ Prof. Dr. Marco Block-Berlitz\\
Zweitgutachten:\\ }
\date{\today}
\end_preamble
\options ngerman
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Java,frame=lrbt,numbers=left,showstringspaces=false,breaklines=true,xleftmargin=15pt,tabsize=2,basicstyle={\fontsize{9}{11}\ttfamily},keywordstyle={\color{blue}\ttfamily},stringstyle={\color{red}\ttfamily},commentstyle={\color{green}\ttfamily}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
maketitle 
\end_layout

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
vfill{}
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
includepdf[pages={1}]{pdf/erklaerung.pdf}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{page}{1} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Einführung
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
Das Interesse an der Darstellung von großen Punktwolken ist durch das Aufkommen
 von günstigen 3D Scanner und der 3D Rekonstruktion in den letzten Jahrzehnt
 stark gewachsen.
 Aufgrund der technologischen Entwicklungen in diesem Bereich, ist es möglich
 von kleinen Objekten, wie einem Dinosaurier Schädel, bis hin zu ganzen
 Städte, Modele in hoher Detailstufe digital zu erfassen.
 In der Denkmalpflege werden Objekte mittlerweile aus Routine abgescannt
 und archiviert.
 
\end_layout

\begin_layout Standard
Für gewöhnlich sind die erzeugten Modelle enorm groß und daher nicht ohne
 weiteres darstellbar.
 Die Modelle bestehen meist aus einer ungeordneten Sammlung von dreidimensionale
n Punkten mit Farbinformationen.
 Desktop Lösung verlassen sich zur Lösung des Problems auf Level-of-Detail(LOD)
 Konzepte kombiniert mit Out-of-core Verfahren und klugen Caching Strategien
 um der hohen Datenmenge Herr zu werden.
 Durch das Aufkommen von leistungsstarken Smartphones entstand eine neue
 Plattform zum Darstellen von Modellen.
\end_layout

\begin_layout Standard
Daraus entstand eine Nachfrage durch Forschungsgruppen für eine mobile Applikati
on zum Betrachten großer Modelle.
 Die Applikation kann Beispielsweise bei 3D Rekonstruktion schnelles Feedback
 liefern, vereint mit den Vorzügen eines mobilen Gerätes.
 Dadurch können schnell unvollständige oder schwer zu erfassende Bereiche
 des Modells beim Scannen erkannt werden.
 Des weiteren kann die Applikation zur Präsentation von Modellen eingesetzt
 werden.
\end_layout

\begin_layout Standard
Die Herausforderung bestand darin trotz der Limitierungen eines Tablets
 durch seinen geringen Arbeitsspeicher und der Vergleichsweisen schwache
 GPU Punktwolken mit mehreren Millionen Punkten flüssig darzustellen.
 Dabei sollte es möglich sein jederzeit neue Punkte in die bestehende Darstellun
g hinzuzufügen.
 Zur Zeit existieren nur bedingt geeignet Softwarelösungen für das Problem.
\end_layout

\begin_layout Subsection
Archaeocopter und Archaeonautic Projekt
\begin_inset CommandInset label
LatexCommand label
name "sub:Archaeocopter-Projekt"

\end_inset


\end_layout

\begin_layout Standard
Das Archaeocopter Projekt, welches 2012 von Dr.
 Benjamin Ducke und Prof.
 Dr.
 Marco Block-Berlitz ins Leben gerufen wurde, hat es sich zum Ziel gesetzt
 eine unbemanntes Flugobjekt (UAV) zu entwickeln, welcher durch halb-autonome
 Flüge Archäologen bei ihrer Arbeit durch Luftaufnahmen unterstützt.
 Aus diesen Aufnahmen lassen sich durch 3d Rekonstruktion Modelle generieren.
 Die Technik wird auch zum Denkmalschutz angewandt.
\end_layout

\begin_layout Standard
Die Idee war es aktuelle Verfahren aus der Computervision und künstlichen
 Intelligenz zusammen mit UAVs mit Kameras für die Datenerhebung einzusetzen.
 Das innovative Verfahren lässt sich auch Unterwasser einsetzen.
 Offiziell ging das Projekt im September 2012 mit Unterstützung von Prof.
 Dr.
 Raúl Rojas von Berlin's Freier Universität an den Start.
\end_layout

\begin_layout Standard
Diese Arbeit ist in Zusammenarbeit mit dem Projekt entstanden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/slider008.jpg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Archaeocopter Projekt
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Bilder
\end_layout

\end_inset


\end_layout

\begin_layout Section
Ziele
\end_layout

\begin_layout Standard
Ziel dieser Arbeit ist es ein mobile Applikation für das Android Betriebssystem
 zu entwickeln, welche in der Lage ist Punktwolken mit mehreren Millionen
 Punkten performant darzustellen.
 Dabei soll es möglich sein Punkte in die bestehende Darstellung zur Laufzeit
 hinzuzufügen.
\end_layout

\begin_layout Standard
Ein weiteres Ziel der Arbeit ist es, die Architektur möglichst modular und
 plattformunabhängig zu gestalten um dadurch Austauschbarkeit und Wartbarkeit
 der einzelnen Komponenten zu gewährleisten.
 Es sollte möglichst einfach sein, eine Applikation für iOS oder ein anderes
 mobiles Betriebssystem nachzureichen.
 Des weiteren soll eine moderne Auswahl von Frameworks getroffen werden.
 Dabei soll die Applikation möglichst intuitiv benutzbar sein.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Punktwolken diskutieren, Formate ply, nvm.
 visualsfm
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Theorie
\begin_inset CommandInset label
LatexCommand label
name "sec:Theorie"

\end_inset


\end_layout

\begin_layout Section
Einführung in die 3D Rekonstruktion
\end_layout

\begin_layout Standard
Die Idee aus einer Folge von Bilder ein 3D Model zu errechnen ist eines
 der Kernthemen der Computervision.
 Verwendungen dieser Technik sind vielfältig und finden sich in der Wissenschaft
 und Wirtschaft wieder.
 Anwendungen existieren zum Beispiel in der Robotik, 
\begin_inset CommandInset citation
LatexCommand cite
key "klimentjew2008grundlagen"

\end_inset

 in welcher mit Hilfe eines Stereokamerasystems die Position des Roboters
 innerhalb seiner Umgebung feststellbar ist.
 Ein weiteres Feld ist die Archäologie und der Denkmalsschutz.
 Ein Beispiel dafür ist das Archaeocopter Projekt.
\end_layout

\begin_layout Standard
Allgemein kann man zwischen aktiver und passiver Rekonstruktion 
\begin_inset CommandInset citation
LatexCommand cite
key "ladikos2011real"

\end_inset

 unterscheiden.
\end_layout

\begin_layout Subsection
Aktive Rekonstruktion
\end_layout

\begin_layout Standard
Bei aktiver Rekonstruktion wird aktiv mit einem Sensors das Objekt abgetastet
 um die Struktur zu ermitteln.
 3D Scanner sind ein Vertreter dieser Gattung.
 Im Grunde sind sie der Kamera ähnlich.
 Genau wie diese besitzen sie ein Sichtfeld.
 Allerdings liefern sie statt Farbwert Abstandswert von ihrem Sichtfeld.
 Die Abstandswerte können entweder über die 
\begin_inset Quotes gld
\end_inset

Time of Flight
\begin_inset Quotes grd
\end_inset

 oder die Triangulierungmethode ermittelt werden.
\end_layout

\begin_layout Standard
Bei der 
\begin_inset Quotes gld
\end_inset

Time of Flight
\begin_inset Quotes grd
\end_inset

 Methode wird ein Laserstrahl versendet.
 Aus der Dauer bis die Reflektion ihren Ausgangspunkt erreicht kann die
 Entfernung ermittelt werden.
 Diese Methode ist bei nahen und feinen Objekten ungenau weil die Zeit nur
 zu einer gewissen Genauigkeit gemessen werden kann.
\end_layout

\begin_layout Standard
Bei der Triangulierungsmethode wird von einem Laser ein Punkte auf das das
 Objekt projektiert.
 Dieser Punkt wird von einer Kamera erfasst.
 In Abhängigkeit von der Entfernung erscheint der Laserpunkt im Sichtfeld
 der Kamera.
 Um das Verfahren zu beschleunigen kann statt einem Punkt eine Linie verwendet
 werden.(siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TriangulierungBild"

\end_inset

)
\end_layout

\begin_layout Standard
Die Methode ist sehr genau und daher für Skulpturen gut geeignet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/scanner-head-and-david-head-s.jpg
	width 63text%

\end_inset


\begin_inset Graphics
	filename img/david-classic-leftlight-s.jpg
	width 36text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:TriangulierungBild"

\end_inset

Triangulierungsmethode beim 
\begin_inset Quotes gld
\end_inset

The Digital Michelangelo
\begin_inset Quotes grd
\end_inset

 Projekt.
 Quelle: 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://graphics.stanford.edu/projects/mich/
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Passive Rekonstruktion
\end_layout

\begin_layout Standard
Unter passiver Rekonstruktion versteht man Methoden welche nicht aktiv eine
 Szene abtasten, sondern vorhandene photometrische Information(z.B Photos)
 nutzen um die Tiefe zu berechnen.
\end_layout

\begin_layout Standard
Das Stereo Verfahren ist eines der Ersten in diesem Feld.
 Man geht von 2 auf der x-Achse verschoben Bildern einer Szene aus.
 Nun gilt es Punktpaare zwischen den beiden Bilder zu finden.
 Um das zu vereinfachen sucht man nach einer Abbildung von Punkten aus Bild
 1 zu Bild 2.
 Aufgrund der Verschiebung der Bilder auf der x-Achse kann man durch Epipolargeo
metrie die Tiefe des Punkte berechnen.
\end_layout

\begin_layout Subsection
VisualSFM
\end_layout

\begin_layout Standard
Bei VisualSFM
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://ccwu.me/vsfm/
\end_layout

\end_inset


\end_layout

\end_inset

 handelt es sich um ein 3D Rekonstruktionssystem.
 Es verfügt über eine grafische Benutzeroberfläche und zeichnet sich mit
 Skalierbarkeit durch Nutzung der nVidia oder ATI Grafikkarten des Computers
 aus.
\end_layout

\begin_layout Standard
Entwickelt wurde das Programm von dem Studenten Changchang Wu
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://ccwu.me/
\end_layout

\end_inset


\end_layout

\end_inset

, welcher mittlerweile bei google beschäftigt ist.
 VisualSFM wird von dem Archaeocopter Projekt zur 3D Rekonstruktion verwendet.
\end_layout

\begin_layout Section
Repräsentationen von Punktwolken
\end_layout

\begin_layout Standard
Punkt basierende geometrische Oberflächen können als Stichprobenmenge einer
 kontinuierlichen Oberfläche verstanden werden.
 Dabei entstehen dreidimensionale Raumkoordinaten 
\begin_inset Formula $p_{i}\text{\in\mathbb{R}}^{3}$
\end_inset

.
 Oft existieren noch weiter Daten zu dem Punkt wie eine Normale 
\begin_inset Formula $n_{i}$
\end_inset

 oder eine Farbe 
\begin_inset Formula $c_{i}$
\end_inset

.
 Eine Punktwolke 
\begin_inset Formula $S$
\end_inset

 ist eine Menge solcher Punkte.
\end_layout

\begin_layout Subsection
QSplat Verfahren
\end_layout

\begin_layout Standard
Erste Vorschläge zur Darstellung von sehr großer Punktmengen wurden durch
 das QSplat Verfahren gemacht 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2000:QMP:344779.344940"

\end_inset

.
 Splat bedeutet Klecks wie von Farbklecks.
\end_layout

\begin_layout Standard
Die Punktmenge wird durch eine Hierarchie auf Basis von Kugeln modelliert.
 Jede Kugel repräsentiert einen Knoten in einem binär Baum.
 Jeder Knoten enthält den Mittelpunkt seiner Kugel, den Radius, die Normale
 und die Breite des Normalen Kegels und optional eine Farbe.
 Die Datenstruktur wird zu Beginn erstellt.
 Der Konstruktionsalgorithmus kann entweder auf einer Punktwolke oder besser
 einem triangulierten Modell angewendet werden.
 Bei letzterem ist es leichter die Normalen zu berechnen.
 Für den Radius der Kugeln wird die Länge der Längsten anliegenden Kante
 gewählt.
 Mit Hilfe folgendem Algorithmus kann nun die Datenstruktur erstellt werden.
\end_layout

\begin_layout Standard
\align left
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

BuildTree(vertices[begin..end]) { 
\end_layout

\begin_layout Plain Layout

	if (begin == end) 
\end_layout

\begin_layout Plain Layout

		return Sphere(vertices[begin]) 
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout
\align left

		midpoint = PartitionAlongLongestAxis(vertices[begin..end]) 		
\end_layout

\begin_layout Plain Layout
\align left

		leftsubtree  = BuildTree(vertices[begin..midpoint]) 
\end_layout

\begin_layout Plain Layout
\align left

		rightsubtree = BuildTree(vertices[midpoint+1..end]) 
\end_layout

\begin_layout Plain Layout
\align left

		return BoundingSphere(leftsubtree, rightsubtree) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sobald die Datenstruktur aufgebaut ist, kann die Punktmenge gezeichnet werden
 mit folgendem Algorithmus
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

TraverseHierarchy(node) { 
\end_layout

\begin_layout Plain Layout

	if (node not visible) 
\end_layout

\begin_layout Plain Layout

		skip this branch of the tree 
\end_layout

\begin_layout Plain Layout

	else if (node is a leaf node) 
\end_layout

\begin_layout Plain Layout

		draw a splat 
\end_layout

\begin_layout Plain Layout

	else if (benefit of recursing further is too low) 
\end_layout

\begin_layout Plain Layout

		draw a splat 
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		for each child in children(node) 
\end_layout

\begin_layout Plain Layout

			TraverseHierarchy(child) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zuerst wird getestet ob die Kugel des Knoten sichtbar ist.
 Dafür wird getestet ob die Kugle in dem View Frustum liegt.
 Falls nicht muss der Knoten und seine Kinder nicht beachtet werden und
 die Rekursion wird abgebrochen.
 QSplat führt auch Backface Culling aus mit Hilfe der Normalen Kegeln.
\end_layout

\begin_layout Standard
QSplat entscheidet anhand der Größe der projektierten Kugel auf die View-Ebene
 ob die Rekursion fortgesetzt wird.
 Überschreitet diese einen gewissen Schwellwert wird die Rekursion beendet
 und der aktuelle Knoten wird gezeichnet.
 
\end_layout

\begin_layout Standard
Das Verfahren kann modifiziert auch zum Streaming von Punktwolken genutzt
 werden 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2001:SQV:364338.364350"

\end_inset

 .
 
\end_layout

\begin_layout Subsection
Octree
\end_layout

\begin_layout Standard
Octrees sind eine Datenstruktur um dreidimensionale Daten hierarchisch zu
 untergliedern.
 Sie wurde 1980 von Donal Maegher beschrieben 
\begin_inset CommandInset citation
LatexCommand citep
key "meagher1982geometric"

\end_inset

.
 Octrees sind Analog im dreidimensionalen zu Quadtrees im zweidimensionalen.
\end_layout

\begin_layout Standard
Jeder Knoten repräsentiert einen Würfel welcher alle in den Knoten eingefügten
 3D Punkte beinhaltet.
 Jeder innere Knoten besitzt immer 8 Kinder.
 Diese unterteilen den Würfel des Knoten in 8 gleichgroße Oktanten usw.
 (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Octree"

\end_inset

)
\end_layout

\begin_layout Standard
Die eigentlichen Punktdaten sind in den äußeren Knoten gespeichert.
 Äußere Knoten können auch leer sein.
\end_layout

\begin_layout Standard
Der Octree unterstützt das Einfügen von Punkten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/Octree2.svg
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Octree"

\end_inset

Schematische Darstellung eines Octrees Quelle:?
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Multiresolution Octree
\begin_inset CommandInset label
LatexCommand label
name "sub:Multiresolution-Octree"

\end_inset


\end_layout

\begin_layout Standard
Die Datenstruktur entstammt aus der Arbeit 
\begin_inset Quotes eld
\end_inset

Interactive Editing of Large Point Clouds
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Wand:2008:SSP:1363373.1363581"

\end_inset


\end_layout

\begin_layout Standard
Die Datenstruktur unterstützt einfügen, löschen und bietet unterschiedlich
 detaillierte Darstellungen des Ausgangsmodells.
 
\end_layout

\begin_layout Standard
Im folgendem wird die Datenstruktur vorgestellt.
\end_layout

\begin_layout Standard
Der Multiresolution Octree(MRT) kann als eine spezielle Form des Octree
 verstanden werden.
 Wie beim Octree enthalten die äußeren Knoten alle Punkte.
\end_layout

\begin_layout Standard
Die Tiefe ergibt sich aus der Eigenschaft das kein Blatt mehr als 
\begin_inset Formula $n_{max}$
\end_inset

 Punkte beinhalten darf.
 Ist 
\begin_inset Formula $n_{max}$
\end_inset

 nach einer Einfüge Operation überschritten wird das Kind geteilt und die
 bestehenden Punkte werden auf die 8 neuen Kinder verteilt.
\end_layout

\begin_layout Standard
Die inneren Knoten sollen eine vereinfachte bzw.
 gröbere Version ihrer Kinder liefern.
\end_layout

\begin_layout Standard
Dafür haben diese eine dreidimensionale Rasterung gespeichert.
 Das Raster unterteilt den Würfel in 
\begin_inset Formula $k^{3}$
\end_inset

 gleichgroße Rasterzellen (z.B.
 
\begin_inset Formula $k\text{=128}$
\end_inset

).
 Jeder Rasterzelle hat zusätzlich ein Gewicht und ein Farbe als RGB Wert
 gespeichert.
 Das Raster selbst ist nicht als einfaches Array gespeichert, sondern als
 Hashtabelle um Speicherplatz zu sparen.
 Auf diese Art werden nur die Zellen gespeichert welche Punkte enthalten.
 
\end_layout

\begin_layout Standard
Zellen mit hohem Gewicht werden beim rendern größer gezeichnet.
 Sobald ein weiterer Punkt in die gleiche Zelle fällt wird das Gewicht inkrement
iert.
 
\end_layout

\begin_layout Standard
Der Farbwert entspricht dem des zuerst hinzugefügten Punktes der Zelle.
 
\end_layout

\begin_layout Paragraph
Einfügen eines Punktes
\end_layout

\begin_layout Standard
Beim Einfügen können zwei Fälle auftreten.
\end_layout

\begin_layout Subparagraph
1.
 Fall : Der Punkt liegt außerhalb der Wurzel.
 
\end_layout

\begin_layout Standard
Nun muss die bestehende Wurzel so lange erweitert werden bis sie den neuen
 Punkt mit einschließt.
 
\end_layout

\begin_layout Standard
Die Breite sowie Höhe der Wurzel verdoppelt sich dabei in jedem Schritt.
\end_layout

\begin_layout Standard
Sobald der Punkt in der Wurzel liegt tritt der 2.
 Fall ein.
\end_layout

\begin_layout Subparagraph
2.
 Fall : Der Punkt liegt innerhalb der Wurzel
\end_layout

\begin_layout Standard
Zuerst wird der Punkt der Rasterung hinzugefügt.
 Sprich das Gewicht in der entsprechende Rasterzelle wird um 1 erhöht und
 die Farbe des Punkten wird gegebenenfalls gespeichert.
 Dann wird ermittelt in welchem der Kinder der Punkt liegt.
 Nun wird der Vorgang beim Kind wiederholt bis ein äußerer Knoten erreicht
 wird.
 Falls die maximale Anzahl Punkte 
\begin_inset Formula $n_{max}$
\end_inset

 überschritten wurde muss der Knoten gespalten werden.
 Alle bisher gespeicherten Punkte und der neue Punkt werden nun auf die
 neuen Kinder verteilt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/img-003.ppm
	width 70text%
	scaleBeforeRotation

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Schema der Rasterung.
 Quelle: 
\begin_inset CommandInset citation
LatexCommand citep
key "Wand:2008:SSP:1363373.1363581"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/img-004.ppm
	width 70text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Schema nach einer Einfüge Operation.
 Quelle:
\begin_inset CommandInset citation
LatexCommand citep
key "Wand:2008:SSP:1363373.1363581"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Surface Splats
\end_layout

\begin_layout Standard
-
\end_layout

\begin_layout Subsection
Moving Least-Squares Surfaces
\end_layout

\begin_layout Standard
Das moving least-squares (MLS) Verfahren wurde von Levin 1998 vorgestellt
 
\begin_inset CommandInset citation
LatexCommand citep
key "levin1998approximation"

\end_inset

.
 Das Verfahren wurde erstmalig 2001 durch Alexa zur Darstellung von Punktwolken
 benutzt 
\begin_inset CommandInset citation
LatexCommand citep
key "Alexa:2001:PSS:601671.601673"

\end_inset

.
 Die Grundidee der Arbeit ist, dass die gegebene Menge Punkte 
\begin_inset Formula $S$
\end_inset

 indirekt eine Oberfläche 
\begin_inset Formula $S_{A}$
\end_inset

 definiert.
 Es wird eine Projektion 
\begin_inset Formula $\phi:U\rightarrow\mathbb{R}^{3}$
\end_inset

 vorgestellt welche einen beliebigen Punkt aus der Umgebung 
\begin_inset Formula $U$
\end_inset

 von 
\begin_inset Formula $S$
\end_inset

 auf eine Oberfläche 
\begin_inset Formula $S_{A}$
\end_inset

, welche das Objekt lokal beschreibt, projektiert.
 Alle Punkt die auf sich Selbst abbilden ergeben die Abgeschätzte Oberfläche
 
\begin_inset Formula $S_{A}$
\end_inset

.
 
\begin_inset Formula 
\[
S_{A}:=\{x\in\mathbb{R}^{3}|\phi(x)=x\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $U$
\end_inset

 kann man als eine Vereinigung von Kugeln mit Radius 
\begin_inset Formula $r_{k}$
\end_inset

, dessen Mittelpunkt ein Punkt aus 
\begin_inset Formula $S$
\end_inset

 ist, beschreiben.
\begin_inset Formula 
\[
U:=\bigcup_{i}\{x\in\mathbb{R}^{3}|\lVert x-p_{i}\rVert<r_{K}\}
\]

\end_inset


\end_layout

\begin_layout Standard
Die Projektion eines Punktes 
\begin_inset Formula $r$
\end_inset

 wird in 3 Schritten ermittelt.
\end_layout

\begin_layout Enumerate
Ermittle eine Referenzebene 
\begin_inset Formula $H=\{x|\langle n,x\rangle-D=0,x\in\mathbb{R}^{3}\},n\in\mathbb{R}^{3},\lVert n\rVert=1$
\end_inset

 durch Minimierung des Ausdrucks
\begin_inset Formula 
\[
\sum_{i=1}^{N}(\langle n,p_{i}\rangle-D)^{2}\Theta(\lVert p_{i}-q\rVert)
\]

\end_inset

 wobei 
\begin_inset Formula $q$
\end_inset

 die Projektion von 
\begin_inset Formula $r$
\end_inset

 auf 
\begin_inset Formula $H$
\end_inset

 ist.
 Bei 
\begin_inset Formula $\Theta$
\end_inset

 handelt es sich um eine monoton, radial, fallende Funktion mit positiven
 Wertebereich.
 Typischer weise 
\begin_inset Formula $\Theta(d)=e^{\frac{d^{2}}{h^{2}}}$
\end_inset

.
 
\begin_inset Formula $h$
\end_inset

 ist typischer Weise der durchschnittliche Abstand von benachbarten Punkten
 und hat einen direkten Einfluss wie glatt die Oberfläche erscheint.
\end_layout

\begin_layout Enumerate
Mit Hilfe von 
\begin_inset Formula $H$
\end_inset

 kann nun ein zwei zweidimensionales Polynom zum Abschätzen der Umgebung
 von 
\begin_inset Formula $S_{A}$
\end_inset

 in der Nähe von 
\begin_inset Formula $r$
\end_inset

 gefunden werden.
\begin_inset Formula 
\[
\sum_{i=1}^{N}(g(x_{i},y_{i})-f_{i})^{2}\Theta(\lVert p_{i}-q\rVert))
\]

\end_inset

Hier ist 
\begin_inset Formula $f_{i}$
\end_inset

 der kürzeste Weg von 
\begin_inset Formula $H$
\end_inset

 zu 
\begin_inset Formula $p_{i}$
\end_inset

.
 Bei 
\begin_inset Formula $x_{i}$
\end_inset

und 
\begin_inset Formula $y_{i}$
\end_inset

handelt es sich um die Koordinaten von Punkt 
\begin_inset Formula $q_{i}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Die Projektion von 
\begin_inset Formula $r$
\end_inset

 ist schlussendlich wie folgt definiert.
\begin_inset Formula 
\[
\phi(r)=q+g(0,0)n
\]

\end_inset


\end_layout

\begin_layout Standard
Neben dem Darstellen von Punkten kann das Verfahren auch eingesetzt werden
 um weitere Punkte zu generieren.
 
\end_layout

\begin_layout Standard
Beim rendern wird eine Datenstruktur wie bei dem QSplat Verfahren verwendet.
 Unterscheiden tun sich die Blätter.
 In denen werden zusätzlich zur Position, Radius, Normalen und Farbe auch
 eine Referenzebene 
\begin_inset Formula $H$
\end_inset

 sowie die Koeffizienten des Polynoms gespeichert.
\end_layout

\begin_layout Standard
Wenn bei dem Render Vorgang ein Blatt erreicht wird und wenn mehr als ein
 Punkt benötigt wird werden mit Hilfe des Polynoms weiter Punkte für die
 Umgebung generiert.
\end_layout

\begin_layout Section
Minimum bounding box
\end_layout

\begin_layout Standard
In der Geometrie versteht man unter einer 
\begin_inset Quotes gld
\end_inset

minimum bounding box
\begin_inset Quotes grd
\end_inset

 ein Rechteck(2d) oder Box(3d) welches eine Menge von Punkten umschließt.
 Dabei ist der die Fläche bzw.
 das Volumen minimal.
\end_layout

\begin_layout Section
Proxy Design Pattern
\begin_inset CommandInset label
LatexCommand label
name "sub:Proxy-Design-Pattern"

\end_inset


\end_layout

\begin_layout Standard
Bei einem Proxy(siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UML-Proxy-Pattern"

\end_inset

) 
\begin_inset CommandInset citation
LatexCommand citep
key "Gamma:1995:DPE:186897"

\end_inset

 handelt es sich um ein Objekt welches als eine Schnittstelle zu etwas anderem
 agiert.
 Zum Beispiel mit einer größeren Datei oder einer anderen teuren Ressource.
\end_layout

\begin_layout Standard
Ein klassisches Beispiel sind Platzhalter für Bilder, welche noch nicht
 fertig geladen wurden, auf Webseiten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/Proxy_pattern_diagram.svg
	width 50text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
UML Proxy Pattern
\begin_inset CommandInset label
LatexCommand label
name "fig:UML-Proxy-Pattern"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Singleton Pattern
\begin_inset CommandInset label
LatexCommand label
name "sec:Singleton-Pattern"

\end_inset


\end_layout

\begin_layout Standard
-
\end_layout

\begin_layout Section
Representational state transfer
\begin_inset CommandInset label
LatexCommand label
name "sub:Representational-state-transfer"

\end_inset


\end_layout

\begin_layout Standard
Representational state transfer(REST) ist ein Programmierparadigma für Service
 orientierte verteilte Systeme.
 REST wurde im Jahr 2000 von Roy Fielding in seiner Doktorarbeit 
\begin_inset CommandInset citation
LatexCommand cite
key "Fielding:2000:ASD:932295"

\end_inset

 wie folgt beschrieben.
 REST definiert sich über eine Menge von Beschränkungen bei der Kommunikation
 von Komponenten.
 Das prominentest Beispiel ist das World Wide Web.
\end_layout

\begin_layout Standard
Die Beschränkungen werden im folgendem kurz vorgestellt.
\end_layout

\begin_layout Subsubsection*
Client-Server Model
\end_layout

\begin_layout Standard
Nach Andrews 
\begin_inset CommandInset citation
LatexCommand cite
key "Andrews:1991:PPI:103162.103164"

\end_inset

 ist der Client ein auslösender Prozess und der Server ein reagierender
 Prozess.
 Clienten stellen Anfragen auf welcher der Server reagiert.
 Der Client kann entscheiden wann er mit dem Server interagiert.
 Der Server wiederum muss auf Anfragen warten und dann auf diese reagieren.
 Oft ist ein Server auf nicht endender Prozess welcher auf mehrere Clienten
 reagiert.
\end_layout

\begin_layout Subsubsection*
Zustandslosigkeit
\end_layout

\begin_layout Standard
Jede Anfrage vom Clienten muss alle Informationen enthalten welche Notwendig
 sind um die Anfrage zu verarbeiten.
 Des weiteren darf kein gespeicherter Kontext auf dem Server vorliegen auf
 welchen Bezug genommen wird.
 Alle Zustände werden auf dem Clienten gespeichert.
\end_layout

\begin_layout Subsubsection*
Caching
\end_layout

\begin_layout Standard
Server Antworten müssen implizit oder explizit als cachebar gekennzeichnet
 sein.
 Die Idee ist den Netzwerkverkehr effizienter zu machen.
 Bemerkenswert dabei ist das dadurch ganze Interaktionen wegfallen können.
\end_layout

\begin_layout Subsubsection*
Einheitliche Schnittstelle
\end_layout

\begin_layout Standard
Ein integraler Bestandteil einer REST Architektur ist eine einheitliche
 Schnittstelle.
 Das vereinfacht die System Architektur und die Sichtbarkeit von Interaktionen
 ist verbessert.
 Sie ist durch 4 weitere Eigenschaften beschrieben.
\end_layout

\begin_layout Subparagraph
Adressierbarkeit von Ressourcen
\end_layout

\begin_layout Standard
Jede Information, die über einen URI kenntlich gemacht wurde, wird als Ressource
 gekennzeichnet.
 Die Ressource selbst wie in einer Repräsentation übertragen welche sich
 von der internen Repräsentation unterscheidet.
 Jeder REST-konforme Dienst hat eine eindeutige Adresse, den Uniform Resource
 Locator (URL).
\end_layout

\begin_layout Subparagraph
Repräsentationen zur Veränderung von Ressourcen
\end_layout

\begin_layout Standard
Wenn ein Client die Repräsentation einer Ressource besitzt mit seinen Metadaten,
 reicht dies aus um die Ressource zu modifizieren bzw zu löschen.
 
\end_layout

\begin_layout Subparagraph
Self-descriptive messages
\end_layout

\begin_layout Standard
Jede Nachricht enthält beschreibt wie seine Informationen zu verarbeitet
 sind.
 Z.B durch Angabe seine Internet Media Types(MIME-Type)
\end_layout

\begin_layout Subparagraph
„Hypermedia as the Engine of Application State
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Bei „Hypermedia as the Engine of Application State
\begin_inset Quotes grd
\end_inset

 HATEOAS navigiert der Client einer REST-Schnittstelle ausschließlich über
 URLs, welche vom Server bereitgestellt werden.
 Abhängig von der gewählten Repräsentation geschieht die Bereitstellung
 der URIs über Hypermedia.
 Abstrakt betrachtet stellen HATEOAS-konforme REST-Services einen endlichen
 Automaten dar, dessen Zustandsveränderungen durch die Navigation mittels
 der bereitgestellten URIs erfolgt.
 Durch HATEOAS ist eine lose Bindung gewährleistet und die Schnittstelle
 kann verändert werden.
 
\end_layout

\begin_layout Subsubsection*
Mehrschichtige Systeme
\end_layout

\begin_layout Standard
Der Client soll lediglich die Schnittstelle kennen.
 Schichten dahinter bleiben ihm verborgen.
\end_layout

\begin_layout Chapter
Verwandte Arbeiten
\end_layout

\begin_layout Standard
Das Interesse an der Darstellung von großen Punktwolken ist durch das Aufkommen
 von modernen 3D Scanner und der 3D Rekonstruktion in den letzten Jahrzehnt
 stark gewachsen.
 Durch den Anstieg der Leistungsfähigkeit von Tablets wurde schon einige
 Ansätze für die Darstellung von sehr großen Punktwolken gemacht.
 Allerdings kann keine bestehende Arbeit alle Anforderungen erfüllen.
\end_layout

\begin_layout Section
KiwiViewer
\end_layout

\begin_layout Standard
KiwiViewer 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.kiwiviewer.org/
\end_layout

\end_inset


\end_layout

\end_inset

 ist eine freie quelloffene Applikation zur Erkundung von Punktwolken.
 Die App ist für Android sowie iOS verfügbar.
 Multi-Touch Gestensteuerung wird unterstützt.
 KiwiViewer bedient sich der 
\begin_inset Quotes eld
\end_inset

Point Cloud Library
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://pointclouds.org/
\end_layout

\end_inset


\end_layout

\end_inset

 für seine Kernfunktionen.
 Die Punktmenge wird entweder über eine SD-Karte, eMail oder URL geladen.
\end_layout

\begin_layout Paragraph

\emph on
Abgrenzung
\end_layout

\begin_layout Standard
Die App speichert die geladenen Punkte direkt auf dem Tablet.
 Modelle werden nicht vereinfacht.
 Daher treffen Modelle mit mehreren Millionen Punkten schnell an die Grenzen
 der GPU.
\end_layout

\begin_layout Section
LiMo
\end_layout

\begin_layout Standard
Bei LiMo handelt es sich um eine von OGSystems entwickelte Android Applikation
 zum Betrachten von LiDAR Daten.
 LiMo wurde für den professionellen Gebrauch entwickelt und ermöglicht das
 Beobachten von Gebäuden sowie Naturszenen.
 Daten können auch über einen eigen Webservice gestreamt werdenm weshalb
 die App auch zu Monitoring Zwecken eingesetzt werden kann.
\end_layout

\begin_layout Standard
Die Applikation unterstützt bis zu 5 Millionen Punkte.
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Die App ist auf LiDAR Daten beschränkt.
 LiDAR ist primär zum scannen von großen Objekten, wie Brücken , geeignet
 und verfügt daher nicht über die Genauigkeit welche Beispielsweise bei
 einer Skulptur benötigt wird.
\end_layout

\begin_layout Section
QSplat Verfahren
\end_layout

\begin_layout Standard
Erste Vorschläge zur Darstellung von sehr großer Punktmengen wurden durch
 das QSplat 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2000:QMP:344779.344940"

\end_inset

 Verfahren gemacht.
 Die Punkteenge wird durch eine 'Multiresolution' Hierarchie auf Basis von
 'bounding spheres' modelliert.
 Abhängig von der Kameraposition wird die Struktur bis zu einer gewissen
 Tiefe (Detailstufe) durchlaufen.
 Das Verfahren kann modifiziert auch zum Streaming von Punktwolken genutzt
 werden 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2001:SQV:364338.364350"

\end_inset

 .
 
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Für HD Displays ist der Algorithmus zu rechenintensiv weil die Berechnung
 pro Display Punkt von der CPU erledigt wird.
 
\end_layout

\begin_layout Section
Multiresolution Octree
\end_layout

\begin_layout Standard
Die Arbeit 
\begin_inset CommandInset citation
LatexCommand cite
key "Wand:2008:SSP:1363373.1363581"

\end_inset

 war eine Kooperation zwischen der Stanford Universität und der Universität
 Tübingen.
\end_layout

\begin_layout Standard
Die Veröffentlichung stellte einen Multiresolution Octree (siehe Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Multiresolution-Octree"

\end_inset

) gekoppelt mit out-of-core Mechanismen vor zur Darstellung von enorm großen
 Punktwolken vor.
 Für das das out-of-core Verfahren wird ein Least recently used Cache verwendet.
 Sind angeforderte Daten nicht im Cache enthalten werden sie von der Festplatte
 geladen.
 Dadurch ist die Größe der Punktdaten lediglich nur durch dieses Speichermedium
 beschränkt.
 Anders als bestehende Ansätze bietet die Datenstruktur Operation wie Löschen
 und Einfügen von Punkten unabhängig von der Komplexität der Szene.
 Des weiteren wird ein System zum Bearbeiten von Punktwolken diskutiert.
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Die Arbeit beschreibt ein Verfahren für Desktop Systeme.
 Eigenarten von mobilen Geräten werden nicht berücksichtigt.
 Das Verfahren ist sehr speicherintensiv und kann daher nicht ohne weiter
 auf ein mobiles Gerät übertragen werden.
\end_layout

\begin_layout Section
Knn-Tree iOS
\end_layout

\begin_layout Standard
Eine weitere Möglichkeit ist ein Knn-Tree zu verwenden 
\begin_inset CommandInset citation
LatexCommand cite
key "VAST:VAST12:057-064"

\end_inset

.
 Allerdings mit der Beschränkung, dass die Punktmenge von Anfang an vollständig
 ist.
\end_layout

\begin_layout Standard
Diese Arbeit richtet sich besonders an die Darstellung auf mobilen Geräten.
 Die Datenstruktur selbst wird auf einem Server gespeichert.
 Knoten werden auf Anfrage eines Clients übertragen.
\end_layout

\begin_layout Standard
Übertragende Knoten werden mit Hilfe eines LRU-Cache gespeichert.
 Die Implementierung erfolgte in C++ und OpenGl ES.
 Für die Netzwerkkommunikation wir 'http pipelining' sowie eine Wavletkompressio
n verwendet.
 
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Die Datenstruktur ist nicht dynamisch, also die Menge der Punkte muss von
 Anfang an fest stehen.
 Implementierung erfolgte in C++ und für iOS.
 Die Datenstruktur bietet den Vorteil das sie eine geringe Tiefe besitzt.
\end_layout

\begin_layout Chapter
Frameworks, Programmiersprachen und Laufzeitumgebung
\end_layout

\begin_layout Standard
Im folgendem werden die Technologien, Begriffe und Frameworks vorgestellt
 welche in der Arbeit verwendet werden.
\end_layout

\begin_layout Section
Java
\end_layout

\begin_layout Standard
Bei Java 
\begin_inset CommandInset citation
LatexCommand citep
key "gosling1995java"

\end_inset

 handelt es sich um eine 1995 von Sun Microsystems veröffentliche Programmierspr
ache.
 Entwickelt wurde die Sprache von James Gosling.
 Java ist Objektorientiert, nebenläufig und plattformunabhängig.
 Letzteres wird erreicht indem Java Code, genauer gesagt Java Byte Code,
 auf einer virtuellen Maschine (JVM) interpiretiert wird.
 Moderne Implementierungen der JVM unterstützen sogenannte 
\begin_inset Quotes gld
\end_inset

Just in Time
\begin_inset Quotes grd
\end_inset

 Kompilierung.
 Das bedeutet, dass eine Übersetzung in Maschinencode während der Laufzeit
 vorgenommen wird.
\end_layout

\begin_layout Standard
Des weiteren kümmert die Laufzeitumgebung von Java um das Speicher Management.
 Nach dem Tiobe Index zu urteilen ist Java eine der populärsten Programmiersprac
hen der Welt
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.tiobe.com/tiobe_index?page=Java
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Android
\end_layout

\begin_layout Standard
Android
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.android.com/
\end_layout

\end_inset


\end_layout

\end_inset

 ist ein mobiles Betriebssystem welches momentan von Google entwickelt wird.
 Es wurde mit 33 Mitgliedern der Open Handset Alliance entwickelt.
 Ziel war es einen offenen Standard für mobile Geräte zu schaffen
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.openhandsetalliance.com/press_110507.html
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Android baut auf dem Linux Kernel auf und ist für eine Bedienung über Touchdispl
ays ausgelegt.
 Daher werden Eingaben hauptsächlich über Gesten und Tippen am Display vorgenomm
en.
 Android verfügt über Ableger für Fernseher(Android TV), Autos (Android
 Auto) sowie Smartwatches(Android Wear).
 Android hat seit mehreren Jahren einen dominanten Marktanteil
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.idc.com/prodserv/smartphone-os-market-share.jsp
\end_layout

\end_inset


\end_layout

\end_inset

 bei mobile Geräten und ist das mit Abstand meist genutzt Betriebssystem
 weltweit
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Usage_share_of_operating_systems
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Java ist die bevorzugte wenn auch nicht einzig mögliche Programmiersprache
 für Android.
 Allerdings kommt bei Android keine Standard JVM zum Einsatz sondern eine
 modifizierte Version.
 Bis Android 4.4 kam die Virtuelle Maschine Dalivk zum Einstatz.
 Diese wurde vollständig in Android 5.0 ersetzt durch Android Runtime(ART)
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://developer.android.com/about/versions/android-5.0-changes.html
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Google Protocol Buffers
\end_layout

\begin_layout Standard
Bei Google Protocol Buffers
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://developers.google.com/protocol-buffers/
\end_layout

\end_inset


\end_layout

\end_inset

 handelt es sich um eine Plattform unabhängige Datenstruktur zum Serialisieren
 von Daten.
 
\end_layout

\begin_layout Standard
Die Datenstruktur wird in einem einheitlichen Schema festgelegt.
 Zum Beispiel:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

message Person {   
\end_layout

\begin_layout Plain Layout

	required string name = 1;   
\end_layout

\begin_layout Plain Layout

	required int32 id = 2;   
\end_layout

\begin_layout Plain Layout

	optional string email = 3;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Schema definiert Namespaces über diese dann die eigentlich Daten ausgelesen
 werden können.
 In dem Beispiel hat der Datentyp Person drei Felder.
 Jedes dieser Felder ist getypt und mit einem Schlüsselwort versehen welches
 angibt ob das Feld Pflicht ist.
\end_layout

\begin_layout Standard
Es besitzt also jede Person einen String für den Namen aber nicht immer
 einen String für die Mail.
\end_layout

\begin_layout Standard
Aus dem Schema kann für jede unterstützte Programmiersprache(Java, C++,
 Python, JavaNano, Ruby, Objective-C und C#) Klassen generiert werden welche
 die Daten (de)serialisieren.
 Das macht es möglich Clienten in anderen Sprachen zu schreiben.
\end_layout

\begin_layout Standard
Protocol Buffers sind komplett abwärtskompatibel.
 Die Schema können problemlos erweitert werden.
\end_layout

\begin_layout Standard
Ein weiter Vorteil ist der merklich verringerte Overhead im Vergleich zu
 JSON oder XML.
 Nachteilig ist das die übertragenden Daten nicht ohne weiteres für einen
 Menschen lesbar sind.
 Protocol Buffers werden intensiv intern bei Google selbst eingesetzt.
 Ein weiter prominenter Nutzer ist Blizzard beim 
\begin_inset Quotes gld
\end_inset

BATTLE.NET
\begin_inset Quotes grd
\end_inset

 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://news.ycombinator.com/item?id=11444846
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Open Graphics Library for Embedded Systems
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Open Graphics Library for Embedded Systems (OpenGL ES) bietet ein offenes
 Interface für Grafikhardware.
 Dieses besteht aus einer Sammlung von Prozeduren und Funktion die es dem
 Programmierer ermöglichen Shaderprgramme, Objekte und Operation zu spezifiziere
n um dreidimensionale Farbbilder zu produzieren.
 Viele der Funktion von OpenGL ES implementieren das Zeichnen von geometrischen
 Objekten wie Punkte oder Linien.
 OpenGL ES setzt voraus das die Grafikhardware über einen Framebuffer verfügt.
\end_layout

\begin_layout Subsection
Vertex
\end_layout

\begin_layout Standard
Unter einem Vertex(plural die Vertices) versteht man eine Datenstruktur
 welche einen zwei- oder dreidimensinalen Punkt im Raum beschreibt.
\end_layout

\begin_layout Subsection
Shader
\end_layout

\begin_layout Standard
Bei Shadern handelt es sich um vom Nutzer geschriebene Programme welche
 an unterschiedlichen Station der Rendering Pipeline aufgerufen werden.
 Shader werden in der C nahen OpenGL Shading Language geschrieben.
\end_layout

\begin_layout Subsection
Pipeline
\end_layout

\begin_layout Standard
Der Vorgang des Renderings lässt sich vereinfacht als Datenverarbeitung
 von nacheinander folgenden Stufen darstellen.
\end_layout

\begin_layout Paragraph
Vertex Spezifikation
\end_layout

\begin_layout Standard
In diesem Schritt werden wird ein Stream von Vertices für OpenGL vorbereitet.
 Dazu muss festgelegt werden, um was für ein Grundobjekt(Primitive) die
 Daten darstellen.
 Beispiele sind Punkte, Linien oder Dreiecke.
\end_layout

\begin_layout Paragraph
Vertex Shader
\end_layout

\begin_layout Standard
Dieser Shader erhält einzelne Elemente aus dem Vertexstream und gibt dann
 ein einzelnes Vertex aus.
 Der Shader wird vom Benutzer Programmiert.
 Typischer Weise wird hier die Projektionsmatrix auf die Punkte angewendet.
\end_layout

\begin_layout Paragraph
Tessellation
\end_layout

\begin_layout Standard
In dieser optionalen Stufe werden Patch(ein Primitve für Tesselation) in
 mehrere kleinere Primitives zerlegt.
\end_layout

\begin_layout Paragraph
Geometry Shader
\end_layout

\begin_layout Standard
Der optionale Geometry Shader erhält als Eingabe eine Primitive und gibt
 keine oder mehr Primitives zurück.
 
\end_layout

\begin_layout Paragraph
Vertex Post-Processing
\end_layout

\begin_layout Standard
In diesem Schritt werden Teile außerhalb des Kamerafensters verworfen, dieser
 Prozess nennt sich Clipping.
 In dieser Stufe werden werden die dreidimensionalen Koordinaten zu zweidimensio
nalen Kamerakoordinaten umgerechnet.
\end_layout

\begin_layout Paragraph
Primitive Assembly
\end_layout

\begin_layout Standard
Diese Stufe erstellt teilt Primitves zu einer Sammlung von finalen kleinsten
 Primitves.
 Zum Bespiel wird aus einer Liste von Vertices vom Primitive Typ GL_LINE_STRIP
 mit 8 Mitglieder 7 neue Primitives vom Typ 
\begin_inset Quotes gld
\end_inset

line base
\begin_inset Quotes grd
\end_inset

.
\end_layout

\begin_layout Paragraph
Rasterization
\end_layout

\begin_layout Standard
In diesem Schritt werden die Primitives in diskrete Elemente unterteilt(geraster
t).
 Diese nennt man Fragmente.
\end_layout

\begin_layout Paragraph
Fragment Shader
\end_layout

\begin_layout Standard
Die Fragmente aus der Raster bildet den Input dieses Shaders.
 Die Ausgabe ist ein Farb-, Tiefen und sogenannter Stencilwert.
\end_layout

\begin_layout Paragraph
Per-Sample Operations
\end_layout

\begin_layout Standard
Anschließend kann für den Output vom Fragment Shader eine Anzahl von Test
 ausführen.
 Beispielsweise der Tiefen Test(Depth Test) um zu vermeiden das Objekte
 welche verdeckt sind gezeichnet werden.
 Andere Test sind Scissor Test, Stencil Test und der Pixel Ownership Test.
\end_layout

\begin_layout Section
NanoHTTPD
\begin_inset CommandInset label
LatexCommand label
name "sub:NanoHTTPD"

\end_inset


\end_layout

\begin_layout Standard
NanoHTTPD
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/NanoHttpd/nanohttpd
\end_layout

\end_inset


\end_layout

\end_inset

 bezeichnet sich selbst als einen schlanker HTTP Server welche darauf ausgericht
et ist, sich einfach in bestehende Anwendungen einbetten zu lassen.
\end_layout

\begin_layout Standard
Das Project ist Open Source und wird aktiv auf github entwickelt.
\end_layout

\begin_layout Section
la4j
\end_layout

\begin_layout Standard
La4j
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://la4j.org/
\end_layout

\end_inset


\end_layout

\end_inset

 ist eine aus einem Studentenprojekt entstandene offene Java Bibliothek.
 Die Bibliothek liefert Objekte für Lineare Algebra(Matrizen und Vektoren)
 und Algorithmen.
\end_layout

\begin_layout Section
DEFLATE
\end_layout

\begin_layout Standard
Bei DEFLATE 
\begin_inset CommandInset citation
LatexCommand citep
key "Deutsch:1996:DCD:RFC1951"

\end_inset

 handelt es sich um einen Kompression Algorithmus von Phil Katz aus dem
 Jahre 1993.
 Er kombiniert die die Kompressions Algorithmen LZ77 oder LZSS mit einer
 Huffman Kodierung.
 Der Algorithmus zeichnet such durch eine solide Kompression in kurzer Zeit
 aus.
 Der Algorithmus findet zum Beispiel im .png Format Anwendung.
\end_layout

\begin_layout Section
Volley 
\begin_inset CommandInset label
LatexCommand label
name "sub:Volley"

\end_inset


\end_layout

\begin_layout Standard
Bei Volley 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://developer.android.com/training/volley/index.html
\end_layout

\end_inset


\end_layout

\end_inset

 handelt es sich um ein HTTP Bibliothek zum Verwalten von Netzwerkanfragen.
 Volley bietet automatisches koordinieren von Anfragen.
 Es ermöglicht mehrere neben läufige Netzwerkverbindungen, Anfragen Priorisierun
g und einiges mehr.
\end_layout

\begin_layout Standard
Die Bibliothek ist frei und wird unter diesem Link 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://android.googlesource.com/platform/frameworks/volley
\end_layout

\end_inset


\end_layout

\end_inset

 entwickelt.
\end_layout

\begin_layout Chapter
Gewählter Lösungsansatz
\end_layout

\begin_layout Standard
Mobile Geräte verfügen über begrenzte Ressourcen was Rechenleistung und
 Speicher angeht.
 Punktwolken mit mehr als einer Million Punkte bringen die GPU schnell an
 Ihre Grenzen.
 Daher wurde ein Ansatz gewählt, der es ermöglicht präzise Punkte auszuwählen.
 Dabei unterscheiden wir zwischen 2 Dimension.
 Zum einem die Sichtbarkeit und zum anderen die Detailstufe der Punkte.
 Zum ermitteln der Punkte nach diesen Kriterien kommt ein Multi-Resolution
 Octree(siehe Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Multiresolution-Octree"

\end_inset

) zum Einsatz.
 Dadurch wird die GPU effizient eingesetzt.
 
\end_layout

\begin_layout Standard
Die Defizite beim Speicher werden durch eine Client-Server Architektur ausgeglic
hen (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Übersicht"

\end_inset

).
 Das eigentliche Model wird von einem Server verwaltet.
 Der Mobile Client hat selber nur den momentan benötigten Satz Punkte gespeicher
t.
 Um Netzwerkverkehr niedrig zu halten werden die Punkte von Client in einem
 Cache nach dem 
\begin_inset Quotes gld
\end_inset

Least recently used
\begin_inset Quotes grd
\end_inset

 Prinzip gespeichert.
 Zum Rendern werden die Punkte als 
\begin_inset Quotes gld
\end_inset

vertex buffer object
\begin_inset Quotes grd
\end_inset

 in den Speicher der GPU geschrieben und anschließend gezeichnet.
 Ein Vorteil der Client Sever Architektur ist das mehrere
\end_layout

\begin_layout Standard
Als Programmiersprache wurde Java gewählt aufgrund des guten Kompromisses
 aus Portabilität und Performance sowie der guten Integration in das Android
 Betriebssystem.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/architektur.svg
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Übersicht"

\end_inset

Übersicht
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Server
\end_layout

\begin_layout Standard
Der Server hat drei Aufgaben.
 Zum ersten erstellt er aus gegebenen Punkten einen MRT.
 Seine zweite Aufgabe ist es Punktanfragen zu bedienen und als letztes ein
 Proxy Objekt (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Proxy-Design-Pattern"

\end_inset

) des MRT an die Klienten zu verteilen.
\end_layout

\begin_layout Standard
Zur Interaktion stellt der Server ein RESTful Interface auf Basis des HTTP
 Protokolls bereit.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Warum nicht normaler Socketverkehr
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Multi Resolution Tree
\end_layout

\begin_layout Standard
Der MultiResolution Tree besteht aus 4 Klassen (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Multiresolution-Tree-UML"

\end_inset

).
 Die Klasse 
\begin_inset Quotes eld
\end_inset

MultiResolutionTree
\begin_inset Quotes erd
\end_inset

 dient als Schnittstelle für alle äußeren Komponenten.
 Dadurch ist eine sinnvolle Kapselung gewährleistet.
 Sie beherbergt einen Zeiger auf den Wurzelknoten des MRT.
 Des weiteren legt sie einen Index von den Knoten an um schnellen Zugriff
 zu ermöglichen.
 Zusätzlich existiert einer Factory Methode zum erstellen von Google Protocol
 Buffer Objekten.
\end_layout

\begin_layout Standard
Die Implementierung des MRT ist analog zu der Beschreibung in Kapitel
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Multiresolution-Octree"

\end_inset

.
 Jeder Knoten besitzt eine ID.
 Diese sind die Koordinaten seines absoluten Mittelpunkts.
 Erwähnenswert sind die Entscheidungen bei der Raster Klasse.
 Die Rasterwerte sind in einer interne DefaultHashMap vermerkt.
 Diese bildet einen dreidimensionalen Vektor auf Farbwerte und Gewicht ab.
 Bei einer DefaultHashMap werden bei Abfrage von nicht existierender Einträge
 Standartwerte zurück gegeben.
 Dadurch wird im Vergleich zu einem 
\begin_inset Formula $n^{3}$
\end_inset

Array Speicherplatz gespart.
 Der eigentliche Rastervorgang wird durch die folgende Hashfunktion erreicht.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
H(p)=(\left\lfloor \frac{x(p)}{cellLength}\right\rfloor ,\left\lfloor \frac{y(p)}{cellLength}\right\rfloor ,\left\lfloor \frac{z(p)}{cellLength}\right\rfloor )
\]

\end_inset


\end_layout

\begin_layout Standard
wobei die Koordinate von 
\begin_inset Formula $p$
\end_inset

 relativ zu Ursprung des Würfel ist.
 Die Variable
\begin_inset Formula $cellLength$
\end_inset

 entspricht der Länge einer Gitterzelle.
 Also:
\begin_inset Formula 
\[
cellLength=\frac{cube.length}{k}
\]

\end_inset


\end_layout

\begin_layout Standard
Einfach gesprochen werden die Koordinaten auf ein Vielfaches der 
\begin_inset Formula $cellLength$
\end_inset

 abgerundet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/MultiResolutionTreeUML.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Multiresolution-Tree-UML"

\end_inset

Multiresolution Tree UML
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit schnelle Zugriffe bei Anfragen auf die entsprechenden Knoten bzw.
 Punkte möglich sind existiert eine weitere Hashmap als Index.
 Dieser bildet Ids auf die entsprechenden Knoten ab.
 Der Index wird in nach einer festen Anzahl Einfüge Operationen aktualisiert.
\end_layout

\begin_layout Subsection
RESTful API
\end_layout

\begin_layout Standard
Unter einer RESTful API versteht man ein Webinterface welches die Beschränkungen
 von REST (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Representational-state-transfer"

\end_inset

) einhält.
\end_layout

\begin_layout Standard
Die API wurde mit Hilfe des NanoHTTPD Frameworks (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:NanoHTTPD"

\end_inset

) implementiert.
 NanoHTTPD wurde ausgewählt weil es schlank und einfach ist.
\end_layout

\begin_layout Standard
Ressourcen werden über GET Anfragen mit folgender Form abgerufen
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

GET SERVER_IP:PORT/?parameter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Werte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Erklärung
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes gld
\end_inset

proxy
\begin_inset Quotes grd
\end_inset

, 
\begin_inset Quotes gld
\end_inset

samples
\begin_inset Quotes grd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Definiert den Typ der Anfrage
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Id für Punktdaten
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Prinzipiell wird bei jeder Anfrage eine Fallunterscheidung an dem 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 Parameter gemacht.
 Die Anfragetypen werden im folgenden vorgestellt.
\end_layout

\begin_layout Subsubsection
MRT-Proxy Anfrage
\begin_inset CommandInset label
LatexCommand label
name "sub:MRT-Proxy-Anfrage"

\end_inset


\end_layout

\begin_layout Standard
Da die Ermittlung gebrauchten Punkte auf dem Klienten statt findet muss
 auch dieser in Kenntnis über die Struktur des MRTs sein.
 Aus diesem Grund Stellt der Server ein MRT-Proxy zur Verfügung.
 Der MRT-Proxy ist im Prinzip gleich dem Multiresolution Octree, allerdings
 haben seine Knoten keine Punkte oder Rasterung gespeichert, sondern nur
 Ids um beim Server die entsprechenden Punkte anzufragen.
 Diese können entweder Original Punkte aus Blättern sein oder Punkte aus
 der Rasterung.
\end_layout

\begin_layout Standard
Eine Anfrage wäre zum Beispiel:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

GET 192.168.2.1:8080/?mode=tree
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zum versendet wird aus der Datenstruktur ein Protocol Buffer Objekt erstellt.
 Diese kann dann problemlos serialisiert werden.
 Das Protocol Buffer Objekt ist wie folgt definiert.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package DataAccesLayer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

option java_outer_classname = "MultiResTreeProtos";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

message MRTree{
\end_layout

\begin_layout Plain Layout

	required MRNode root = 1;
\end_layout

\begin_layout Plain Layout

	message MRNode {
\end_layout

\begin_layout Plain Layout

		required string id = 1;    
\end_layout

\begin_layout Plain Layout

		repeated double center = 2 [packed=true];         
\end_layout

\begin_layout Plain Layout

		required double cellLength = 3;         
\end_layout

\begin_layout Plain Layout

		required int32 pointCount = 4;         
\end_layout

\begin_layout Plain Layout

		required bool isLeaf = 5;         
\end_layout

\begin_layout Plain Layout

		repeated MRNode octant = 6;     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Punktanfrage
\end_layout

\begin_layout Standard
Der 2.
 Typ Anfragen liefert Punkte an den Klienten aus.
 Bei dieser Anfrage wird vom Klienten immer eine Id als Parameter mitgesendet.
 Diese Id passt auf einen Knoten des MRT.
\end_layout

\begin_layout Standard
Falls es sich um ein inneren Knoten handelt wird die Rasterung zu einer
 Liste von Punkten exportiert.
 Beim einem Blatt wird lediglich auf die vorhandene Punktliste zugegriffen.
 
\end_layout

\begin_layout Standard
Der Server greift über die MultiResolutionTree Klasse auf den entsprechende
 Knoten zu und generiert ein Protocol Buffer Objekt.
 Die Spezifikation des Objektes lautet:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package DataAccesLayer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

option java_outer_classname = "RasterProtos";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

message Raster{     
\end_layout

\begin_layout Plain Layout

	repeated Point3DRGB sample = 1;
\end_layout

\begin_layout Plain Layout

	message Point3DRGB{         
\end_layout

\begin_layout Plain Layout

		repeated float position = 1;         
\end_layout

\begin_layout Plain Layout

		repeated float color = 2;         
\end_layout

\begin_layout Plain Layout

		required int32 size = 3;     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es handelt sich also um eine Liste von Punkten mit Positions-, Farb- und
 einer Gewichtswerten (size).
\end_layout

\begin_layout Standard
Alle Protocol Buffer Objekte werden bevor sie über das Netzwerk versendet
 werden serialisiert und durch den DEFLATE Algorithmus komprimiert, um den
 Netzwerkverkehr möglichst niedrig zu halten.
 
\end_layout

\begin_layout Section
Client
\end_layout

\begin_layout Standard
Bei dem Client handelt es um eine Android Anwendung.
 Der Client ist verantwortlich für das Darstellen der Punktwolke und reagiert
 auf Eingaben des Users.
\end_layout

\begin_layout Standard
Der Client verfolgt eine eventbasierte Architektur.
 Wird vom Nutzer eine Translation(2-Finger Geste) oder Rotation(Slide Geste)
 an dem Punktmodel ausgeführt kann sich die Menge der zu zeichnenden Punkte
 ändern.
\end_layout

\begin_layout Standard
Die Menge der momentan zu zeichnenden Punkte wird im folgenden als aktive
 Punkte bezeichnet.
 Die Knoten, welche die aktiven Punkte beinhalten, werden als aktive Knoten
 bezeichnet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename uml/Client.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Client UML
\begin_inset CommandInset label
LatexCommand label
name "fig:Client-UML"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
UML Diagram
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Netzwerkverkehr
\end_layout

\begin_layout Subsubsection
DataAcessLayer Klasse
\end_layout

\begin_layout Standard
Bei der DataAcessLayer Klasse handelt es sich um ein Singleton(siehe Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Singleton-Pattern"

\end_inset

)welches als Schnittstelle für jeglichen Netzwerkverkehr fungiert.
 Sie verfügt über Funktion zum Anfordern von Punkten oder des MRT Proxy.
 Für asynchronen Anfragen kommt das 
\begin_inset Quotes gld
\end_inset

Volley Framework
\begin_inset Quotes grd
\end_inset

 zum Einsatz.
 (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Volley"

\end_inset

).
 Das Framework stellt eine Prioritätswarteschlange für HTTP Anfragen zur
 Verfügung.
 Volley ermöglicht es die Callback Funktion, welche nach Eintreffen einer
 Antwort aufgerufen wird, zu überschreiben, um eigene Logik zu definieren.
\end_layout

\begin_layout Standard
Die zwei Methoden der Klasse werden im folgendem vorgestellt.
\end_layout

\begin_layout Paragraph
buildMultiResTreeProtos(owner:MultiResTreeOwner)
\end_layout

\begin_layout Standard
Die Methode dekoriert eine Instanz welche das MultiResTreeOwner Interface
 implementiert (z.B RemotePointClusterGL) mit dem MRT-Proxy.
 
\end_layout

\begin_layout Standard
Als erster Schritt wird eine HTTP-Anfrage für den MRT Proxy an den Server
 gesendet.
 Beim Empfangen der Antwort werden die Daten deserialisiert und im Anschluss
 mit Hilfe einer Factory Methode zum MRT-Proxy gebaut.
 Die als Parameter übergebene Instanz erhält einen Zeiger auf den Proxy.
\end_layout

\begin_layout Paragraph
getSamples(id:String, cache:LRUDrawableCache)
\end_layout

\begin_layout Standard
Die Methode fordert Punktdaten vom Server an und speichert diese in einem
 Cache Objekt welches später zum Zeichnen der Punkte verwendet wird.
 Bei erhalten der Antwort werden die Daten zuerst dekomprimiert(DEFLATE)
 und deserialisiert.
 Im Anschluss werden die Farb-, Positions- und Gewichtswerte in einen nativen
 Buffer geschrieben damit OpenGL bei Bedarf darauf zugreifen kann.
\end_layout

\begin_layout Subsection
Rendering
\end_layout

\begin_layout Subsubsection
Shader
\end_layout

\begin_layout Standard
Die Shader sind als Textdatei in dem Android Ressourcen gespeichert.
 Bei der Initialisierung der OpenGL View Instanz werden sie kompiliert und
 gelinkt.
 Im folgendem werden die Shader vorgestellt.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# vertex_shader.glsl
\end_layout

\begin_layout Plain Layout

attribute vec3 a_Position; 
\end_layout

\begin_layout Plain Layout

attribute vec3 a_Color; 
\end_layout

\begin_layout Plain Layout

attribute float a_Size; 
\end_layout

\begin_layout Plain Layout

uniform mat4 u_Matrix; 
\end_layout

\begin_layout Plain Layout

varying vec4 v_Color;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void main() {     
\end_layout

\begin_layout Plain Layout

	v_Color = vec4(a_Color, 1.0);     
\end_layout

\begin_layout Plain Layout

	gl_Position = u_Matrix * (vec4(a_Position, 1.0));     
\end_layout

\begin_layout Plain Layout

	gl_PointSize = min(4.0, sqrt(a_Size)); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In dem Vertex Shader werden die Postionen der Punkte mit der Projektionsmatrix
 multipliziert und an die nächste Stufe der OpenGL Pipeline weiter gegeben.
 Des weiteren wird die Größe der zu zeichnenden Punktes berechnet.
 Es wird die Wurzel gezogen um sehr große Werte abzuschwächen.
 Durch die min() Funktion wird eine obere Grenze von 4 eingeführt.
 Das ist nötig den bei sehr detaillierten Objekten kann das Gewicht schnell
 sehr groß werden.
 Die Farbwerte werden einfach an den Fragment Shader durch eine varying
 Variable weitergereicht.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

precision mediump float;
\end_layout

\begin_layout Plain Layout

varying vec4 v_Color;
\end_layout

\begin_layout Plain Layout

void main() {     
\end_layout

\begin_layout Plain Layout

	gl_FragColor = v_Color; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Fragment Shader empfängt die Farbwerte und gibt sie weiter an die vorgegeben
e Variable gl_FragColor und legt damit den Farbwert des Fragmentes fest.
\end_layout

\begin_layout Subsubsection
Scene Klasse
\end_layout

\begin_layout Standard
Die Scene Klasse siehe(Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Client-UML"

\end_inset

)ist die Schnittstelle für alle Rendering relevanten Aktionen.
 Alle zu zeichnenden Objekte sowie die Kamera sind in dieser Klasse gespeichert.
 Nutzereingaben werden von dieser Klasse entgegengenommen und entsprechend
 verarbeitet.
\end_layout

\begin_layout Paragraph
drawScene()
\end_layout

\begin_layout Standard
Beim Aufruf der Methode wird die draw() Methode von jedem Element der Liste
 ausgelöst.
\end_layout

\begin_layout Subsubsection
CameraGL Klasse
\end_layout

\begin_layout Standard
-
\end_layout

\begin_layout Subsubsection
RemotePointClusterGL
\end_layout

\begin_layout Standard
Die RemotePointClusterGL kümmert sich um das Ermitteln aktiver Punkte mit
 Hilfe des MRT, dafür sind Verweise auf den Cache und dem MRT-Proxy gespeichert.
 Des weiteren greift die Klasse auf die DataAccesLayer Instanz zu, um entweder
 den MRT Proxy zu aktualisieren oder neuen Punkten anzufordern.
 Bei Initialisierung der Instanz wird der Proxy vom Server erfragt.
 Der gespeicherte LRU-Cache beinhaltet die Punktdaten
\end_layout

\begin_layout Standard
Immer wenn sich die Kameraposition ändert wird die updateCache() aufgerufen
 um den aktiven Knoten zu ermitteln.
\end_layout

\begin_layout Paragraph
updateCache()
\end_layout

\begin_layout Standard
Die Methode bestimmt die momentan aktiven Punkten bzw.
 Knoten mit Hilfe des Proxy Objektes.
\end_layout

\begin_layout Standard
Knoten(mit ihren Punkten) werden zu den aktiven Knoten hinzugefügt wenn
 folgende Kriterien erfüllt sind:
\end_layout

\begin_layout Itemize
die Punkte sind sichtbar
\end_layout

\begin_layout Itemize
die Auflösung der Punkte ist ausreichen oder schon Maximal
\end_layout

\begin_layout Standard
Um das zu erreichen wird der Proxy mit Hilfe des folgenden Algorithmus traversie
rt.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public List<String> getIdsViewDependent(){         
\end_layout

\begin_layout Plain Layout

	List<String> ids = new LinkedList<>();         
\end_layout

\begin_layout Plain Layout

	_getIdsViewDependent(root, ids);         
\end_layout

\begin_layout Plain Layout

	return ids;     V
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private void _getIdsViewDependent(OctreeNodeGL currentNode, List<String>
 ids) {      
\end_layout

\begin_layout Plain Layout

	if ((currentNode.isLeaf || 
\end_layout

\begin_layout Plain Layout

	currentNode.getDetailFactor(this.owner) < DETAIL_THRESHOLD)){           
  
\end_layout

\begin_layout Plain Layout

		ids.add(currentNode.id);             
\end_layout

\begin_layout Plain Layout

		return;         
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	for (OctreeNodeGL node : currentNode.octants ) {             
\end_layout

\begin_layout Plain Layout

		if (node.isVisible(owner) && node.pointCount > 0)         
\end_layout

\begin_layout Plain Layout

			_getIdsViewDependent(node, ids);
\end_layout

\begin_layout Plain Layout

	}     
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Einfach gesagt, besuche Knoten solange sichtbar bis entweder ein Blatt erreicht
 ist oder eine ausreichende Detailstufe.
 Bei dem Test auf Sichtbarkeit wird geprüft ob die projektierte Box (von
 einem Knoten) sich mit der View-Ebene schneidet.
 In jedem Schritt wird der detailFactor() ermitteln und mit einem festgelegten
 Schwellwert verglichen.
 Der 
\end_layout

\begin_layout Standard
Schwellwert ist experimentell ermittelt und kann abhängig von der Leistung
 des Gerätes gewählt werden.
 Sobald der detailFactor klein genug ist, gilt der Knoten als ausreichend
 aufgelöst und wird gezeichnet.
 Der 
\begin_inset Formula $\mbox{detaiFactor()}$
\end_inset

berechnet sich wie folgt.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
\align left

public float getDetailFactor(ModelGl m){             
\end_layout

\begin_layout Plain Layout
\align left

	float[] boundingBox = getBoundingBox(projectPoints(edgePoints,m.camera.projection
Matrix, m.camera.viewMatrix, m.getModelMatrix()));             
\end_layout

\begin_layout Plain Layout
\align left

	float[] centerProj = projectPoint(center, m.camera.projectionMatrix, m.camera.viewM
atrix, m.getModelMatrix());             
\end_layout

\begin_layout Plain Layout
\align left

	float zNorm = centerProj[2];             
\end_layout

\begin_layout Plain Layout
\align left

	return getArea(boundingBox) * 1/(zNorm * zNorm);        
\end_layout

\begin_layout Plain Layout
\align left

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der komplette Vorgang findet in einem eigenem Thread statt, damit der Nutzer
 nicht warten muss um neue Eingabe zu machen.
 Für die Verwaltung weiterer Threads kommt die von Java mitgelieferte ThreadPool
Executor Klasse zum Einsatz.
\end_layout

\begin_layout Standard
Nachdem alle nötigen Knoten festgestellt wurden, wird geprüft ob sich diese
 schon im Cache befinden.
 Falls nicht werde diese vom Server angefordert.
\end_layout

\begin_layout Paragraph
draw()
\end_layout

\begin_layout Standard
Zum zeichnen des Models wird die draw Methode aller aktiven Knoten im Cache
 aufgerufen.
 
\end_layout

\begin_layout Subsubsection
Drawable-Cache Klasse
\end_layout

\begin_layout Standard
Diese Klasse speichert und cached die Punktdaten vom Server.
 Des weiteren sendet sie Punktdaten als Vertex Buffer Object(VBO) an die
 GPU.
 Der Vorteil von VBOs liegt darin, dass Punktdaten nicht bei jedem Frame
 neu übermittelt werden müssen.
 Was die Performance stark verbessert.
 Schlussendlich wird in dieser Klasse das Zeichnen durch OpenGL initiiert.
\end_layout

\begin_layout Standard
Der Cache besitzt eine Prioritätswarteschlange von Knoten nach dem zuletzt
 benutzt Prinzip.
 Die Knoten besitzen die Punktdaten und einen Vermerk ob diese schon im
 Speicher der GPU gelandet sind.
 Die Positions-, Farb- und Gewichtsdaten werden in einem einzigen Buffer
 pro Knoten ineinander abgespeichert um die Performance zu verbessern 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLE
S_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVe
rtexData.html
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Beim zeichnen wird zuerst geprüft ob die Daten des Knoten schon als VBO
 auf der GPU sind.
 Falls ja werden die Punkte mit der folgenden Methode gezeichnet.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    public void draw(){
\end_layout

\begin_layout Plain Layout

        glDrawArrays(GL_POINTS, 0, pointCount);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
User Interface
\end_layout

\begin_layout Chapter
Experimente und Auswertung
\end_layout

\begin_layout Standard
-
\end_layout

\begin_layout Chapter
Zusammenfassung und Ausblick
\end_layout

\begin_layout Standard
-
\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "sources"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
