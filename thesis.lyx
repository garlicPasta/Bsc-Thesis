#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrreprt
\begin_preamble
\usepackage{url}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{pdfpages}



\title{\includegraphics[width=0.6\textwidth]{img/logo}\\
{\normalsize Bachelorarbeit am Institut für Informatik der Freien Universität Berlin}\\ DotViewer: Darstellung gigantischer Punktwolken auf Android Geräten}

\author{Jakob Krause\\
Matrikelnummer: 4573260 \\
jakobkrause@zedat.fu-berlin.de\\\\
Betreuung und Erstgutachten:\\ Prof. Dr. Marco Block-Berlitz\\
}
\date{\today}
\urlstyle{same}
\end_preamble
\options ngerman
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Java,frame=lrbt,numbers=left,showstringspaces=false,breaklines=true,xleftmargin=15pt,tabsize=2,basicstyle={\fontsize{9}{11}\ttfamily},keywordstyle={\color{blue}\ttfamily},stringstyle={\color{red}\ttfamily},commentstyle={\color{green}\ttfamily}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
maketitle 
\end_layout

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
vfill{}
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
includepdf[pages={1}]{pdf/erklaerung.pdf}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{page}{1} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Einleitung und Motivation
\end_layout

\begin_layout Standard
Das Interesse an der Darstellung von großen Punktwolken ist durch das Aufkommen
 von günstigen 3D-Scannern und der 3D-Rekonstruktion in den letzten Jahrzehnten
 stark gewachsen.
 Aufgrund der technologischen Entwicklungen in diesem Bereich ist es möglich
 von kleinen Objekten, wie einem Dinosaurierschädel bis hin zu ganzen Städten,
 Modelle in hoher Detailstufe digital zu erfassen.
 In der Denkmalpflege werden Objekte mittlerweile aus Routine abgescannt
 und archiviert.
 
\end_layout

\begin_layout Standard
Für gewöhnlich sind die erzeugten Modelle enorm groß und daher nicht ohne
 weiteres darstellbar.
 Die Modelle bestehen meist aus einer ungeordneten Sammlung von dreidimensionale
n Punkten mit Farbinformationen.
 Desktop-Lösungen verlassen sich zur Lösung des Problems auf Level-of-Detail
 (LOD) Konzepte kombiniert mit Out-of-core Verfahren und klugen Caching
 Strategien, um der hohen Datenmenge Herr zu werden.
 Durch das Aufkommen von leistungsstarken Smartphones entstand eine neue
 Plattform zum Darstellen von Modellen.
 
\end_layout

\begin_layout Standard
Daraus entstand eine Nachfrage durch Forschungsgruppen für eine mobile Applikati
on zum Betrachten großer Modelle.
 Die Applikation kann beispielsweise bei 3D-Rekonstruktion schnelles Feedback
 liefern, vereint mit den Vorzügen eines mobilen Gerätes.
 Dadurch können schnell unvollständige oder schwer zu erfassende Bereiche
 des Modells beim Scannen erkannt werden.
 Des Weiteren kann die Applikation zur Präsentation von Modellen eingesetzt
 werden.
\end_layout

\begin_layout Standard
Die Herausforderung bestand darin, trotz der Limitierungen eines Tablets
 durch seinen geringen Arbeitsspeicher und der relativ schwachen GPU, Punktwolke
n mit mehreren Millionen Punkten flüssig darzustellen.
 Dabei sollte es möglich sein, jederzeit neue Punkte in die bestehende Darstellu
ng hinzuzufügen.
 Zur Zeit existieren nur bedingt geeignete Softwarelösungen für das Problem.
\end_layout

\begin_layout Section
Archaeocopter und Archaeonautic Projekt
\begin_inset CommandInset label
LatexCommand label
name "subsec:Archaeocopter-Projekt"

\end_inset


\end_layout

\begin_layout Standard
Das Archaeocopter Projekt, welches 2012 von Dr.
 Benjamin Ducke und Prof.
 Dr.
 Marco Block-Berlitz ins Leben gerufen wurde, hat es sich zum Ziel gesetzt,
 ein unbemanntes Flugobjekt (UAV) zu entwickeln, welches durch halb-autonome
 Flüge Archäologen bei ihrer Arbeit durch Luftaufnahmen unterstützt.
 Aus diesen Aufnahmen lassen sich durch 3D-Rekonstruktion Modelle generieren.
 Diese Technik wird auch im Denkmalschutz angewandt.
\end_layout

\begin_layout Standard
Die Idee war es, aktuelle Verfahren aus Computervision und künstlicher Intellige
nz zusammen mit UAVs mit Kameras für die Datenerhebung einzusetzen.
 Das innovative Verfahren lässt sich auch unter Wasser einsetzen.
 Offiziell ging das Projekt im September 2012 mit Unterstützung von Prof.
 Dr.
 Raúl Rojas von Berlin's Freier Universität an den Start.
 Diese Arbeit ist in Zusammenarbeit mit dem Projekt entstanden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/slider008.jpg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ein UAV beginnt mit dem Filmen einer Landschaft.
 Aus dem Videomaterial kann später ein dreidimensionales Modell erstellt
 werden.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Ziele und Aufbau der Arbeit
\end_layout

\begin_layout Standard
Ziel dieser Arbeit ist eine mobile Applikation für das Android Betriebssystem
 zu entwickeln, welche die folgenden Anforderungen erfüllen soll:
\end_layout

\begin_layout Enumerate
flüssige Darstellung von Punktwolken mit mehreren Millionen Punkten 
\end_layout

\begin_layout Enumerate
neue Punkte können zur Laufzeit in die Darstellung hinzugefügt werden
\end_layout

\begin_layout Enumerate
Implementierung in Java
\end_layout

\begin_layout Enumerate
modularer Aufbau
\end_layout

\begin_layout Enumerate
einfache Nutzung
\end_layout

\begin_layout Standard
Dafür wird in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Theorie"

\end_inset

 ein Einblick in den Stand der Forschung mitsamt bestehender Arbeiten aus
 dem Feld gegeben.
 Bestehende Ansätze und Datenstrukturen werden mit den Anforderungen verglichen,
 um festzustellen, ob sie verwendbar sind.
 Im folgendem Kapitel werden in der Arbeit verwendete Technologien vorgestellt.
 Der Aufbau sowie die Implementierung der Applikation wird in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:dotViewer"

\end_inset

 beschrieben.
 In Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Experimente-und-Auswertungen"

\end_inset

 wird die Bildrate und Bildqualität der Applikation anhand zweier Beispielmodell
e evaluiert.
 Im letzten Kapitel wird die Arbeit zusammengefasst.
 Des Weiteren werden mögliche Verbesserungen vorgestellt.
\end_layout

\begin_layout Standard
Der Quellcode wird nach Abschluss dieser Arbeit über die Entwicklungsplattform
 Github
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.github.com
\end_layout

\end_inset


\end_layout

\end_inset

 frei zugänglich gemacht.
\end_layout

\begin_layout Chapter
Theorie und verwandte Arbeiten
\begin_inset CommandInset label
LatexCommand label
name "sec:Theorie"

\end_inset


\end_layout

\begin_layout Standard
In diesem Kapitel werden Grundlagen zum Verstehen der Arbeit und des Kontextes
 vorgestellt.
 Es wird eine kurze Einführung in die 3D-Rekonstruktion gemacht.
 Des Weiteren werden Punktwolken sowie deren Repräsentationen diskutiert.
 Anschließend werden bestehende Arbeiten diskutiert.
 Zum Abschluss werden genutzte Entwurfsmuster und Architekturstile vorgestellt.
\end_layout

\begin_layout Section
Einführung in die 3D-Rekonstruktion
\end_layout

\begin_layout Standard
Die Idee, aus einer Folge von Bildern ein 3D-Modell zu errechnen, ist eines
 der Kernthemen der Computervision.
 Verwendungen dieser Technik sind vielfältig und finden sich in Wissenschaft
 und Wirtschaft wieder.
 Anwendungen existieren zum Beispiel in der Robotik 
\begin_inset CommandInset citation
LatexCommand cite
key "klimentjew2008grundlagen"

\end_inset

, in welcher mit Hilfe eines Stereokamerasystems die Position des Roboters
 innerhalb seiner Umgebung feststellbar ist.
 Ein weiteres Feld ist die Archäologie und der Denkmalsschutz.
 Ein Beispiel dafür ist das Archaeocopter Projekt.
\end_layout

\begin_layout Standard
Allgemein kann man zwischen aktiver und passiver Rekonstruktion 
\begin_inset CommandInset citation
LatexCommand cite
key "ladikos2011real"

\end_inset

 unterscheiden.
 Die beiden Verfahren werden im Anschluss kurz vorgestellt.
\end_layout

\begin_layout Subsection
Aktive Rekonstruktion
\end_layout

\begin_layout Standard
Bei aktiver Rekonstruktion wird aktiv mit einem Sensor das Objekt abgetastet,
 um die Struktur zu ermitteln.
 3D-Scanner sind ein Vertreter dieser Gattung.
 Im Grunde sind sie der Kamera ähnlich.
 Genau wie diese besitzen sie ein Sichtfeld.
 Allerdings liefern sie statt Farbwerte, Abstandswerte von ihrem Sichtfeld.
 Die Abstandswerte können unter anderem mit Hilfe einer Time-of-Flight Camera
 oder der Triangulierungsmethode ermittelt werden.
\end_layout

\begin_layout Standard
Bei einer Time-of-Flight Kamera 
\begin_inset CommandInset citation
LatexCommand citep
key "li2014time"

\end_inset

 wird ein modulierter Lichtstrahl versendet.
 Aus der Dauer bis der Strahl nach der Reflexion seinen Ausgangspunkt erreicht,
 kann die Entfernung vom Objekt ermittelt werden.
 Diese Methode ist bei nahen und feinen Objekten ungenau, weil die Zeit
 nur zu einer gewissen Genauigkeit gemessen werden kann.
 Die Auflösung erreicht etwa 320x240 Pixel.
 Vorteilhaft sind die hohen Bildraten von bis zu 160 Bildern pro Sekunde.
\end_layout

\begin_layout Standard
Bei der Triangulierungsmethode wird von einem Laser ein Punkt auf das Objekt
 projiziert.
 Dieser Punkt wird von einer Kamera erfasst.
 In Abhängigkeit von der Entfernung erscheint der Laserpunkt im Sichtfeld
 der Kamera.
 Um das Verfahren zu beschleunigen, kann statt einem Punkt eine Linie verwendet
 werden (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TriangulierungBild"

\end_inset

).
\end_layout

\begin_layout Standard
Diese Methode ist sehr genau und daher für Skulpturen gut geeignet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/scanner-head-and-david-head-s.jpg
	width 63text%

\end_inset


\begin_inset Graphics
	filename img/david-classic-leftlight-s.jpg
	width 36text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:TriangulierungBild"

\end_inset

Links: Anwendung der Triangulierungsmethode mit Hilfe einer Scanline beim
 
\begin_inset Quotes gld
\end_inset

The Digital Michelangelo
\begin_inset Quotes grd
\end_inset

 Projekt, Rechts: Das Ergebnis des Scanvorganges (Abb.
 aus 
\begin_inset CommandInset citation
LatexCommand citep
key "MichelangeloProject"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Passive Rekonstruktion
\end_layout

\begin_layout Standard
Unter passiver Rekonstruktion versteht man Methoden, welche nicht aktiv
 eine Szene abtasten, sondern vorhandene photometrische Informationen (z.B.
 Fotos) nutzen, um die Tiefe zu berechnen.
 Das Stereo-Verfahren 
\begin_inset CommandInset citation
LatexCommand citep
key "ladikos2011real"

\end_inset

 ist eines der ersten in diesem Feld.
 Ausgehend von zwei auf der x-Achse verschobenen Bildern einer Szene gilt
 es, Punktpaare zwischen den beiden Bildern zu finden.
 Um das zu vereinfachen, sucht man nach einer Abbildung von Punkten aus
 Bild 1 zu Bild 2.
 Aufgrund der Verschiebung der Bilder auf der x-Achse kann man durch Epipolargeo
metrie die Tiefe der Punkte berechnen.
\end_layout

\begin_layout Subsection
VisualSFM
\end_layout

\begin_layout Standard
Bei VisualSFM
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://ccwu.me/vsfm/
\end_layout

\end_inset

.
 Aufg.
 am 24.05.2016
\end_layout

\end_inset

 handelt es sich um ein 3D-Rekonstruktionssystem.
 Es verfügt über eine grafische Benutzeroberfläche und zeichnet sich durch
 Skalierbarkeit auf Grundlage der Nutzung von nVidia oder ATI Grafikkarten
 des Computers aus.
 Entwickelt wurde das Programm von dem Studenten Changchang Wu
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://ccwu.me/
\end_layout

\end_inset

.
 Aufg.
 am 24.05.2016
\end_layout

\end_inset

, welcher mittlerweile bei Google beschäftigt ist.
 VisualSFM wird von dem Archaeocopter Projekt zur 3D-Rekonstruktion verwendet.
\end_layout

\begin_layout Section
Minimum Bounding-Box
\end_layout

\begin_layout Standard
In der Geometrie versteht man unter einer Minimum Bounding-Box ein Rechteck
 (2D) oder Box (3D) welches eine Menge von Punkten umschließt.
 Dabei ist die Fläche bzw.
 das Volumen minimal.
\end_layout

\begin_layout Section
Repräsentationen von Punktwolken
\end_layout

\begin_layout Standard
Punkt basierende geometrische Oberflächen können als Stichprobenmenge einer
 kontinuierlichen Oberfläche verstanden werden.
 Dabei entstehen dreidimensionale Raumkoordinaten 
\begin_inset Formula $p_{i}\text{\in\mathbb{R}}^{3}$
\end_inset

.
 Oft existieren noch weitere Daten zu dem Punkt, wie eine Normale 
\begin_inset Formula $n_{i}$
\end_inset

 oder eine Farbe 
\begin_inset Formula $c_{i}$
\end_inset

.
 Eine Punktwolke 
\begin_inset Formula $S$
\end_inset

 ist eine Menge solcher Punkte.
 Im folgendem wird eine Auswahl von Ansätze vorgestellt.
\end_layout

\begin_layout Subsection
QSplat Verfahren
\end_layout

\begin_layout Standard
Erste Vorschläge zur Darstellung von sehr großen Punktmengen wurden durch
 das QSplat Verfahren gemacht 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2000:QMP:344779.344940"

\end_inset

.
 Splat ist das englische Wort für Farbklecks.
\end_layout

\begin_layout Standard
Die Punktmenge wird durch eine Hierarchie auf Basis von Kugeln modelliert.
 Jede Kugel repräsentiert einen Knoten in einem Binärbaum.
 Jeder Knoten enthält den Mittelpunkt seiner Kugel, den Radius, die Normale
 und die Breite des Normalen Kegels und optional eine Farbe.
 Die Datenstruktur wird zu Beginn erstellt.
 Der Konstruktionsalgorithmus kann entweder auf einer Punktwolke oder besser
 einem triangulierten Modell angewendet werden.
 Bei Letzterem ist es leichter, die Normalen zu berechnen.
 Für den Radius der Kugeln wird die Länge der längsten anliegenden Kante
 gewählt.
 Mit Hilfe folgendem Algorithmus kann nun die Datenstruktur erstellt werden:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

BuildTree(vertices[begin..end]) { 
\end_layout

\begin_layout Plain Layout

	if (begin == end) 
\end_layout

\begin_layout Plain Layout

		return Sphere(vertices[begin]) 
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout
\align left

		midpoint = PartitionAlongLongestAxis(vertices[begin..end]) 		
\end_layout

\begin_layout Plain Layout
\align left

		leftsubtree  = BuildTree(vertices[begin..midpoint]) 
\end_layout

\begin_layout Plain Layout
\align left

		rightsubtree = BuildTree(vertices[midpoint+1..end]) 
\end_layout

\begin_layout Plain Layout
\align left

		return BoundingSphere(leftsubtree, rightsubtree) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sobald die Datenstruktur aufgebaut ist, kann die Punktmenge mit folgendem
 Algorithmus gezeichnet werden:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

TraverseHierarchy(node) { 
\end_layout

\begin_layout Plain Layout

	if (node not visible) 
\end_layout

\begin_layout Plain Layout

		skip this branch of the tree 
\end_layout

\begin_layout Plain Layout

	else if (node is a leaf node) 
\end_layout

\begin_layout Plain Layout

		draw a splat 
\end_layout

\begin_layout Plain Layout

	else if (benefit of recursing further is too low) 
\end_layout

\begin_layout Plain Layout

		draw a splat 
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		for each child in children(node) 
\end_layout

\begin_layout Plain Layout

			TraverseHierarchy(child) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zuerst wird getestet, ob die Kugel des Knotens sichtbar ist.
 Dafür wird getestet, ob die Kugel in dem View-Frustum liegt.
 Falls nicht, muss der Knoten samt seiner Kinder nicht beachtet werden und
 die Rekursion wird abgebrochen.
 QSplat führt auch Backface-Culling aus mit Hilfe der Normalen Kegel.
\end_layout

\begin_layout Standard
Anhand der Größe der projizierten Kugel auf die View-Ebene wird entschieden,
 ob die Rekursion fortgesetzt wird.
 Überschreitet diese einen gewissen Schwellenwert, wird die Rekursion beendet
 und der aktuelle Knoten gezeichnet.
 
\end_layout

\begin_layout Standard
Das Verfahren kann modifiziert auch zum Streaming von Punktwolken genutzt
 werden 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2001:SQV:364338.364350"

\end_inset

 .
 
\end_layout

\begin_layout Standard
Für HD-Displays ist der Algorithmus zu rechenintensiv, weil die Berechnung
 pro Pixel von der CPU erledigt wird.
\end_layout

\begin_layout Subsection
Octree
\end_layout

\begin_layout Standard
Octrees sind eine Datenstruktur, um dreidimensionale Daten hierarchisch
 zu untergliedern.
 Sie wurde 1980 von Donal Maegher beschrieben 
\begin_inset CommandInset citation
LatexCommand citep
key "meagher1982geometric"

\end_inset

.
 Octrees sind analog im Dreidimensionalen zu Quadtrees im Zweidimensionalen.
\end_layout

\begin_layout Standard
Jeder Knoten repräsentiert einen Würfel, welcher alle in den Knoten eingefügten
 3D-Punkte beinhaltet.
 Jeder innere Knoten besitzt immer 8 Kinder.
 Diese unterteilen den Würfel des Knotens in 8 gleich große Oktanten usw.
 (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Octree"

\end_inset

)
\end_layout

\begin_layout Standard
Die eigentlichen Punktdaten sind in den äußeren Knoten gespeichert.
 Äußere Knoten können auch leer sein.
\end_layout

\begin_layout Standard
Der Octree unterstützt das Einfügen und Löschen von Punkten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/Octree2.svg
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Octree"

\end_inset

In jedem Level zerlegt der Octree den Raum in weitere feinere Würfel (Abb
 aus.
 
\begin_inset CommandInset citation
LatexCommand citep
key "OctreeWiki"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Multiresolution Octree
\begin_inset CommandInset label
LatexCommand label
name "subsec:Multiresolution-Octree"

\end_inset


\end_layout

\begin_layout Standard
Die Datenstruktur entstammt aus der Arbeit 
\begin_inset Quotes eld
\end_inset

Interactive Editing of Large Point Clouds
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Wand:2008:SSP:1363373.1363581"

\end_inset

.
 Sie unterstützt Einfügen, Löschen und bietet unterschiedlich detaillierte
 Darstellungen des Ausgangsmodells.
 Im Folgenden wird die Datenstruktur vorgestellt.
\end_layout

\begin_layout Standard
Der Multiresolution Octree (MRT) kann als eine spezielle Form des Octree
 verstanden werden.
 Wie beim Octree enthalten die äußeren Knoten alle Punkte.
 Die Tiefe ergibt sich aus der Eigenschaft, dass kein Blatt mehr als 
\begin_inset Formula $n_{max}$
\end_inset

 Punkte beinhalten darf.
 Ist 
\begin_inset Formula $n_{max}$
\end_inset

 nach einer Einfüge-Operation überschritten, wird das Kind geteilt und die
 bestehenden Punkte werden auf die 8 neuen Kinder verteilt.
\end_layout

\begin_layout Standard
Die inneren Knoten sollen eine vereinfachte bzw.
 gröbere Version ihrer Kinder liefern.
 Dafür haben diese eine dreidimensionale Rasterung gespeichert.
 Das Raster unterteilt den Würfel in 
\begin_inset Formula $k^{3}$
\end_inset

 gleich große Rasterzellen (z.B.
 
\begin_inset Formula $k\text{=128}$
\end_inset

).
 Jede Rasterzelle hat zusätzlich ein Gewicht und eine Farbe als RGB-Wert
 gespeichert.
 Das Raster selbst ist nicht als einfaches Array gespeichert, sondern als
 Hashtabelle, um Speicherplatz zu sparen.
 Auf diese Art werden nur die Zellen gespeichert, welche Punkte enthalten.
 
\end_layout

\begin_layout Standard
Zellen mit hohem Gewicht werden beim Rendern größer gezeichnet.
 Sobald ein weiterer Punkt in die gleiche Zelle fällt, wird das Gewicht
 inkrementiert.
 
\end_layout

\begin_layout Standard
Der Farbwert entspricht dem des zuerst hinzugefügten Punktes der Zelle.
 
\end_layout

\begin_layout Paragraph
Einfügen eines Punktes
\end_layout

\begin_layout Standard
Beim Einfügen können zwei Fälle auftreten.
\end_layout

\begin_layout Subparagraph
1.
 Fall : Der Punkt liegt außerhalb der Wurzel.
 
\end_layout

\begin_layout Standard
Die bestehende Wurzel muss so lange erweitert werden, bis sie den neuen
 Punkt mit einschließt.
 Die Breite sowie Höhe der Wurzel verdoppelt sich dabei in jedem Schritt.
\end_layout

\begin_layout Standard
Sobald der Punkt in der Wurzel liegt, tritt der 2.
 Fall ein.
\end_layout

\begin_layout Subparagraph
2.
 Fall : Der Punkt liegt innerhalb der Wurzel
\end_layout

\begin_layout Standard
Zuerst wird der Punkt der Rasterung hinzugefügt.
 Das heißt, das Gewicht in der entsprechende Rasterzelle wird um eins erhöht
 und die Farbe des Punktes wird gegebenenfalls gespeichert.
 Dann wird ermittelt, in welchem der Kinder der Punkt liegt.
 Nun wird der Vorgang beim Kind wiederholt, bis ein äußerer Knoten erreicht
 wird.
 Falls die maximale Anzahl Punkte 
\begin_inset Formula $n_{max}$
\end_inset

 überschritten wurde, muss der Knoten gespalten werden.
 Alle bisher gespeicherten Punkte und der neue Punkt werden nun auf die
 neuen Kinder verteilt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/img-003.ppm
	width 70text%
	scaleBeforeRotation

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/img-004.ppm
	width 70text%

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Abb.
 Links: Die Rasterung ist schematisch für die zweite Dimension dargestellt.
 Die inneren Knoten beinhalten die Gewichte.
 Die äußeren Knoten enthalten die Punkte.
 Rechts: Das Schema nach dem Einfügen eines weiteren Punktes in den Quadranten
 rechts unten.
 Auf jedem Level wird ein Gewicht erhöht.
 (Abb.
 aus 
\begin_inset CommandInset citation
LatexCommand citep
key "Wand:2008:SSP:1363373.1363581"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Moving-Least-Squares Surfaces
\end_layout

\begin_layout Standard
Das Moving-Least-Squares (MLS) Verfahren wurde von Levin 1998 vorgestellt
 
\begin_inset CommandInset citation
LatexCommand citep
key "levin1998approximation"

\end_inset

.
 Das Verfahren wurde erstmals 2001 durch Alexa zur Darstellung von Punktwolken
 benutzt 
\begin_inset CommandInset citation
LatexCommand citep
key "Alexa:2001:PSS:601671.601673"

\end_inset

.
 Die Arbeit wird im Folgenden kurz vorgestellt.
 Die Grundidee der Arbeit ist, dass die gegebene Menge Punkte 
\begin_inset Formula $S$
\end_inset

 indirekt eine Oberfläche 
\begin_inset Formula $S_{A}$
\end_inset

 definiert.
 Es wird eine Projektion 
\begin_inset Formula $\phi:U\rightarrow\mathbb{R}^{3}$
\end_inset

 vorgestellt, welche einen beliebigen Punkt aus der Umgebung 
\begin_inset Formula $U$
\end_inset

 von 
\begin_inset Formula $S$
\end_inset

 auf eine Oberfläche 
\begin_inset Formula $S_{A}$
\end_inset

, welche das Objekt lokal beschreibt, projiziert.
 Alle Punkte, die auf sich selbst abbilden, ergeben die abgeschätzte Oberfläche
 
\begin_inset Formula $S_{A}$
\end_inset

: 
\begin_inset Formula 
\[
S_{A}:=\{x\in\mathbb{R}^{3}|\phi(x)=x\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $U$
\end_inset

 kann man als eine Vereinigung von Kugeln mit Radius 
\begin_inset Formula $r_{k}$
\end_inset

, dessen Mittelpunkt ein Punkt aus 
\begin_inset Formula $S$
\end_inset

 ist, beschreiben:
\begin_inset Formula 
\[
U:=\bigcup_{i}\{x\in\mathbb{R}^{3}|\lVert x-p_{i}\rVert<r_{K}\}
\]

\end_inset


\end_layout

\begin_layout Standard
Die Projektion eines Punktes 
\begin_inset Formula $r$
\end_inset

 wird in 3 Schritten ermittelt.
\end_layout

\begin_layout Enumerate
Ermittle eine Referenzebene 
\begin_inset Formula $H=\{x|\langle n,x\rangle-D=0,x\in\mathbb{R}^{3}\},n\in\mathbb{R}^{3},\lVert n\rVert=1$
\end_inset

 durch Minimierung des Ausdrucks,
\begin_inset Formula 
\[
\sum_{i=1}^{N}(\langle n,p_{i}\rangle-D)^{2}\Theta(\lVert p_{i}-q\rVert)
\]

\end_inset

 wobei 
\begin_inset Formula $q$
\end_inset

 die Projektion von 
\begin_inset Formula $r$
\end_inset

 auf 
\begin_inset Formula $H$
\end_inset

 ist.
 Bei 
\begin_inset Formula $\Theta$
\end_inset

 handelt es sich um eine monoton, radial, fallende Funktion mit positivem
 Wertebereich.
 Normalerweise gilt: 
\begin_inset Formula 
\[
\Theta(d)=e^{\frac{d^{2}}{h^{2}}}
\]

\end_inset

 
\begin_inset Formula $h$
\end_inset

 ist meist der durchschnittliche Abstand von benachbarten Punkten und hat
 einen direkten Einfluss darauf, wie glatt die Oberfläche erscheint.
\end_layout

\begin_layout Enumerate
Mit Hilfe von 
\begin_inset Formula $H$
\end_inset

 kann nun ein zweidimensionales Polynom zum Abschätzen der Umgebung von
 
\begin_inset Formula $S_{A}$
\end_inset

 in der Nähe von 
\begin_inset Formula $r$
\end_inset

 gefunden werden.
\begin_inset Formula 
\[
\sum_{i=1}^{N}(g(x_{i},y_{i})-f_{i})^{2}\Theta(\lVert p_{i}-q\rVert))
\]

\end_inset

Hier ist 
\begin_inset Formula $f_{i}$
\end_inset

 der kürzeste Weg von 
\begin_inset Formula $H$
\end_inset

 zu 
\begin_inset Formula $p_{i}$
\end_inset

.
 Bei 
\begin_inset Formula $x_{i}$
\end_inset

und 
\begin_inset Formula $y_{i}$
\end_inset

handelt es sich um die Koordinaten von Punkt 
\begin_inset Formula $q_{i}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Die Projektion von 
\begin_inset Formula $r$
\end_inset

 ist letztendlich wie folgt definiert:
\begin_inset Formula 
\[
\phi(r)=q+g(0,0)n
\]

\end_inset


\end_layout

\begin_layout Standard
Neben dem Darstellen von Punkten kann das Verfahren auch eingesetzt werden,
 um weitere Punkte zu generieren.
 
\end_layout

\begin_layout Standard
Beim Rendern wird eine Datenstruktur wie bei dem QSplat-Verfahren verwendet.
 Es unterscheiden sich die Blätter, in denen zusätzlich zur Position, Radius,
 Normalen und Farbe auch eine Referenzebene 
\begin_inset Formula $H$
\end_inset

 sowie die Koeffizienten des Polynoms gespeichert werden.
\end_layout

\begin_layout Standard
Wenn bei dem Rendervorgang ein Blatt erreicht wird und wenn mehr als ein
 Punkt benötigt wird, werden mit Hilfe des Polynoms weitere Punkte für die
 Umgebung generiert.
\end_layout

\begin_layout Subsection
Tetraedertree
\begin_inset CommandInset label
LatexCommand label
name "subsec:Tetraedertree"

\end_inset


\end_layout

\begin_layout Standard
Die Arbeit 
\begin_inset CommandInset citation
LatexCommand citep
key "rodriguez2013compressionDiamond"

\end_inset

 stellt eine offline Datenstruktur zum Verwalten von triangulierten Punkten
 vor.
 Die Datenstruktur unterteilt den Raum in einzelne Tetraeder.
 Durch die Tetraeder können Punkte durch baryzentriche Koordinaten repräsentiert
 werden.
\end_layout

\begin_layout Standard
In der Vorverarbeitung wird Top-Down eine Diamanten Hierarchie aufgebaut,
 wobei jeder Diamant aus einer Menge von Tetraedern besteht.
 Die Eingabe erfolgt offline als eine Menge von Dreiecken.
 Zu Beginn wird die Bounding-Box in 6 Tetraeder unterteilt, wobei die Diagonale
 von allen Tetraedern geteilt wird.
 Sobald ein eingefügtes Dreieck zwischen mehrere Tetraeder (Blätter) fällt,
 wird es am Rand des Tetraeders abgeschnitten.
 Die neuen Dreiecke werden dann in ihre entsprechenden Blätter hinzugefügt.
 Sobald in einem Blatt mehr als eine vorher festgelegte Menge Dreiecke enthalten
 ist, wird es anhand einer Ebene, welche durch den Mittelpunkt der längsten
 Kante und seiner gegenüberliegenden Kante verläuft, geteilt.
 Im Anschluss werden die Dreiecke auf die zwei Kinder verteilt.
 Der nächste Schritt vereinfacht die Kinder Buttom-Up.
 Jeder Diamant wird dabei unabhängig voneinander abgearbeitet.
 Dafür muss beachtet werden, das Vertices, welche an den Außenwänden liegen,
 nicht verändert werden dürfen.
 Bei Vertices an den Innenwänden muss auch der korrespondierende Vertex
 beim Nachbarn mit einbezogen werden.
 Ist beides nicht der Fall, kann beliebig vereinfacht werden.
 Da die Diamanten unabhängig voneinander vereinfacht werden, ist es einfacher
 die Datenstruktur zu parallelisieren.
\end_layout

\begin_layout Section
Bestehende Applikationen
\end_layout

\begin_layout Standard
Die Idee, Punktwolken auf mobilen Geräten zu betrachten, ist nicht neu.
 Daher existieren schon einige Vorschläge zum Lösen des Problems.
 Im Folgenden werden einige dieser Möglichkeiten vorgestellt.
 
\end_layout

\begin_layout Subsection
KiwiViewer
\end_layout

\begin_layout Standard
KiwiViewer
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.kiwiviewer.org/
\end_layout

\end_inset

.
 Aufg.
 am 19.05.2016
\end_layout

\end_inset

 ist eine Open-Source Applikation zur Erkundung von Punktwolken.
 Die App ist für Android sowie iOS verfügbar.
 Multi-Touch Gestensteuerung wird unterstützt.
 KiwiViewer bedient sich der Point-Cloud-Library
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://pointclouds.org/
\end_layout

\end_inset

.
 Aufg.
 am 22.05.2016
\end_layout

\end_inset

 (PCL) für seine Kernfunktionen.
 Bei der Point-Cloud-Library handelt es sich um eine Open-Source Bibliothek
 zum verarbeiten von Punktwolken.
 Die Punktdaten werden entweder über eine SD-Karte, E-Mail oder URL geladen.
 Die Applikation lässt sich sehr einfach bedienen.
\end_layout

\begin_layout Paragraph
Abgrenzung
\emph on
 
\end_layout

\begin_layout Standard
Die App speichert die geladenen Punkte direkt auf dem Tablet.
 Punktwolken werden nicht vereinfacht.
 Daher treffen Modelle mit mehreren Millionen Punkten schnell an die Grenzen
 der GPU.
\end_layout

\begin_layout Subsection
LiMo
\end_layout

\begin_layout Standard
Bei LiMo
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://play.google.com/store/apps/details?id=com.ogs.limo&hl=en
\end_layout

\end_inset

.
 Aufg.
 am 27.05.2016
\end_layout

\end_inset

 handelt es sich um eine von OGSystems entwickelte Android Applikation zum
 Betrachten von LiDAR Daten.
 LiMo wurde für den professionellen Gebrauch entwickelt und ermöglicht das
 Beobachten von Gebäuden sowie Naturszenen.
 Daten können auch über einen eigenen Webservice gestreamt werden, weshalb
 die App auch zu Monitoring Zwecken eingesetzt werden kann.
 Die Applikation unterstützt bis zu 5 Millionen Punkte.
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Die Anwendung ist auf LiDAR Daten beschränkt.
 LiDAR ist primär zum Scannen von großen Objekten, wie Brücken geeignet
 und verfügt daher nicht über die Genauigkeit, welche beispielsweise bei
 einer Skulptur benötigt wird.
 Die Applikation ist auf 5 Millionen Punkte beschränkt.
\end_layout

\begin_layout Subsection
iOS App mit Knn-Baum 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Knn-Baum"

\end_inset


\end_layout

\begin_layout Standard
Diese Applikation wurde von der Visual Computing Gruppe
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.crs4.it/vic/
\end_layout

\end_inset

.
 Aufg.
 am 11.06.2016
\end_layout

\end_inset

 des CRS4 (Center for Advanced Studies, Research and Development in Sardinia)
 entwickelt.
 Die Applikation verwendet einen Knn-Baum zum Verwalten der Punktmenge 
\begin_inset CommandInset citation
LatexCommand cite
key "VAST:VAST12:057-064"

\end_inset

.
 Ähnlich wie beim MRT werden in den inneren Knoten vereinfacht Abbilder
 der Kinder gespeichert.
 Der Ansatz verwendet eine Client-Server Struktur.
 Die Datenstruktur selbst wird auf einem Server gespeichert.
 Die Knoten werden auf Anfrage eines Clients übertragen.
 Übertragende Knoten werden mit Hilfe eines LRU-Cache gespeichert.
 Die Implementierung erfolgte in C++ und OpenGl ES.
 Für die Netzwerkkommunikation wird Http-Pipelining sowie eine Wavletkompression
 verwendet.
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Die Datenstruktur ist nicht dynamisch, also die Menge der Punkte muss von
 Anfang an feststehen.
 Die Implementierung erfolgte in C++ und für iOS.
 Die Datenstruktur bietet den Vorteil, dass sie eine geringe Tiefe besitzt.
 Die Benchmarks sind beeindruckend, da Punktwolken bis zu 180 Millionen
 Punkte dargestellt werden können.
 Die Anzahl gleichzeitig angezeigter Punkte liegt allerdings bei 1 Millionen
 Punkte auf den Testgeräten.
 Der Quellcode ist nicht frei verfügbar.
\end_layout

\begin_layout Subsection
HuMoRS
\end_layout

\begin_layout Standard
Das HuMoRs (Huge models Mobile Rendering System) 
\begin_inset CommandInset citation
LatexCommand citep
key "Balsa:2014:HHM"

\end_inset

 ist eine weitere Entwicklung der Visual Computing Gruppe des CRS4.
 Die Applikation beherrscht das Darstellen von Modellen mit mehr als 70
 Millionen Punkten bzw.
 Dreiecken.
 Die Anwendung läuft auf Android und wurde mit mehreren Geräten sowie Versionen
 getestet.
 Besonderes Augenmerk wurde in der Arbeit auf die Bedienbarkeit gelegt.
 Der Rotationspunkt des Modells wird dynamisch berechnet.
 Des Weiteren  werden zu jedem Modell Thumbnails generiert, um zu interessanten
 Abschnitten des Modells springen zu können.
 Die Anwendung folgt dem gleichen Client-Server Ansatz wie die iOS Applikation
 aus Sektion 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Knn-Baum"

\end_inset

.
 Als Datenstruktur wird ein Tetraederbaum (siehe Sektion 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Tetraedertree"

\end_inset

) verwendet.
 Diese ermöglicht eine Kompression, welche einen Vertex mit Position, Farbe
 und Normale auf 64Bit komprimiert.
\end_layout

\begin_layout Standard
Auf der Clientseite wird ein LRU-Cache verwendet, um den Netzwerkverkehr
 niedrig zu halten.
 Die Applikation wurde in C++ mit Hilfe des Qt-Frameworks 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
verweis
\end_layout

\end_inset

programmiert.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename papers/humors/humors-000.jpg
	width 50text%

\end_inset


\begin_inset Graphics
	filename papers/humors/humors-001.jpg
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HuMorsBild"

\end_inset

Darstellung einer Szene von hochauflösenden Statuen auf einem Tablet (Asus
 TF201) sowie Smartphone (LG Nexus 4).
 Am rechten Bildrand sieht man die vorausberechneten Vorschaubilder.
 (Abb.
 aus 
\begin_inset CommandInset citation
LatexCommand citep
key "Balsa:2014:HHM"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Die Arbeit bietet gute Ansätze, besonders in Bezug auf die Bedienung.
 Die verwendete Datenstruktur bietet eine detaillierte Darstellung samt
 hoher Bildfrequenz.
 Allerdings müssen auch hier alle Punkte vor Aufbau der Datenstruktur bekannt
 sein.
\end_layout

\begin_layout Section
Proxy Entwurfsmuster
\begin_inset CommandInset label
LatexCommand label
name "subsec:Proxy-Design-Pattern"

\end_inset


\end_layout

\begin_layout Standard
Bei einem Proxy (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UML-Proxy-Pattern"

\end_inset

) 
\begin_inset CommandInset citation
LatexCommand citep
key "Gamma:1995:DPE:186897"

\end_inset

 handelt es sich um ein Objekt, welches als Schnittstelle zu etwas Anderem
 agiert.
 Diese sind zum Beispiel eine große Datei oder eine andere teure Ressource.
\end_layout

\begin_layout Standard
Ein klassisches Beispiel sind Platzhalter für noch nicht fertig geladene
 Bilder auf Webseiten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename uml/proxy.svg
	height 4.5cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Das Diagramm zeigt, wie das reale Subjekt durch ein Proxy Objekt repräsentiert
 wird, auf das der Client zugreift.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:UML-Proxy-Pattern"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Singleton Entwurfsmuster
\begin_inset CommandInset label
LatexCommand label
name "sec:Singleton-Pattern"

\end_inset


\end_layout

\begin_layout Standard
Man spricht von einem Singleton, wenn von einer Klasse nur eine einzige
 oder beschränkte Anzahl Instanzen erlaubt sind.
 Typische Vertreter sind Objekte, die einen Zustand oder globale Variablen
 speichern wie das Android Kontext Objekt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename uml/singleton.svg
	height 2cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
UML-Diagramm eines Singleton Objektes, welches die einzige Instanz beherbergt.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Representational State Transfer
\begin_inset CommandInset label
LatexCommand label
name "subsec:Representational-state-transfer"

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Zitierstil prüfen
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Representational State Transfer (REST) ist ein Programmierparadigma für
 serviceorientierte verteilte Systeme.
 REST wurde im Jahr 2000 von Roy Fielding in seiner Doktorarbeit 
\begin_inset CommandInset citation
LatexCommand cite
key "Fielding:2000:ASD:932295"

\end_inset

 wie folgt beschrieben.
\end_layout

\begin_layout Standard
REST definiert sich über eine Menge von Beschränkungen bei der Kommunikation
 von Komponenten.
 Das prominenteste Beispiel ist das World Wide Web.
 Die Beschränkungen werden im Folgenden kurz vorgestellt.
\end_layout

\begin_layout Subsubsection*
Client-Server Modell
\end_layout

\begin_layout Standard
Nach Andrews 
\begin_inset CommandInset citation
LatexCommand cite
key "Andrews:1991:PPI:103162.103164"

\end_inset

 ist der Client ein auslösender Prozess und der Server ein reagierender
 Prozess.
 Der Client stellt Anfragen, auf welche der Server reagiert.
 Der Client kann entscheiden, wann er mit dem Server interagiert.
 Der Server wiederum muss auf Anfragen warten und dann auf diese reagieren.
 Oft ist ein Server ein nicht endender Prozess, welcher auf mehrere Clients
 reagiert.
\end_layout

\begin_layout Subsubsection*
Zustandslosigkeit
\end_layout

\begin_layout Standard
Jede Anfrage vom Client muss alle Informationen enthalten, welche notwendig
 sind, um die Anfrage zu verarbeiten.
 Des Weiteren darf kein gespeicherter Kontext auf dem Server vorliegen,
 auf welchen Bezug genommen wird.
 Alle Zustände werden auf dem Client gespeichert.
\end_layout

\begin_layout Subsubsection*
Caching
\end_layout

\begin_layout Standard
Serverantworten müssen implizit oder explizit als cachebar gekennzeichnet
 sein.
 Die Idee ist, den Netzwerkverkehr effizienter zu machen.
 Bemerkenswert dabei ist, dass dadurch ganze Interaktionen wegfallen können.
\end_layout

\begin_layout Subsubsection*
Einheitliche Schnittstelle
\end_layout

\begin_layout Standard
Ein integraler Bestandteil einer REST-Architektur ist eine einheitliche
 Schnittstelle.
 Das vereinfacht die Systemarchitektur und verbessert die Sichtbarkeit von
 Interaktionen.
 Sie ist durch vier weitere Eigenschaften beschrieben.
\end_layout

\begin_layout Subparagraph
1.
 Adressierbarkeit von Ressourcen
\end_layout

\begin_layout Standard
Jede Information, die über einen URI kenntlich gemacht wurde, wird als Ressource
 gekennzeichnet.
 Die Ressource selbst wird in einer Repräsentation übertragen, welche sich
 von der internen Repräsentation unterscheidet.
 Jeder REST-konforme Dienst hat eine eindeutige Adresse, den Uniform Resource
 Locator (URL).
\end_layout

\begin_layout Subparagraph
2.
 Repräsentationen zur Veränderung von Ressourcen
\end_layout

\begin_layout Standard
Wenn ein Client die Repräsentation einer Ressource mitsamt seinen Metadaten
 kennt, reicht dies aus, um die Ressource zu modifizieren bzw.
 zu löschen.
 
\end_layout

\begin_layout Subparagraph
3.
 Self-descriptive messages
\end_layout

\begin_layout Standard
Jede Nachricht beschreibt, wie ihre Informationen zu verarbeiten ist, z.B.
 durch Angabe ihres Internet Media Types (MIME-Type).
\end_layout

\begin_layout Subparagraph
4.
 Hypermedia as the Engine of Application State
\end_layout

\begin_layout Standard
Bei Hypermedia as the Engine of Application State (HATEOAS) navigiert der
 Client ausschließlich über Hypermedia, welche vom Server bereitgestellt
 wird.
 Abstrakt betrachtet stellen HATEOAS-konforme REST-Services einen endlichen
 Automaten dar, dessen Zustandsveränderungen durch die Navigation mittels
 der bereitgestellten URI erfolgt.
 Durch HATEOAS ist eine lose Bindung gewährleistet und die Schnittstelle
 kann verändert werden.
 
\end_layout

\begin_layout Subsubsection*
Mehrschichtige Systeme
\end_layout

\begin_layout Standard
Der Client soll lediglich die Schnittstelle kennen.
 Schichten dahinter bleiben ihm verborgen.
\end_layout

\begin_layout Chapter
Frameworks und Architektur
\end_layout

\begin_layout Standard
Im Folgenden werden die Technologien, Begriffe und Frameworks vorgestellt,
 welche in der Arbeit verwendet werden.
\end_layout

\begin_layout Section
Java und Android
\end_layout

\begin_layout Standard
Bei Java 
\begin_inset CommandInset citation
LatexCommand citep
key "gosling1995java"

\end_inset

 handelt es sich um eine 1995 von Sun Microsystems veröffentliche Programmierspr
ache.
 Entwickelt wurde die Sprache von James Gosling.
 Java ist objektorientiert, nebenläufig und plattformunabhängig.
 Letzteres wird erreicht, indem Java Code, genauer gesagt Java Byte Code,
 auf einer virtuellen Maschine (JVM) interpretiert wird.
 Moderne Implementierungen der JVM unterstützen die sogenannte Just-in-Time-Komp
ilierung.
 Das bedeutet, dass eine Übersetzung in den Maschinencode während der Laufzeit
 vorgenommen wird.
 Des Weiteren kümmert sich die Laufzeitumgebung von Java um das Speichermanageme
nt.
 Nach dem Tiobe-Index zu urteilen ist Java eine der populärsten Programmiersprac
hen der Welt
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.tiobe.com/tiobe_index?page=Java
\end_layout

\end_inset

.
 Aufg.
 am 17.05.2016
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Android
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.android.com/
\end_layout

\end_inset

.
 Aufg.
 am 19.05.2016
\end_layout

\end_inset

 ist ein mobiles Betriebssystem, welches momentan von Google weiter entwickelt
 wird.
 Es wurde von 33 Mitgliedern der Open Handset Alliance entwickelt.
 Ziel war es, einen offenen Standard für mobile Geräte zu schaffen
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.openhandsetalliance.com/press_110507.html
\end_layout

\end_inset

.
 Aufg.
 am 23.05.2016
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Android baut auf dem Linux Kernel auf und ist für eine Bedienung über Touchdispl
ays ausgelegt.
 Daher werden Eingaben hauptsächlich über Gesten und Tippen am Display vorgenomm
en.
 Android verfügt über Ableger für Fernseher (Android TV), Autos (Android
 Auto) sowie Smartwatches (Android Wear).
 Android hat seit mehreren Jahren einen dominanten Marktanteil
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.idc.com/prodserv/smartphone-os-market-share.jsp
\end_layout

\end_inset

.
 Aufg.
 am 21.05.2016
\end_layout

\end_inset

 bei mobilen Geräten und ist das mit Abstand meist genutzte Betriebssystem
 weltweit
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Usage_share_of_operating_systems
\end_layout

\end_inset

.
 Aufg.
 am 21.05.2016
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Java ist die bevorzugte, wenn auch nicht einzig mögliche Programmiersprache
 für Android.
 Allerdings kommt bei Android keine Standard JVM zum Einsatz, sondern eine
 modifizierte Version.
 Bis zur Version Android 4.4 kam die virtuelle Maschine Dalivk zum Einsatz.
 Diese wurde vollständig in Android 5.0 ersetzt durch Android Runtime (ART)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://developer.android.com/about/versions/android-5.0-changes.html
\end_layout

\end_inset

.
 Aufg.
 am 23.05.2016
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Google Protocol Buffers
\end_layout

\begin_layout Standard
Bei Google Protocol Buffers
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://developers.google.com/protocol-buffers/
\end_layout

\end_inset

.
 Aufg.
 am 20.05.2016
\end_layout

\end_inset

 handelt es sich um eine plattformunabhängige Datenstruktur zum Serialisieren
 von Daten.
 
\end_layout

\begin_layout Standard
Die Datenstruktur wird in einem einheitlichen Schema festgelegt, zum Beispiel:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

message Person {   
\end_layout

\begin_layout Plain Layout

	required string name = 1;   
\end_layout

\begin_layout Plain Layout

	required int32 id = 2;   
\end_layout

\begin_layout Plain Layout

	optional string email = 3;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Schema definiert einen Namespaces, über welchen dann die eigentlichen
 Daten ausgelesen werden können.
 In dem Beispiel hat der Datentyp 
\begin_inset Quotes gld
\end_inset

Person
\begin_inset Quotes grd
\end_inset

 drei Felder.
 Jedes dieser Felder ist getypt und mit einem Schlüsselwort versehen, welches
 angibt, ob das Feld Pflicht ist.
\end_layout

\begin_layout Standard
Es besitzt also jede 
\begin_inset Quotes gld
\end_inset

Person
\begin_inset Quotes grd
\end_inset

 einen String für den Namen, aber nicht immer einen String für die Mail.
\end_layout

\begin_layout Standard
Aus dem Schema können für jede unterstützte Programmiersprache (Java, C++,
 Python, JavaNano, Ruby, Objective-C und C#) Klassen generiert werden, welche
 die Daten (de)serialisieren.
 Das macht es möglich, Clients in anderen Sprachen zu schreiben.
\end_layout

\begin_layout Standard
Protocol Buffers sind komplett abwärtskompatibel.
 Die Schemata können problemlos erweitert werden.
\end_layout

\begin_layout Standard
Ein weiterer Vorteil ist der merklich verringerte Overhead im Vergleich
 zu JSON oder XML.
 Nachteilig ist, dass die übertragenen Daten nicht ohne Weiteres für einen
 Menschen lesbar sind.
 Protocol Buffers werden intensiv intern bei Google selbst eingesetzt.
 Ein weiterer prominenter Nutzer ist Blizzard beim BATTLE.NET
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://news.ycombinator.com/item?id=11444846
\end_layout

\end_inset

.
 Aufg.
 am 23.05.2016
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Open-Graphics-Library for Embedded-Systems
\end_layout

\begin_layout Standard
Open-Graphics-Library for Embedded-Systems (OpenGL ES) 
\begin_inset CommandInset citation
LatexCommand citep
key "openGlES"

\end_inset

 bietet ein offenes Interface für Grafikhardware.
 Dieses besteht aus einer Sammlung von Prozeduren und Funktionen, die es
 den Programmierern ermöglichen Shaderprogramme, Objekte und Operationen
 zu spezifizieren, um dreidimensionale Farbbilder zu produzieren.
 Viele der Funktionen von OpenGL ES implementieren das Zeichnen von geometrische
n Objekten, wie Punkte oder Linien.
 OpenGL ES setzt voraus, dass die Grafikhardware über einen Framebuffer
 verfügt.
\end_layout

\begin_layout Subsection
Vertex
\end_layout

\begin_layout Standard
Unter einem Vertex versteht man eine Datenstruktur, welche einen zwei- oder
 dreidimensionalen Punkt im Raum beschreibt.
\end_layout

\begin_layout Subsection
Shader 
\end_layout

\begin_layout Standard
Bei Shadern handelt es sich um vom Nutzer geschriebene Programme, welche
 an unterschiedlichen Stationen der Rendering-Pipeline aufgerufen werden.
 Shader werden in der C nahen OpenGL Shading Language geschrieben.
\end_layout

\begin_layout Subsection
Pipeline
\end_layout

\begin_layout Standard
Der Vorgang des Renderings lässt sich vereinfacht als Datenverarbeitung
 von aufeinanderfolgenden Stufen darstellen 
\begin_inset CommandInset citation
LatexCommand citep
key "OpenGlPipeline"

\end_inset

.
 Die Stufen werden im Folgenden kurz vorgestellt.
\end_layout

\begin_layout Standard
Den Anfang macht die Vertex Spezifikation.
 In diesem Schritt wird ein Stream von Vertices für OpenGL ES vorbereitet.
 Dazu muss festgelegt werden, was für ein Grundobjekt (Primitive) die Daten
 darstellen.
 Beispiele wären Punkte, Linien oder Dreiecke.
 Darauf folgt der Vertex Shader.
 Dieser erhält einzelne Elemente aus dem Vertexstream und gibt nach dem
 Ausführen des Shaders ein einzelnes Vertex zurück.
 Der Shader wird vom Benutzer programmiert.
 Typischerweise wird in diesem Schritt die Projektionsmatrix auf die Punkte
 angewendet.
\end_layout

\begin_layout Standard
Als nächster Schritt kann eine Tessellation angewendet werden.
 In dieser optionalen Stufe werden Patches (Primitves für Tesselation) in
 mehrere kleinere Primitives zerlegt.
\end_layout

\begin_layout Standard
Darauf folgt der Geometry Shader.
 Dieser optionale Shader erhält als Eingabe einen Primitive und gibt keine
 oder mehre Primitives zurück.
 
\end_layout

\begin_layout Standard
Im Anschluss wird das Vertex Post-Processing ausgeführt.
 In diesem Schritt werden Teile außerhalb des Kamerafensters verworfen.
 Dieser Prozess nennt sich Clipping.
 In dieser Stufe werden die dreidimensionalen Koordinaten zu zweidimensionalen
 Kamerakoordinaten umgerechnet.
\end_layout

\begin_layout Standard
In der nächsten Stufe folgt das Primitve Assembly.
 Hier werden die erstellten Primitives zu einer Sammlung von finalen kleineren
 Primitives zerteilt.
 Zum Beispiel werden aus einer Liste von Vertices vom Primitive Typ GL_LINE_STRI
P mit 8 Mitgliedern 7 neue Primitives vom Typ Line-Base.
\end_layout

\begin_layout Standard
Im Anschluss werden die Primitives in diskrete Elemente unterteilt (gerastert).
 Diese Elemente nennt man Fragmente, welche an den Fragment Shader weitergereich
t werden.
 Die Ausgabe des Shaders ist ein Farb-, Tiefen- und sogenannter Stencilwert.
 Im letzten Schritt werden für die Ausgabewerte des Shaders eine Handvoll
 Tests durchgeführt.
 Ein Beispiel ist der Tiefentest (Depth-Test), um zu vermeiden, dass verdeckte
 Objekte gezeichnet werden.
 Andere Tests sind der Scissor-Test, der Stencil-Test und der Pixel-Ownership-Te
st.
\end_layout

\begin_layout Section
NanoHTTPD
\begin_inset CommandInset label
LatexCommand label
name "subsec:NanoHTTPD"

\end_inset


\end_layout

\begin_layout Standard
NanoHTTPD
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/NanoHttpd/nanohttpd
\end_layout

\end_inset

.
 Aufg.
 am 24.05.2016
\end_layout

\end_inset

 bezeichnet sich selbst als einen schlanken HTTP Server, welcher darauf
 ausgerichtet ist, sich einfach in bestehende Anwendungen einbetten zu lassen.
\end_layout

\begin_layout Standard
Das Projekt ist Open-Source und wird aktiv auf Github entwickelt.
\end_layout

\begin_layout Section
la4j
\end_layout

\begin_layout Standard
La4j
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://la4j.org/
\end_layout

\end_inset

.
 Aufg.
 am 10.06.2016
\end_layout

\end_inset

 ist eine, aus einem Studentenprojekt entstandene, offene Java Bibliothek.
 Die Bibliothek liefert Objekte (Matrizen und Vektoren) und Algorithmen
 für Lineare Algebra.
\end_layout

\begin_layout Section
DEFLATE
\end_layout

\begin_layout Standard
Bei DEFLATE 
\begin_inset CommandInset citation
LatexCommand citep
key "Deutsch:1996:DCD:RFC1951"

\end_inset

 handelt es sich um einen Kompressionsalgorithmus von Phil Katz aus dem
 Jahre 1993.
 Er kombiniert die Kompressionsalgorithmen LZ77 oder LZSS mit einer Huffman-Kodi
erung.
 Der Algorithmus zeichnet sich durch eine solide Kompression in kurzer Zeit
 aus.
 Der Algorithmus findet zum Beispiel im PNG-Format Anwendung.
\end_layout

\begin_layout Section
Volley 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Volley"

\end_inset


\end_layout

\begin_layout Standard
Bei Volley 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://developer.android.com/training/volley/index.html
\end_layout

\end_inset

.
 Aufg.
 am 24.05.2016
\end_layout

\end_inset

 handelt es sich um eine HTTP-Bibliothek zum Verwalten von Netzwerkanfragen.
 Volley bietet automatisches Koordinieren von Anfragen.
 Es ermöglicht mehrere nebenläufige Netzwerkverbindungen, Anfragen, Priorisierun
g und einiges mehr.
 Die Bibliothek ist frei und wird unter diesem Link
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://android.googlesource.com/platform/frameworks/volley/
\end_layout

\end_inset

.
 Aufg.
 am 24.05.2016 
\end_layout

\end_inset

 entwickelt.
\end_layout

\begin_layout Chapter
dotViewer
\begin_inset CommandInset label
LatexCommand label
name "chap:dotViewer"

\end_inset


\end_layout

\begin_layout Standard
Mobile Geräte verfügen über vergleichsweise begrenzte Ressourcen bezogen
 auf die Rechenleistung von CPU und GPU und Arbeitsspeicher.
 Punktwolken mit mehr als einer Million Punkte bringen die GPU schnell an
 ihre Grenzen.
 Daher wurde ein Ansatz gewählt, der es ermöglicht, Punkte nach Bedarf anzuzeige
n und zu vereinfachen.
 Zum Ermitteln der Punkte kommt ein Multiresolution Octree (siehe Sektion
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Multiresolution-Octree"

\end_inset

) zum Einsatz.
 Dadurch wird die GPU effizient eingesetzt.
 
\end_layout

\begin_layout Standard
Die Defizite beim Speicher werden durch eine Client-Server Architektur ausgeglic
hen (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Übersicht"

\end_inset

).
 Das eigentliche Modell wird von einem Server verwaltet.
 Der Client hat nur den momentan benötigten Satz Punkte gespeichert.
 Um Netzwerkverkehr niedrig zu halten, werden die Punkte von Client in einem
 Cache nach dem Least-Recently-Used Prinzip gespeichert.
 Zum Rendern werden die Punkte als Vertex Buffer Object in den Speicher
 der GPU geschrieben und anschließend gezeichnet.
 
\end_layout

\begin_layout Standard
Als Programmiersprache wurde Java gewählt aufgrund des guten Kompromisses
 aus Portabilität und Performance sowie der guten Integration in das Android
 Betriebssystem.
\end_layout

\begin_layout Standard
Als Entwicklungsumgebung wurde für den Client Android-Studio und für den
 Server Intellij IDEA verwendet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename uml/dataflow.svg
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Übersicht"

\end_inset

Das Datenflussdiagramm zeigt den groben Aufbau von Client und Server sowie
 die Interaktion mit der Api durch den Data-Access-Layer des Servers.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Server
\end_layout

\begin_layout Standard
Der Server hat drei Aufgaben.
 Zum ersten erstellt er aus gegebenen Punkten einen MRT.
 Seine zweite Aufgabe ist es, Punktanfragen zu bedienen und als letztes
 ein Proxy Objekt (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proxy-Design-Pattern"

\end_inset

) des MRT an die Clients zu verteilen.
\end_layout

\begin_layout Standard
Zur Interaktion stellt der Server ein RESTful Interface auf Basis des HTTP-Proto
kolls bereit.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Warum nicht normaler Socketverkehr
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Multiresolution Tree
\end_layout

\begin_layout Standard
Der Multiresolution Tree besteht aus vier Klassen (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Multiresolution-Tree-UML"

\end_inset

).
 Die Klasse 
\begin_inset Quotes gld
\end_inset

MultiResolutionTree
\begin_inset Quotes grd
\end_inset

 dient als Schnittstelle für alle äußeren Komponenten.
 Dadurch ist eine sinnvolle Kapselung gewährleistet.
 Sie beherbergt einen Zeiger auf den Wurzelknoten des MRTs.
 Des Weiteren legt sie einen Index von den Knoten an, um schnellen Zugriff
 zu ermöglichen.
 Zusätzlich existiert eine Factory-Methode zum Erstellen von Protocol Buffer
 Objekten.
\end_layout

\begin_layout Standard
Die Implementierung des MRT ist analog zu der Beschreibung in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Multiresolution-Octree"

\end_inset

.
 Jeder Knoten hat die absolute Koordinate seines Mittelpunktes als ID gespeicher
t.
 Erwähnenswert sind die Entscheidungen bei der Raster Klasse.
 Die Rasterwerte sind in einer internen Default Hash Map vermerkt.
 Diese bildet einen dreidimensionalen Vektor auf Farbwert und Gewicht ab.
 Charakteristisch ist bei einer Default Hash Map, dass bei Abfrage von nicht
 existierenden Einträgen ein Standartwert zurückgegeben wird.
 Dadurch wird im Vergleich zu einem 
\begin_inset Formula $n^{3}$
\end_inset

Array Speicherplatz gespart.
 Der eigentliche Rastervorgang wird durch die folgende Hashfunktion erreicht:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
H(p)=(\left\lfloor \frac{x(p)}{cellLength}\right\rfloor ,\left\lfloor \frac{y(p)}{cellLength}\right\rfloor ,\left\lfloor \frac{z(p)}{cellLength}\right\rfloor )
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $p$
\end_inset

 ist hier der Positionsvektor des Punktes relativ zum Ursprung des Würfels.
 Die Variable
\begin_inset Formula $cellLength$
\end_inset

 entspricht der Länge einer Gitterzelle.
 Also:
\begin_inset Formula 
\[
cellLength=\frac{cube.length}{k}
\]

\end_inset


\end_layout

\begin_layout Standard
Einfach gesprochen werden die Koordinaten auf ein Vielfaches der 
\begin_inset Formula $cellLength$
\end_inset

 abgerundet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/MultiResolutionTreeUML.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Multiresolution-Tree-UML"

\end_inset

Das UML-Diagramm zeigt den Aufbau des Multiresolution Trees.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit schnelle Zugriffe bei Anfragen auf die entsprechenden Knoten bzw.
 Punkte möglich sind, existiert eine weitere Hash Map als Index.
 Diese bildet Ids auf die entsprechenden Knoten ab.
 Der Index wird nach einer festen Anzahl Einfügeoperationen aktualisiert.
\end_layout

\begin_layout Subsection
RESTful API
\end_layout

\begin_layout Standard
Unter einer RESTful API versteht man ein Webinterface, welches die Beschränkunge
n von REST (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Representational-state-transfer"

\end_inset

) einhält.
\end_layout

\begin_layout Standard
Die API wurde mit Hilfe des NanoHTTPD Frameworks (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:NanoHTTPD"

\end_inset

) implementiert.
 NanoHTTPD wurde ausgewählt, weil es schlank und einfach ist.
\end_layout

\begin_layout Standard
Ressourcen werden über GET-Anfragen mit folgender Form abgerufen:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

GET SERVER_IP:PORT/?parameter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Werte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Erklärung
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes gld
\end_inset

proxy
\begin_inset Quotes grd
\end_inset

, 
\begin_inset Quotes gld
\end_inset

samples
\begin_inset Quotes grd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Definiert den Typ der Anfrage
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Id für Punktdaten
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Prinzipiell wird bei jeder Anfrage eine Fallunterscheidung an dem Parameter
 
\begin_inset Quotes gld
\end_inset

mode
\begin_inset Quotes grd
\end_inset

 gemacht.
 Die Anfragetypen werden im Folgenden vorgestellt.
\end_layout

\begin_layout Subsubsection
MRT-Proxy Anfrage
\begin_inset CommandInset label
LatexCommand label
name "subsec:MRT-Proxy-Anfrage"

\end_inset


\end_layout

\begin_layout Standard
Da die Ermittlung gebrauchter Punkte auf dem Clients stattfindet, muss auch
 dieser in Kenntnis über die Struktur des MRTs gesetzt werden.
 Aus diesem Grund stellt der Server ein MRT-Proxy zur Verfügung.
 Der MRT-Proxy ist im Prinzip gleich dem Multiresolution Octree, allerdings
 haben seine Knoten keine Punkte oder Rasterung gespeichert, sondern nur
 Ids, um beim Server die entsprechenden Punkte anzufragen.
 Diese können entweder Originalpunkte aus Blättern sein oder Punkte aus
 der Rasterung.
\end_layout

\begin_layout Standard
Eine Anfrage wäre zum Beispiel:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

GET 192.168.2.1:8080/?mode=tree
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zum Versenden wird aus der Datenstruktur ein Protocol Buffer Objekt erstellt.
 Diese kann dann problemlos serialisiert werden.
 Das Protocol Buffer Objekt ist wie folgt definiert.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package DataAccesLayer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

option java_outer_classname = "MultiResTreeProtos";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

message MRTree{
\end_layout

\begin_layout Plain Layout

	required MRNode root = 1;
\end_layout

\begin_layout Plain Layout

	message MRNode {
\end_layout

\begin_layout Plain Layout

		required string id = 1;    
\end_layout

\begin_layout Plain Layout

		repeated double center = 2 [packed=true];         
\end_layout

\begin_layout Plain Layout

		required double cellLength = 3;         
\end_layout

\begin_layout Plain Layout

		required int32 pointCount = 4;         
\end_layout

\begin_layout Plain Layout

		required bool isLeaf = 5;         
\end_layout

\begin_layout Plain Layout

		repeated MRNode octant = 6;     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Punktanfrage
\end_layout

\begin_layout Standard
Der 2.
 Typ Anfragen liefert Punkte an die Clients aus.
 Bei dieser Anfrage wird vom Client immer eine Id als Parameter mitgesendet.
 Diese Id passt auf einen Knoten des MRTs.
\end_layout

\begin_layout Standard
Falls es sich um einen inneren Knoten handelt, wird die Rasterung zu einer
 Liste von Punkten exportiert.
 Bei einem Blatt wird lediglich auf die vorhandene Punktliste zugegriffen.
 
\end_layout

\begin_layout Standard
Der Server greift über die 
\begin_inset Quotes gld
\end_inset

MultiResolutionTree
\begin_inset Quotes grd
\end_inset

 Klasse auf den entsprechenden Knoten zu und generiert ein Protocol Buffer
 Objekt.
 Die Spezifikation des Objektes lautet:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package DataAccesLayer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

option java_outer_classname = "RasterProtos";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

message Raster{     
\end_layout

\begin_layout Plain Layout

	repeated Point3DRGB sample = 1;
\end_layout

\begin_layout Plain Layout

	message Point3DRGB{         
\end_layout

\begin_layout Plain Layout

		repeated float position = 1;         
\end_layout

\begin_layout Plain Layout

		repeated float color = 2;         
\end_layout

\begin_layout Plain Layout

		required int32 size = 3;     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es handelt sich also um eine Liste von Punkten mit Positions-, Farb- und
 Gewichtswerten (size).
\end_layout

\begin_layout Standard
Alle Protocol Buffer Objekte werden, bevor sie über das Netzwerk versendet
 werden, serialisiert und durch den DEFLATE Algorithmus komprimiert, um
 den Netzwerkverkehr möglichst niedrig zu halten.
 
\end_layout

\begin_layout Section
Client
\end_layout

\begin_layout Standard
Bei dem Client handelt es sich um eine Android Anwendung.
 Der Client ist verantwortlich für das Darstellen der Punktwolke und reagiert
 auf Eingaben des Users.
\end_layout

\begin_layout Standard
Der Client verfolgt eine eventbasierte Architektur.
 Wird vom Nutzer eine Translation (Zwei-Finger Geste) oder Rotation (Slide
 Geste) an dem Punktmodell ausgeführt, kann sich die Menge der zu zeichnenden
 Punkte ändern.
\end_layout

\begin_layout Standard
Die Menge der momentan zu zeichnenden Punkte wird im Folgenden als aktive
 Punkte bezeichnet.
 Die Knoten, welche die aktiven Punkte beinhalten, werden als aktive Knoten
 bezeichnet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename uml/Client.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Das UML-Diagramm zeigt den Aufbau des Multiresolution Trees.
\begin_inset CommandInset label
LatexCommand label
name "fig:Client-UML"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Netzwerkverkehr
\end_layout

\begin_layout Standard
Bei der 
\begin_inset Quotes gld
\end_inset

DataAcessLayer
\begin_inset Quotes grd
\end_inset

 Klasse handelt es sich um ein Singleton (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Singleton-Pattern"

\end_inset

), welches als Schnittstelle für jeglichen Netzwerkverkehr fungiert.
 Diese verfügt über Funktionen zum Anfordern von Punkten oder des Proxys.
 Für die asynchronen Anfragen wird das Volley Framework verwendet (siehe
 Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Volley"

\end_inset

).
 Das Framework stellt eine Prioritätswarteschlange für HTTP-Anfragen zur
 Verfügung.
 Volley ermöglicht es, die Callback Funktion, welche nach Eintreffen einer
 Antwort aufgerufen wird, zu überschreiben, um eigene Logik zu definieren.
 Die zwei Methoden der Klasse werden im Folgendem vorgestellt.
\end_layout

\begin_layout Paragraph
buildMultiResTreeProtos(owner:MultiResTreeOwner)
\end_layout

\begin_layout Standard
Die Methode dekoriert eine Instanz, welche das 
\begin_inset Quotes gld
\end_inset

MultiResTreeOwner
\begin_inset Quotes grd
\end_inset

 Interface implementiert (z.B.
 
\begin_inset Quotes gld
\end_inset

RemotePointClusterGL
\begin_inset Quotes grd
\end_inset

) mit dem MRT-Proxy.
 
\end_layout

\begin_layout Standard
Als erster Schritt wird eine HTTP-Anfrage für den MRT Proxy an den Server
 gestellt.
 Beim Empfangen der Antwort werden die Daten deserialisiert und im Anschluss
 mit Hilfe einer Factory Methode zum MRT-Proxy umgewandelt.
 Die als Parameter übergebene Instanz erhält einen Zeiger auf den Proxy.
\end_layout

\begin_layout Paragraph
getSamples(id:String, cache:LRUDrawableCache)
\end_layout

\begin_layout Standard
Die Methode fordert Punktdaten vom Server an und speichert diese in einem
 Cache Objekt, welches später zum Zeichnen der Punkte verwendet wird.
 Beim Erhalten der Antwort werden die Daten zuerst dekomprimiert (DEFLATE)
 und deserialisiert.
 Im Anschluss werden die Farb-, Positions- und Gewichtswerte in einen nativen
 Buffer geschrieben, damit OpenGL bei Bedarf darauf zugreifen kann.
\end_layout

\begin_layout Subsection
Rendering
\end_layout

\begin_layout Standard
In diesem Abschnitt wird beschrieben, wie die Punktdaten ausgewählt und
 verarbeitet werden.
\end_layout

\begin_layout Subsubsection
Shader
\end_layout

\begin_layout Standard
Die Shader sind als Textdatei in den Android Ressourcen gespeichert.
 Bei der Initialisierung der OpenGL View-Instanz werden sie kompiliert und
 gelinkt.
 Im Folgenden werden die Shader vorgestellt.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# vertex_shader.glsl
\end_layout

\begin_layout Plain Layout

attribute vec3 a_Position; 
\end_layout

\begin_layout Plain Layout

attribute vec3 a_Color; 
\end_layout

\begin_layout Plain Layout

attribute float a_Size; 
\end_layout

\begin_layout Plain Layout

uniform mat4 u_Matrix; 
\end_layout

\begin_layout Plain Layout

varying vec4 v_Color;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void main() {     
\end_layout

\begin_layout Plain Layout

	v_Color = vec4(a_Color, 1.0);     
\end_layout

\begin_layout Plain Layout

	gl_Position = u_Matrix * (vec4(a_Position, 1.0));     
\end_layout

\begin_layout Plain Layout

	gl_PointSize = min(4.0, sqrt(a_Size)); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In dem Vertex Shader werden die Postionen der Punkte mit der Projektionsmatrix
 multipliziert und an die nächste Stufe der OpenGL Pipeline weitergegeben.
 Des Weiteren wird die Größe der zu zeichnenden Punkte berechnet.
 Es wird die Wurzel gezogen, um sehr große Werte abzuschwächen.
 Durch die min-Funktion wird eine obere Grenze von 4 eingeführt.
 Das ist nötig, denn bei sehr detaillierten Objekten kann das Gewicht schnell
 sehr groß werden.
 Die Farbwerte werden einfach an den Fragment Shader durch eine varying
 Variable weitergereicht.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

precision mediump float;
\end_layout

\begin_layout Plain Layout

varying vec4 v_Color;
\end_layout

\begin_layout Plain Layout

void main() {     
\end_layout

\begin_layout Plain Layout

	gl_FragColor = v_Color; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Fragment Shader empfängt die Farbwerte und gibt sie weiter an die vorgegeben
e Variable 
\begin_inset Quotes gld
\end_inset

gl_FragColor
\begin_inset Quotes grd
\end_inset

 und legt damit den Farbwert des Fragmentes fest.
\end_layout

\begin_layout Subsubsection
Scene Klasse
\end_layout

\begin_layout Standard
Die 
\begin_inset Quotes gld
\end_inset

Scene
\begin_inset Quotes grd
\end_inset

 Klasse (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Client-UML"

\end_inset

) ist ein Singleton welches die Schnittstelle für alle renderingrelevanten
 Aktionen bildet.
 Alle zu zeichnenden Objekte sowie die Kamera sind in dieser Klasse gespeichert.
 Nutzereingaben werden von dieser Klasse entgegengenommen und entsprechend
 verarbeitet.
\end_layout

\begin_layout Paragraph
drawScene()
\end_layout

\begin_layout Standard
Beim Aufruf der Methode wird die draw-Methode von jedem Element der Liste
 ausgelöst.
\end_layout

\begin_layout Subsubsection
RemotePointClusterGL
\end_layout

\begin_layout Standard
Die 
\begin_inset Quotes gld
\end_inset

RemotePointClusterGL
\begin_inset Quotes grd
\end_inset

 kümmert sich um das Ermitteln aktiver Punkte mit Hilfe des MRT, dafür sind
 Verweise auf den Cache und dem MRT-Proxy gespeichert.
 Des Weiteren greift die Klasse auf die 
\begin_inset Quotes gld
\end_inset

DataAccesLayer
\begin_inset Quotes grd
\end_inset

 Instanz zu, um entweder den MRT Proxy zu aktualisieren oder neue Punkte
 anzufordern.
 Bei Initialisierung der Instanz wird der Proxy vom Server erfragt.
 Der gespeicherte LRU-Cache beinhaltet die Punktdaten.
\end_layout

\begin_layout Standard
Immer wenn sich die Kameraposition ändert, wird die updateCache-Methode
 aufgerufen, um den aktiven Knoten zu ermitteln.
\end_layout

\begin_layout Paragraph
updateCache()
\end_layout

\begin_layout Standard
Die Methode bestimmt die momentan aktiven Punkte bzw.
 Knoten mit Hilfe des Proxy Objektes.
\end_layout

\begin_layout Standard
Knoten (mit ihren Punkten) werden zu den aktiven Knoten hinzugefügt, wenn
 folgende Kriterien erfüllt sind:
\end_layout

\begin_layout Itemize
die Punkte sind sichtbar
\end_layout

\begin_layout Itemize
die Auflösung der Punkte ist ausreichend oder schon maximal
\end_layout

\begin_layout Standard
Um das zu erreichen, wird der Proxy mit Hilfe des folgenden Algorithmus
 traversiert.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public List<String> getIdsViewDependent(){         
\end_layout

\begin_layout Plain Layout

	List<String> ids = new LinkedList<>();         
\end_layout

\begin_layout Plain Layout

	_getIdsViewDependent(root, ids);         
\end_layout

\begin_layout Plain Layout

	return ids; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private void _getIdsViewDependent(OctreeNodeGL currentNode, List<String>
 ids) {      
\end_layout

\begin_layout Plain Layout

	if ((currentNode.isLeaf || 
\end_layout

\begin_layout Plain Layout

	currentNode.getDetailFactor(this.owner) < DETAIL_THRESHOLD)){           
  
\end_layout

\begin_layout Plain Layout

		ids.add(currentNode.id);             
\end_layout

\begin_layout Plain Layout

		return;         
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	for (OctreeNodeGL node : currentNode.octants ) {             
\end_layout

\begin_layout Plain Layout

		if (node.isVisible(owner) && node.pointCount > 0)         
\end_layout

\begin_layout Plain Layout

			_getIdsViewDependent(node, ids);
\end_layout

\begin_layout Plain Layout

	}     
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Beim Test auf Sichtbarkeit wird geprüft, ob die projizierte Box (von einem
 Knoten) sich mit der View-Ebene schneidet.
 In jedem Schritt wird der Detail-Factor ermittelt und mit einem festgelegten
 Schwellenwert verglichen.
 Der Schwellenwert ist experimentell ermittelt und kann abhängig von der
 Leistung des Gerätes gewählt werden.
 Sobald der Detail-Factor klein genug ist, gilt der Knoten als ausreichend
 aufgelöst und wird gezeichnet.
 Der Detail-Factor berechnet sich wie folgt:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

getDetailFactor(MRTNode k, Camera c){
\end_layout

\begin_layout Plain Layout

	float[] edgePointsOnViewPlane = projectPoints(edgePoints(k), c)
\end_layout

\begin_layout Plain Layout

	float[] minimumBoundingBox = getMinimumBoundingBox(edgePointsOnViewPlane)
\end_layout

\begin_layout Plain Layout

	return getArea(minimumBoundingBox) * 1/(projectPoint(k.center.z, c))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die einfließende z-Koordinate sorgt dafür, dass von dem Betrachter entfernte
 Knoten weniger detailliert dargestellt werden.
\end_layout

\begin_layout Standard
Der komplette Vorgang findet in einem eigenem Thread statt, damit der Nutzer
 nicht warten muss, um neue Eingaben zu machen.
 Für die Verwaltung von Threads kommt die von Java mitgelieferte 
\begin_inset Quotes gld
\end_inset

ThreadPoolExecutor
\begin_inset Quotes grd
\end_inset

 Klasse zum Einsatz.
\end_layout

\begin_layout Standard
Nachdem alle nötigen Knoten festgestellt wurden, wird geprüft, ob sich diese
 schon im Cache befinden.
 Falls nicht, werden diese vom Server angefordert.
\end_layout

\begin_layout Paragraph
draw()
\end_layout

\begin_layout Standard
Zum Zeichnen des Modells wird die draw-Methode aller aktiver Knoten im Cache
 aufgerufen.
 
\end_layout

\begin_layout Subsubsection
DrawableCache Klasse
\end_layout

\begin_layout Standard
Diese Klasse speichert und cached die Punktdaten vom Server.
 Des Weiteren sendet sie Punktdaten als Vertex Buffer Object (VBO) an die
 GPU.
 Der Vorteil von VBOs ist, dass Punktdaten nicht bei jedem Frame neu übermittelt
 werden müssen.
 Stattdessen werden die Daten direkt auf der Grafikkarte gespeichert.
 Dadurch wird die Performance stark verbessert.
 Schlussendlich wird in dieser Klasse das Zeichnen durch OpenGL initiiert.
\end_layout

\begin_layout Standard
Der Cache besitzt eine Prioritätswarteschlange von Knoten nach dem LRU-Prinzip.
 Die Knoten besitzen die Punktdaten und einen Vermerk, ob diese schon im
 Speicher der GPU gelandet sind.
 Die Positions-, Farb- und Gewichtsdaten werden in einem einzigen Buffer
 pro Knoten ineinander abgespeichert, um die Performance zu verbessern 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLE
S_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVe
rtexData.html
\end_layout

\end_inset

.
 Aufg.
 am 13.05.2016
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Beim Zeichnen wird zuerst geprüft, ob die Daten des Knotens schon als VBO
 auf der GPU sind.
 Falls ja, werden die Punkte mit der folgenden Methode gezeichnet.
 Ansonsten werden die Punkte erst übermittelt.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    public void draw(){
\end_layout

\begin_layout Plain Layout

        glDrawArrays(GL_POINTS, 0, pointCount);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Benutzer Interface
\end_layout

\begin_layout Standard
Die Applikation unterstützt drei Gesten zum Erkunden der Modelle.
 Das einfache Scrollen mit einem Finger wird als Rotation interpretiert.
 Modelle können pro Bewegung nur um eine Achse rotiert werden, um die Eingabe
 zu vereinfachen.
 Zwei-Finger-Scrollen wird als Zoom verstanden und das Zusammenziehen von
 zwei Fingern (Pinch) als Skalierung.
 
\end_layout

\begin_layout Standard
Für das Verarbeiten der Scroll-Gesten mit einem oder zwei Fingern werden
 Eingaben an die 
\begin_inset Quotes gld
\end_inset

GestureListener
\begin_inset Quotes grd
\end_inset

 Klasse weitergeleitet.
 Diese Klasse implementiert das von Android mitgelieferten 
\begin_inset Quotes gld
\end_inset

GestureDetector.OnGestureListener
\begin_inset Quotes grd
\end_inset

 Interface.
 Bei Pinch Eingaben kommt die 
\begin_inset Quotes gld
\end_inset

ScaleListener
\begin_inset Quotes grd
\end_inset

 Klasse zum Einsatz.
 Diese implementiert das vorgegebene 
\begin_inset Quotes gld
\end_inset

ScaleGestureDetector.OnScaleGestureListener
\begin_inset Quotes grd
\end_inset

 Interface.
 Die Listener Klassen besitzen Zeiger auf das 
\begin_inset Quotes gld
\end_inset

Scene
\begin_inset Quotes grd
\end_inset

 Singleton.
 Die Call-Back Methoden der Listener Klasse rufen dann die entsprechenden
 Transformationsmethoden auf.
\end_layout

\begin_layout Standard
Des Weiteren bietet die Applikation in seinem Actionbar, dem schwarzen Menübalke
n am oberen Bildschirm, einen Zugang zum Settings-Menü.
 Dort kann die IP des Servers sowie ein Schwellenwert für die Detailstufe
 eingetragen werden.
\end_layout

\begin_layout Chapter
Experimente und Auswertungen
\begin_inset CommandInset label
LatexCommand label
name "chap:Experimente-und-Auswertungen"

\end_inset


\end_layout

\begin_layout Standard
In diesem Kapitel soll die Performance des dotViewers evaluiert werden.
 Performance ist hier definiert als die Anzahl der berechneten Bilder (Frames)
 pro Sekunde (FPS).
 Umso mehr Bilder pro Sekunde berechnet werden, desto performanter und flüssiger
 ist die Darstellung.
 Die Darstellungsqualität selbst gibt Aufschluss darüber, wie gut die Datenstruk
tur das Grundmodell vereinfacht.
\end_layout

\begin_layout Section
Durchführung
\end_layout

\begin_layout Standard
Zur Messung werden unterschiedliche Modelle in verschiedenen Vergrößerungsstufen
 um 360 Grad gedreht.
 Die Punkte jedes Modells werden vollständig in die Datenstruktur eingefügt,
 bevor gemessen wird.
 Zum Messen der FPS wurde eine einfache Methode in den Mainloop von OpenGL
 hinzugefügt, welche den Wert in der Konsole ausgibt.
 Als Erstes wird eine Felslandschaft mit ca.
 1.6 Millionen Punkten analysiert.
 Das Modell wurde vom dem Archaeocopter Projekt via 3D-Rekonstruktion errechnet.
 Als Zweites wird eine Baustelle und Umgebung mit 20 Millionen Punkten getestet.
 Das Modell stammt von der Jacobs University Bremen gGmbH und wurde von
 Dorit Borrmann, Jan Elseberg, Hamid Reza Houshiar und Andreas Nüchter aufgenomm
en.
 Angeboten wird das Modell in dem Robotic 3D Scan Repository
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://kos.informatik.uni-osnabrueck.de/3Dscans/
\end_layout

\end_inset


\end_layout

\end_inset

.
 Als Server kommt ein Thinkpad T460 mit einem Intel i5 Prozessor und 16GB
 RAM zum Einsatz.
 Bei dem Client handelt es sich um ein LG G3 Smartphone mit einem 4-Kern
 Qualcomm Snapdragon 80 Chip.
 Das Smartphone verfügt über eine Auflösung von 1440x2560 Pixel und 2 GB
 RAM und ist damit mit einem Tablett vergleichbar.
 Der Netzwerkverkehr läuft über das WLAN.
\end_layout

\begin_layout Standard
Die Messwerte und die Darstellungsqualität selbst geben Aufschluss darüber,
 wie gut die Datenstruktur das Grundmodell vereinfacht.
 
\end_layout

\begin_layout Section
Auswertung
\end_layout

\begin_layout Standard
Die Felslandschaft ist mit 1.5 Millionen Punkten für ein Landschaftsmodell
 wenig detailliert.
 Der Aufbau des MRTs auf dem Server dauert 3 Minuten.
 Das Modell wird von der Applikation mit mindestens 30FPS in jeder Perspektive
 dargestellt.
 Die verschiedenen Detailstufen werden kaum spürbar nachgeladen (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Terra_close"

\end_inset

 und Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Terra_far"

\end_inset

).
 Verzögerungen durch den Netzwerkverkehr beim Aufbau des Bildes übersteigen
 nicht die 5-Sekunden-Marke.
 Sobald Flächen mit unterschiedlichen Sampleraten nebeneinander liegen,
 kann es zu sichtbaren Grenzen kommen.
 Das kann passieren, sobald eine gerasterte Fläche (innerer Knoten) neben
 einer Fläche mit rohen Punktdaten (Blatt) liegt.
 Der Effekt ist in Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Terra_close"

\end_inset

 im oberen Bild zu beobachten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/far_terra1.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/far_terra2.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Visualisierung einer Felsschlucht aus der ferner Distanz.
 Details wurden hier vereinfacht.
 Die dicker gezeichneten Punkte repräsentieren Bereiche mit einer hohen
 Dichte an Punkten.
\begin_inset CommandInset label
LatexCommand label
name "fig:Terra_far"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/mid_terra1.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/close_terra1.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Oben: Bild aus mittlerer Perspektive.
 Eine Kante zwischen zwei Oktanten ist oben rechts im Bild deutlich erkennbar.
 Unten: Die Schlucht in naher Aufnahme.
 Punkte welche in der Ferne liegen werden gröber Dargestellt.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Terra_close"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das zweite Modell stellt eine weitläufige Baustelle dar.
 Das Modell enthält urbane Objekte, z.B.
 Häuser und Brücken.
 Das Einfügen der 20 Millionen Punkte in den MRT dauert 13 Minuten.
 Die Darstellung des Geländes wird durch die Applikation sinnvoll vereinfacht.
 Die Performance bleibt bei jeder Einstellung über 18FPS.
 Auffallend sind die recht hohen Latenzen von bis zu 10 Sekunden beim Nachladen
 der einzelnen Oktanten.
 Diese sind allerdings nicht verwunderlich Anbetracht der hohen Menge an
 Punkten, welche vom Server an die Clients gesendet werden.
 Bei nahen Darstellungen werden Details sichtbar.
 Es kann auf kurzer Distanz zu verdunkelten Bereichen kommen, sobald der
 Punktabstand größer als 1 Pixel beträgt (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:bstelle_close"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/bstelle_far2.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/bstelle_close4.png
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Oben: Vereinfachte Darstellung der Baustelle.
 Viele Details wurden durch einfache Punkte ersetzt.
 Unten: Nahaufnahme der Sandkuhle.
 Auffallend ist die dunkle Verfärbung des hinteren Bereiches.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:bstelle_close"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/bstelle_mid1.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/bstelle_mid4.png
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Beide Bilder zeigen die Baustelle auf mittlerer Distanz.
 Die Bildfrequenz liegt bei den Szenen bei ungefähr 15FPS.
 Das Nachladen zwischen den Zoomstufen ist stark spürbar, wenn die Daten
 nicht gecached sind.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Zusammenfassung und Ausblick
\end_layout

\begin_layout Section
Zusammenfassung
\end_layout

\begin_layout Standard
In der vorliegenden Bachelorarbeit wurde eine Implementierung zum Betrachten
 von großen Punktmengen auf Android Geräten vorgestellt.
 
\end_layout

\begin_layout Standard
Im Kapitel Grundlagen und verwandte Arbeiten wurde eine Einführung in die
 3D-Rekonstruktion gegeben.
 Des Weiteren wurden unterschiedliche Repräsentationen von Punktwolken diskutier
t.
 Im Folgenden wurden bestehende Lösungen für mobile Geräte diskutiert.
 Aktuelle Arbeiten konnten große Punktmengen mit mehr als 100 Millionen
 Punkten bewältigen.
 Allerdings wurden offline Datenstrukturen für die Punktverwaltung verwendet.
 Daher mussten die Punktwolken beim Erstellen schon vollständig vorliegen.
\end_layout

\begin_layout Standard
Aufbauend auf diesem Schwachpunkt wurde im Kapitel dotViewer eine Applikation
 vorgestellt, welche zum einen in der Lage ist, Punktdaten online zu verarbeiten
 sowie Punktwolken mit über 20 Millionen Punkten darzustellen.
 Die theoretische Grundlage für die verwendete Datenstruktur war der in
 Kapitel 2 vorgestellte MRT.
 Als Architektur wurde das Client-Server Modell mit einer RESTfull API gewählt,
 um Speicher und GPU vom Tablett zu entlasten.
 
\end_layout

\begin_layout Standard
In Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Experimente-und-Auswertungen"

\end_inset

 wurde die Applikation durch Messen der FPS und durch Beobachten der Darstellung
 evaluiert.
 Die Framerate ist dabei nicht unter 15FPS gesunken, was völlig ausreichend
 für das Betrachten ist.
 Durch die teilweise unterschiedlich aufgelösten Rasterungen kann es zu
 sichtbaren Kanten kommen.
 Des Weiteren können Bereiche dunkler wirken, wenn der Punktabstand ein
 wenig größer ist als die Pixeldichte.
 Dieser Effekt ist nicht verwunderlich, da zwischen den Punkten nicht interpolie
rt wird.
 Dadurch füllen sich die leeren Bereiche mit der Hintergrundfarbe und die
 Farbe wirkt verfälscht.
\end_layout

\begin_layout Section
Ausblick
\end_layout

\begin_layout Standard
Viele Komponenten der Anwendung sind einfach gehalten, um den angepeilten
 Zeitrahmen nicht zu sprengen.
 Der Server ist nicht an eine Datenbank gekoppelt, um Daten auf die Festplatte
 auszulagern.
 Dadurch wäre die Größe der Modelle theoretisch nur vom Festplattenspeicher
 begrenzt und die Applikation könnte vergleichbare Punktenmengen verarbeiten
 wie HuMoRs.
 Ein weiteres Problem ist die Kompression vor dem Netzwerkverkehr.
 Für die Punktdaten lässt sich sicherlich eine besser angepasste Kompression
 finden.
 Andere Projekte benutzen hierfür zum Beispiel eine Wavletkompression 
\begin_inset CommandInset citation
LatexCommand citep
key "VAST:VAST12:057-064"

\end_inset

 .
 Die Steuerung ist auch nicht optimal gelöst.
 Intelligentere Mechanismen, wie sie bei HuMoRs vorhanden sind, wären eine
 sinnvolle Ergänzung.
\end_layout

\begin_layout Standard
Es würde sich auch anbieten, den Server um weitere HTTP-Methoden zu erweitern.
 Die PUT-Methode könnte zum Hinzufügen von Punkten genutzt werden.
 Dadurch wäre der Server über eine plattformunabhängige Schnittstelle gut
 ansprechbar .
\end_layout

\begin_layout Standard
Die Client
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/garlicPasta/dotViewer
\end_layout

\end_inset


\end_layout

\end_inset

 und Server
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/garlicPasta/dotServer
\end_layout

\end_inset


\end_layout

\end_inset

 wird nach Abgabe dieser Arbeit frei zugänglich durch die Entwicklungsplattform
 Github sein.
 Aufgrund seiner modularen Architektur sind weitere Komponenten unkompliziert
 nachreichbar.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "sources"
options "bibtotoc,plainyr"

\end_inset


\end_layout

\end_body
\end_document
