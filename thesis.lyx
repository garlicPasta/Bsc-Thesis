#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{url}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Darstellung gigantischer Punktwolken auf Android Geraeten
\end_layout

\begin_layout Author
Jakob Krause
\end_layout

\begin_layout Section
Einführung 
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
Das Archaeocopter Projekt, welches 2012 von Dr.
 Benjamin Ducke and Prof.
 Dr.
 Marco Block-Berlitz ins Leben gerufen wurde, suchte nach einer Moeglichkeit
 zur live Darstellung von Punkten waehren der Fluege.
 
\end_layout

\begin_layout Standard
Die Idee ist mit Hilfe der Darstellung feststellen zu können, fuer welche
 Bereiche des Objektes noch mehr Information gesammelt werden muessen.
\end_layout

\begin_layout Standard
Dadurch kann waehrend des Fluges erkannt werden welche Bereiche schwer zu
 erkennen sind.
 
\end_layout

\begin_layout Standard
Die Darstellung sollte auf einem Android Tabelett implementiert werden.
\end_layout

\begin_layout Standard
Die Herrausforderung bestand darin trotz der Limitierungen eines Tabletts
 (wenig RAM, schwache GPU) Punktwolken mit mehreren Millionen Punkten fluessig
 Darzustellen.
 Dabei muss es moeglich sein jederzeit neue Punkte in die bestehende Darstellung
 einzufuegen.
\end_layout

\begin_layout Subsection
Ziele
\end_layout

\begin_layout Standard
Hauptziel der Arbeit ist es eine Datenstruktur zu entwickeln welche es ermoeglic
h die Bereiche der Punktwolke in unterschiedliche Detailstufen zu liefern.
\end_layout

\begin_layout Standard
Das System folgt der Client Server Architektur.
 Daher muss eine effiziente Loesung fuer den Netzwerkverkehr gefunden werden.
\end_layout

\begin_layout Standard
Ein weiteres Ziel der Arbeit war es, die Architektur möglichst modular und
 Plattformunabhaengig zu gestalten um dadurch Austauschbarkeit Wiederverwendbark
eit der einzelnen Komponenten zu gewährleisten.
\end_layout

\begin_layout Standard
Es soll möglichst einfach sein eine App fuer iOS oder ein anderes mobiles
 Betriebssystem nachzureichen.
 Desweiteren soll eine moderne Auswahl von benutzten Frameworks/Komponenten
 getroffen werden.
\end_layout

\begin_layout Standard
Die App sollte moeglichst intuitiv benutzbar sein.
\end_layout

\begin_layout Section
Vergleichbare Arbeiten
\end_layout

\begin_layout Standard
Das Interesse an der Darstellung von großen Punktwolken ist durch das Aufkommen
 von modernen 3D Scanner in den letzten Jahrzehnt stark gewachsen.
\end_layout

\begin_layout Subsection
KiwiViewer
\end_layout

\begin_layout Standard
KiwiViewer ist eine freie 'open-source' App zum erkunden von Punktwolken.
\end_layout

\begin_layout Standard
Die App ist fuer Android sowie iOS verfügbar.
 Multi-Touch Gestensteuerung wird unterstutzt.
 
\end_layout

\begin_layout Standard
KiwiViewer 
\begin_inset CommandInset citation
LatexCommand cite
key "KiwiVierwer"

\end_inset

 bedient sich der 
\begin_inset Quotes eld
\end_inset

Point Cloud Library
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "PCL"

\end_inset

 fuer seine Kernfunktionen.
 Die Punktmenge wird entweder ueber eine SD Karte, eMail oder URL geladen.
\end_layout

\begin_layout Standard

\emph on
Abgrenzung
\end_layout

\begin_layout Standard
Die App speichert die geladenen Punkte direkt auf dem Tablett.
 Daher sind die Modelle auch auf dessen Arbeitspeicher beschränkt.
 Modelle mit mehreren Millionen Punkten sind nicht darstellbar.
\end_layout

\begin_layout Subsection
QSplat Verfahren
\end_layout

\begin_layout Standard
Erste Vorschläge zur Darstellung von sehr großer Punktmengen wurden durch
 das QSplat
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2000:QMP:344779.344940"

\end_inset

 Verfahren gemacht.
 Die Punktemenge wird durch 'multiresolution' Hierarchie auf Basis von 'bounding
 spheres' modelliert.
 Abhängig von der Kameraposition wird die Struktur bis zu einer gewissen
 Tiefe (Auflösung) durchlaufen.
 Das Verfahren kann modifiziert auch zum streaming von Punktwolken genutzt
 werden 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2001:SQV:364338.364350"

\end_inset

 .
 Für HD Displays ist der Algorithmus zu rechenintesiv weil die Berechnung
 pro Display Punkt von der CPU erledigt wird.
 
\end_layout

\begin_layout Subsection
Multiresolution Octree
\end_layout

\begin_layout Standard
Moderne Ansätze benutzen einen Multiresolution Octree
\begin_inset CommandInset citation
LatexCommand cite
key "Wand:2008:SSP:1363373.1363581"

\end_inset

.
 Diese Datenstruktur speichert die original Punkte in ihren äusseren Knoten.
 Die inneren Knoten beinhalten gröbere Praesentationen für ihre Zellen.
\end_layout

\begin_layout Standard
Die Punktdaten werden 'out-of-core' verwaltet, also dynamisch von der Festplatte
 geladen.
 Der Octree bietet den Vorteil, das Punkte dynamisch hinzugefügt werden
 können.
 
\end_layout

\begin_layout Standard

\emph on
Abgrenzung
\end_layout

\begin_layout Standard
Das Paper beschreibt ein Verfahren für Desktop Systeme.
 Eigenarten von Mobilen Geraten wie Netzwerkverkehr sind nicht berücksichtigt.
\end_layout

\begin_layout Subsection
Knn-Tree iOS
\end_layout

\begin_layout Standard
Eine weitere Möglichkeit ist ein Knn-Tree zu verwenden
\begin_inset CommandInset citation
LatexCommand cite
key "VAST:VAST12:057-064"

\end_inset

.
 Allerdings mit der Beschränkung, dass die Punktmenge von Anfang an vollständig
 ist.
\end_layout

\begin_layout Standard
Diese Arbeit richtet sich besonders an die Darstellung auf mobilen Geräten.
 Die Datenstruktur selbst wird auf einem Server gespeichert.
 Knoten werden auf Anfrage eines Clienten übertragen.
\end_layout

\begin_layout Standard
Ubertragende Knoten werden mit Hilfe eines LRU-Cache gespeichert.
 Die Implementierung erfolgte in C++ und OpenGl ES.
 Für die Netzwerkkommunikation wir 'http pipelining' sowie eine Wavletkompressio
n verwendet.
 
\end_layout

\begin_layout Standard

\emph on
Abgenzung
\end_layout

\begin_layout Standard
Die Datenstruktur ist nicht dynamisch, also die Menge der Punkte muss von
 Anfang an fest stehen.
 Implementierung erfolgte in C++ fur iOS.
\end_layout

\begin_layout Standard
Netzwerkverkehr erfolgt uber Http Pipelining.
\end_layout

\begin_layout Section
Gewählter Lösungsansatz
\end_layout

\begin_layout Subsection
Datenstrukturen
\end_layout

\begin_layout Subsubsection
Octree
\end_layout

\begin_layout Standard
Octrees sind eine Datenstruktur um 3d dimensionale Daten hierarchisch zu
 untergliedern.
 Sie wurde 1980 von Donal Maegher beschrieben.
 Octrees sind im 3 dimensionalen das was im 1 dimensionale Binarytrees sind
 und im 2 dimensionalen die Quadtrees.
\end_layout

\begin_layout Standard
Die Wurzel repräsentiert alle eingefuegten Daten.
 Jeder innere Knoten besitzt 8 Kinder.
 Diese unterteilen den Knoten in 8 gleichgrosse Octanten usw.
\end_layout

\begin_layout Paragraph
Einfügen
\end_layout

\begin_layout Standard
2
\end_layout

\begin_layout Subsubsection
Muliresolution Octree
\end_layout

\begin_layout Subsection
Architektur
\end_layout

\begin_layout Standard
Die Applikation besteht entspricht einer Client-Server Architektur.
\end_layout

\begin_layout Standard
Client und Server sind beide in Java geschrieben.
\end_layout

\begin_layout Subsubsection
Server
\end_layout

\begin_layout Standard
Der http Server stellt dem Client die Datenstruktur zur Verfügung um benötigte
 Punkte zu ermitteln.
 Als HTTP Server kommt 
\begin_inset Quotes eld
\end_inset

nanohttpd
\begin_inset Quotes erd
\end_inset

 zum Einsatz, weil es schlank und einfach ist.
\end_layout

\begin_layout Standard
Des weiteren liefert er diese Punkte auf Anfrage aus.
\end_layout

\begin_layout Standard
Da es nötig ist Punkte kontinuierlich hinzufügen kommt ein 'Multi Resolution'
 Octree
\begin_inset CommandInset citation
LatexCommand cite
key "Wand:2008:SSP:1363373.1363581"

\end_inset

 zum Einsatz.
\end_layout

\begin_layout Standard
Die Knoten des Baumes enthalten lediglich Keys zu den Daten.
\end_layout

\begin_layout Standard
Die eigentlichen Punkte werden in einer Key-Value Datenbank gespeichert
 und für Anfragen zu Verfügung stellt.
\end_layout

\begin_layout Standard
Das Model selbst ist auf die Blätter verteilt.
 Die inneren Knoten erhalten vereinfachte Abbilder von seinen Kindern.mu
\end_layout

\begin_layout Itemize
Programmiersprache Java
\end_layout

\begin_layout Itemize
dynamischer 'Multi Resolution' Octree
\end_layout

\begin_layout Itemize
'Redis'
\begin_inset CommandInset citation
LatexCommand cite
key "Redis"

\end_inset

 als Key-Value Datenbank
\end_layout

\begin_layout Itemize
Kompression 
\end_layout

\begin_layout Subsubsection
Client
\end_layout

\begin_layout Standard
Der Android-Client erhält ein Abbild der Datenstruktur vom Server und synchronis
iert diese regelmaessig.
 Beim traversieren der Struktur werden an den Server Anfragen gesendet.
\end_layout

\begin_layout Standard
Empfangene Daten werden in einem 'last recently used' Cache gespeichert.
 Dieser Cache wird gleichzeitig von OpenGl als Buffer für die Punkte benutzt.
\end_layout

\begin_layout Standard
Es existiert ein Buffer für die Punktposition sowie für die RGB Werte.
\end_layout

\begin_layout Standard
Die Anfragen zum Server laufen über das http Protokoll.
 
\end_layout

\begin_layout Itemize
Programmiersprache Java
\end_layout

\begin_layout Itemize
'Volley'
\begin_inset CommandInset citation
LatexCommand cite
key "Volley"

\end_inset

 for asynchrone http Anfragen
\end_layout

\begin_layout Itemize
OpenGl ES für das Rendering
\end_layout

\begin_layout Itemize
UI
\end_layout

\begin_layout Subsubsection
Netzwerktransfer
\end_layout

\begin_layout Itemize
Plattform unabhängigkeit durch 
\begin_inset Quotes eld
\end_inset

google Protocoll Buffer
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section*
Schwierigkeiten
\end_layout

\begin_layout Section*
Dokumentation der Durchführung
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "sources"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
