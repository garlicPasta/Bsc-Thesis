#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
\usepackage{url}
\usepackage{graphicx}
\usepackage{titlesec}



\title{\includegraphics[width=0.6\textwidth]{img/logo}\\
{\normalsize Bachelorarbeit am Institut für Informatik der Freien Universität Berlin}\\ Darstellung gigantischer Punktwolken auf Android Geräten}

\author{Jakob Krause\\
Matrikelnummer: xxxxxxx \\
jakobkrause@zedat.fu-berlin.de\\\\
Betreuung und Erstgutachten:\\ Prof. Dr. Marco Block-Berlitz\\
Zweitgutachten:\\ }
\date{\today}
\end_preamble
\options ngerman
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Java,frame=lrbt,numbers=left,showstringspaces=false,breaklines=true,xleftmargin=15pt,basicstyle={\ttfamily},keywordstyle={\color{blue}\ttfamily},stringstyle={\color{red}\ttfamily},commentstyle={\color{green}\ttfamily}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
maketitle 
\end_layout

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
vfill{}
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{page}{1} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Einführung
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
Das Interesse an der Darstellung von großen Punktwolken ist durch das Aufkommen
 von günstigen 3D Scanner und der 3D Rekonstruktion in den letzten Jahrzehnt
 stark gewachsen.
 Aufgrund der technologischen Entwicklungen in diesem Bereich, ist es möglich
 von kleinen Objekten, wie einem Dinosaurier Schädel, bis hin zu ganzen
 Städte in hoher Detailstufe digital zu erfassen.
 In der Denkmalpflege werden Objekte mittlerweile aus Routine abgescannt
 und archiviert.
 
\end_layout

\begin_layout Standard
Für gewöhnlich sind die erzeugten Modelle enorm groß und daher nicht ohne
 weiteres darstellbar.
 Die Modelle bestehen meist aus einer ungeordneten Sammlung von dreidimensionale
n Punkten mit Farbinformationen.
 Desktop Lösung verlassen sich zur Lösung des Problems auf Level-of-Detail(LOD)
 Konzepte kombiniert mit Out-of-core Verfahren und klugen Caching Strategien
 um der hohen Datenmenge Herr zu werden.
 Durch das Aufkommen von leistungsstarken Smartphones entstand eine neue
 Plattform zum Darstellen von Modellen.
\end_layout

\begin_layout Standard
Daraus entstand eine Nachfrage durch Forschungsgruppen für eine mobile Applikati
on zum Betrachten großer Modelle.
 
\end_layout

\begin_layout Standard
Die Applikation kann Beispielsweise bei 3D Rekonstruktion schnelles Feedback
 liefern, vereint mit den Vorzügen eines mobilen Gerätes.
 Dadurch können schnell unvollständige oder schwer zu erfassende Bereiche
 des Modells beim Scannen erkannt werden.
 Des weiteren kann die Applikation zur Präsentation von Modellen eingesetzt
 werden.
\end_layout

\begin_layout Standard
Die Herausforderung bestand darin trotz der Limitierungen eines Tablets
 durch seinen geringen Arbeitsspeicher und der Vergleichsweisen schwache
 GPU Punktwolken mit mehreren Millionen Punkten flüssig darzustellen.
 Dabei sollte es möglich sein jederzeit neue Punkte in die bestehende Darstellun
g hinzuzufügen.
 Zur Zeit existieren nur bedingt geeignet Softwarelösungen für das Problem.
\end_layout

\begin_layout Subsection
Archaeocopter und Archaeonautic Projekt
\begin_inset CommandInset label
LatexCommand label
name "sub:Archaeocopter-Projekt"

\end_inset


\end_layout

\begin_layout Standard
Das Archaeocopter Projekt, welches 2012 von Dr.
 Benjamin Ducke und Prof.
 Dr.
 Marco Block-Berlitz ins Leben gerufen wurde, hat es sich zum Ziel gesetzt
 eine unbemanntes Flugobjekt (UAV) zu entwickeln, welcher durch halb-autonome
 Flüge Archäologen bei ihrer Arbeit durch Luftaufnahmen unterstützt.
 Aus diesen Aufnahmen lassen sich durch 3d Rekonstruktion Modelle generieren.
 Die Technik wird auch zum Denkmalschutz angewandt.
\end_layout

\begin_layout Standard
Die Idee war es aktuelle Verfahren aus der Computervision und künstlichen
 Intelligenz zusammen mit UAVs mit Kameras für die Datenerhebung einzusetzen.
 Das innovative Verfahren lässt sich auch Unterwasser einsetzen.
\end_layout

\begin_layout Standard
Offiziell ging das Projekt im September 2012 mit Unterstützung von Prof.
 Dr.
 Raúl Rojas von Berlin's Freie Universität an den Start.
\end_layout

\begin_layout Standard
Diese Arbeit ist in Zusammenarbeit mit dem Projekt entstanden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/slider008.jpg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Archaeocopter Projekt
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Bilder
\end_layout

\end_inset


\end_layout

\begin_layout Section
Ziele
\end_layout

\begin_layout Standard
Ziel dieser Arbeit ist es ein mobile Applikation für das Android Betriebssystem
 zu entwickeln, welche in der Lage ist Punktwolken mit mehreren Millionen
 Punkten performant darzustellen.
 Dabei soll es möglich sein Punkte in die bestehende Darstellung zur Laufzeit
 hinzuzufügen.
\end_layout

\begin_layout Standard
Ein weiteres Ziel der Arbeit ist es, die Architektur möglichst modular und
 plattformunabhängig zu gestalten um dadurch Austauschbarkeit und Wartbarkeit
 der einzelnen Komponenten zu gewährleisten.
 Es sollte möglichst einfach sein, eine Applikation für iOS oder ein anderes
 mobiles Betriebssystem nachzureichen.
 Des weiteren soll eine moderne Auswahl von Frameworks getroffen werden.
 Dabei soll die Applikation möglichst intuitiv benutzbar sein.
\end_layout

\begin_layout Chapter
Theorie und verwandte Arbeiten
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Punktwolken diskutieren, Formate ply, nvm.
 visualsfm
\end_layout

\end_inset


\end_layout

\begin_layout Section
Theorie
\begin_inset CommandInset label
LatexCommand label
name "sec:Theorie"

\end_inset


\end_layout

\begin_layout Subsection
Punktwolken
\end_layout

\begin_layout Paragraph*
Definition 
\end_layout

\begin_layout Standard
Im Rahmen dieser Arbeitet ist ein Punkt 
\begin_inset Formula $p$
\end_inset

 wie folgt definiert: 
\begin_inset Formula 
\begin{eqnarray*}
p & \in & \{x,y,z,r,g,b\}\\
x,y,z & \mathbb{\in} & \mathbb{R}\\
r,g,b & \in & [0,1]
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
X,y und z entspricht der Position im euklidischen Raum.
 R,g und b sind Farbwerte aus dem RGB-Farbraum.
\end_layout

\begin_layout Paragraph
Definition
\end_layout

\begin_layout Standard
Eine Punktwolke ist eine Menge von Punkten p.
\end_layout

\begin_layout Subsection
Einführung in die 3D Rekonstruktion
\end_layout

\begin_layout Standard
Die Idee aus einer Folge von Bilder ein 3D Model zu errechnen ist eines
 der Kernthemen der Computervision.
 Verwendungen dieser Technik sind vielfältig und finden sich in der Wissenschaft
 und Wirtschaft wieder.
 Anwendungen existieren zum Beispiel in der Robotik, 
\begin_inset CommandInset citation
LatexCommand cite
key "klimentjew2008grundlagen"

\end_inset

 in welcher mit Hilfe eines Stereokamerasystems die Position des Roboters
 innerhalb seiner Umgebung feststellbar ist.
 Ein weiteres Feld ist die Archäologie und der Denkmalsschutz.
 Ein Beispiel dafür ist das Archaecopter Projekt.
\end_layout

\begin_layout Standard
Allgemein kann man zwischen aktiver und passiver Rekonstruktion 
\begin_inset CommandInset citation
LatexCommand cite
key "ladikos2011real"

\end_inset

 unterscheiden.
\end_layout

\begin_layout Subsubsection
Aktive Rekonstruktion
\end_layout

\begin_layout Standard
Bei aktiver Rekonstruktion wird aktiv mit einem Sensors das Objekt abgetastet
 um die Struktur zu ermitteln.
 3D Scanner sind ein Vertreter dieser Gattung.
 Sie sind der Kamera ähnlich.
 Genau wie diese besitzen sie ein Sichtfeld.
 Allerdings liefern sie statt Farbwert Abstandswert von seinem Sichtfeld.
 Die Abstandswerte können entweder über die 
\begin_inset Quotes gld
\end_inset

Time of Flight
\begin_inset Quotes grd
\end_inset

 oder die Triangulierungmethode ermittelt werden.
\end_layout

\begin_layout Standard
Bei der 
\begin_inset Quotes gld
\end_inset

Time of Flight
\begin_inset Quotes grd
\end_inset

 Methode wird ein Laserstrahl versendet.
 Aus der Dauer bis die Reflektion ihren Ausgangspunkt erreicht kann die
 Entfernung ermittelt werden.
 Diese Methode ist bei nahen und feinen Objekten ungenau weil die Zeit nur
 zu einer gewissen Genauigkeit gemessen werden kann.
\end_layout

\begin_layout Standard
Bei der Triangulierungsmethode wird von einem Laser ein Punkte auf das das
 Objekt projektiert.
 Dieser Punkt wird von einer Kamera erfasst.
 In Abhängigkeit von der Entfernung erscheint der Laserpunkt im Sichtfeld
 der Kamera.
 Um das Verfahren zu beschleunigen kann statt einem Punkt auf eine Linie
 verwendet werden.(siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TriangulierungBild"

\end_inset

)
\end_layout

\begin_layout Standard
Die Methode ist sehr genau und daher für Skulpturen gut geeignet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/scanner-head-and-david-head-s.jpg
	width 63text%

\end_inset


\begin_inset Graphics
	filename img/david-classic-leftlight-s.jpg
	width 36text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:TriangulierungBild"

\end_inset

Triangulierungsmethode beim 
\begin_inset Quotes gld
\end_inset

The Digital Michelangelo
\begin_inset Quotes grd
\end_inset

 Projekt
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Passive Rekonstruktion
\end_layout

\begin_layout Standard
Unter passiver Rekonstruktion versteht man Methoden welche nicht aktiv eine
 Szene abtasten, sondern vorhandene photometrische Information(z.B Photos)
 nutzen um die Tiefe zu berechnen.
\end_layout

\begin_layout Standard
Das Stereo Verfahren ist eines der Ersten in diesem Feld.
 Man geht von 2 auf der x-Achse verschoben Bildern einer Szene aus.
 Nun gilt es Punktpaare zwischen den beiden Bilder zu finden.
 Um das zu vereinfachen sucht man nach einer Abbildung von Punkten aus Bild
 1 zu Bild 2.
 Aufgrund der Verschiebung der Bilder auf der x-Achse kann man durch Epipolargeo
metrie die Tiefe des Punkte berechnen.
\end_layout

\begin_layout Subsubsection
VisualSFM
\end_layout

\begin_layout Standard
-
\end_layout

\begin_layout Subsection
Dynamic Octree
\end_layout

\begin_layout Standard
Octrees sind eine Datenstruktur um dreidimensionale Daten hierarchisch zu
 untergliedern.
 Sie wurde 1980 von Donal Maegher
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle
\end_layout

\end_inset

 beschrieben.
 Octrees sind im dreidimensionalen das was im eindimensionalen Binarytrees
 oder im zweidimensionalen die Quadtrees sind.
\end_layout

\begin_layout Standard
Jeder Knoten repräsentiert einen Würfel welcher alle eingefügten 3D Punkte
 beinhaltet.
 Jeder innere Knoten besitzt immer 8 Kinder.
 Diese unterteilen den Raum des Knoten in 8 gleichgroße Octanten usw.
 (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Octree"

\end_inset

)
\end_layout

\begin_layout Standard
Die eigentlichen Punktdaten sind in den äußeren Knoten gespeichert.
 Äußeren Knoten können auch leer sein.
\end_layout

\begin_layout Standard
Der dynamische Octree unterstützt das inkrementelle Einfügen von Punkten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Octree2.svg
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Octree"

\end_inset

Schematische Darstellung eines Octrees
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Multiresolution Octree
\begin_inset CommandInset label
LatexCommand label
name "sub:Multiresolution-Octree"

\end_inset


\end_layout

\begin_layout Standard
Die Datenstruktur entstammt aus der Arbeit 
\begin_inset Quotes eld
\end_inset

Interactive Editing of Large Point Clouds
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Wand:2008:SSP:1363373.1363581"

\end_inset


\end_layout

\begin_layout Standard
Die Datenstruktur unterstützt einfügen, löschen und bietet unterschiedlich
 detaillierte Darstellungen des Ausgangsmodells.
 
\end_layout

\begin_layout Standard
Im folgendem wird die Datenstruktur vorgestellt.
\end_layout

\begin_layout Standard
Der Multiresolution Octree(MRT) kann als eine spezielle Form des Octree
 verstanden werden.
 Wie beim Octree enthalten die äußeren Knoten alle Punkte.
\end_layout

\begin_layout Standard
Die Tiefe ergibt sich aus der Eigenschaft das kein Blatt mehr als 
\begin_inset Formula $n_{max}$
\end_inset

 Punkte beinhalten darf.
 Ist 
\begin_inset Formula $n_{max}$
\end_inset

 nach einer Einfüge Operation überschritten wird das Kind geteilt und die
 bestehenden Punkte werden auf die 8 neuen Kinder verteilt.
\end_layout

\begin_layout Standard
Die inneren Knoten sollen eine vereinfachte bzw.
 gröbere Version ihrer Kinder liefern.
\end_layout

\begin_layout Standard
Dafür haben diese eine dreidimensionale Rasterung gespeichert.
 Das Raster unterteilt den Würfel in 
\begin_inset Formula $k^{3}$
\end_inset

 gleichgroße Rasterzellen (z.B.
 
\begin_inset Formula $k\text{=128}$
\end_inset

).
 Jeder Rasterzelle hat zusätzlich ein Gewicht und ein Farbe als RGB Wert
 gespeichert.
 Das Raster selbst ist nicht als einfaches Array gespeichert, sondern als
 Hashtabelle um Speicherplatz zu sparen.
 Auf diese Art werden nur die Zellen gespeichert welche Punkte enthalten.
 
\end_layout

\begin_layout Standard
Zellen mit hohem Gewicht werden beim rendern größer gezeichnet.
 Sobald ein weiterer Punkt in die gleiche Zelle fällt wird das Gewicht inkrement
iert.
 
\end_layout

\begin_layout Standard
Der Farbwert entspricht dem des zuerst hinzugefügten Punktes der Zelle.
 Als Koordinate wird der Wert der Hashfunktion benutzt.
\end_layout

\begin_layout Paragraph
Einfügen eines Punktes
\end_layout

\begin_layout Standard
Beim Einfügen können zwei Fälle auftreten.
\end_layout

\begin_layout Subparagraph
1.
 Fall : Der Punkt liegt außerhalb der Wurzel.
 
\end_layout

\begin_layout Standard
Nun muss die bestehende Wurzel so lange erweitert werden bis sie den neuen
 Punkt mit einschließt.
\end_layout

\begin_layout Standard
Die Größe der Wurzel verdoppelt sich dabei bei jedem Schritt.
\end_layout

\begin_layout Standard
Sobald der Punkt in der Wurzel liegt tritt der 2.
 Fall ein.
\end_layout

\begin_layout Subparagraph
2.
 Fall : Der Punkt liegt innerhalb der Wurzel
\end_layout

\begin_layout Standard
Zuerst wird der Punkt der Rasterung hinzugefügt.
 Sprich das Gewicht in der entsprechende Rasterzelle wird um 1 erhöht und
 die Farbe des Punkten wird gegebenenfalls gespeichert.
 Dann wird ermittelt in welchem der Kinder der Punkt liegt.
 Nun wird der Vorgang beim Kind wiederholt bis ein äußerer Knoten erreicht
 wird.
 Falls die maximale Anzahl Punkte 
\begin_inset Formula $n_{max}$
\end_inset

 überschritten wurde muss der Knoten gespalten werden.
 Alle bisher gespeicherten Punkte und der neue Punkt werden nun auf die
 neuen Kinder verteilt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/img-003.ppm
	width 100text%
	scaleBeforeRotation

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Schema der Rasterung
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/img-004.ppm
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schema nach einer Einfüge Operation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Verwandte Arbeiten
\end_layout

\begin_layout Standard
Das Interesse an der Darstellung von großen Punktwolken ist durch das Aufkommen
 von modernen 3D Scanner und der 3D Rekonstruktion in den letzten Jahrzehnt
 stark gewachsen.
 Durch den Anstieg der Leistungsfähigkeit von Tablets wurde schon einige
 Ansätze für die Darstellung von sehr großen Punktwolken gemacht.
 Allerdings kann keine bestehende Arbeit alle Anforderungen erfüllen.
\end_layout

\begin_layout Subsection
KiwiViewer
\end_layout

\begin_layout Standard
KiwiViewer 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.kiwiviewer.org/
\end_layout

\end_inset


\end_layout

\end_inset

 ist eine freie 'open-source' App zum erkunden von Punktwolken.
 Die App ist für Android sowie iOS verfügbar.
 Multi-Touch Gestensteuerung wird unterstützt.
 KiwiViewer bedient sich der 
\begin_inset Quotes eld
\end_inset

Point Cloud Library
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://pointclouds.org/
\end_layout

\end_inset


\end_layout

\end_inset

 für seine Kernfunktionen.
 Die Punktmenge wird entweder über eine SD-Karte, eMail oder URL geladen.
\end_layout

\begin_layout Paragraph

\emph on
Abgrenzung
\end_layout

\begin_layout Standard
Die App speichert die geladenen Punkte direkt auf dem Tablet.
 Modelle werden nicht vereinfacht.
 Daher treffen Modelle mit mehreren Millionen Punkten schnell an die Grenzen
 der GPU.
\end_layout

\begin_layout Subsection
QSplat Verfahren
\end_layout

\begin_layout Standard
Erste Vorschläge zur Darstellung von sehr großer Punktmengen wurden durch
 das QSplat 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2000:QMP:344779.344940"

\end_inset

 Verfahren gemacht.
 Die Punkteenge wird durch eine 'Multiresolution' Hierarchie auf Basis von
 'bounding spheres' modelliert.
 Abhängig von der Kameraposition wird die Struktur bis zu einer gewissen
 Tiefe (Detailstufe) durchlaufen.
 Das Verfahren kann modifiziert auch zum Streaming von Punktwolken genutzt
 werden 
\begin_inset CommandInset citation
LatexCommand cite
key "Rusinkiewicz:2001:SQV:364338.364350"

\end_inset

 .
 
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Für HD Displays ist der Algorithmus zu rechenintensiv weil die Berechnung
 pro Display Punkt von der CPU erledigt wird.
 
\end_layout

\begin_layout Subsection
Multiresolution Octree
\end_layout

\begin_layout Standard
Moderne Ansätze benutzen einen Multiresolution Octree 
\begin_inset CommandInset citation
LatexCommand cite
key "Wand:2008:SSP:1363373.1363581"

\end_inset

.
 Diese Datenstruktur speichert die Punkte in ihren äußeren Knoten.
 Die inneren Knoten beinhalten gröbere Präsentationen von ihren direkten
 Kindern.
\end_layout

\begin_layout Standard
Die Punktdaten werden 'out-of-core' verwaltet, also dynamisch auf die Festplatte
 ausgelagert sobald der RAM erschöpft ist.
 Die Datenstruktur bietet den Vorteil, das Punkte dynamisch hinzugefügt
 werden können.
 
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Das Paper beschreibt ein Verfahren für Desktop Systeme.
 Eigenarten von mobilen Geräten wie Netzwerkverkehr sind nicht berücksichtigt.
\end_layout

\begin_layout Subsection
Knn-Tree iOS
\end_layout

\begin_layout Standard
Eine weitere Möglichkeit ist ein Knn-Tree zu verwenden 
\begin_inset CommandInset citation
LatexCommand cite
key "VAST:VAST12:057-064"

\end_inset

.
 Allerdings mit der Beschränkung, dass die Punktmenge von Anfang an vollständig
 ist.
\end_layout

\begin_layout Standard
Diese Arbeit richtet sich besonders an die Darstellung auf mobilen Geräten.
 Die Datenstruktur selbst wird auf einem Server gespeichert.
 Knoten werden auf Anfrage eines Klienten übertragen.
\end_layout

\begin_layout Standard
Übertragende Knoten werden mit Hilfe eines LRU-Cache gespeichert.
 Die Implementierung erfolgte in C++ und OpenGl ES.
 Für die Netzwerkkommunikation wir 'http pipelining' sowie eine Wavletkompressio
n verwendet.
 
\end_layout

\begin_layout Paragraph
Abgrenzung
\end_layout

\begin_layout Standard
Die Datenstruktur ist nicht dynamisch, also die Menge der Punkte muss von
 Anfang an fest stehen.
 Implementierung erfolgte in C++ und für iOS.
 Die Datenstruktur bietet den Vorteil das sie eine geringe Tiefe besitzt.
\end_layout

\begin_layout Section
Frameworks und Formate
\end_layout

\begin_layout Standard
Im folgendem werden die Technologien, Begriffe und Frameworks vorgestellt
 welche in der Arbeit verwendet werden.
\end_layout

\begin_layout Subsection
Proxy Design Pattern
\begin_inset CommandInset label
LatexCommand label
name "sub:Proxy-Design-Pattern"

\end_inset


\end_layout

\begin_layout Standard
Bei einem Proxy(siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UML-Proxy-Pattern"

\end_inset

) 
\begin_inset CommandInset citation
LatexCommand citep
key "Gamma:1995:DPE:186897"

\end_inset

 handelt es sich um ein Objekt welches als eine Schnittstelle zu etwas anderem
 agiert.
 Zum Beispiel mit einer größeren Datei oder einer anderen teuren Ressource.
\end_layout

\begin_layout Standard
Ein klassisches Beispiel sind Platzhalter für Bilder, welche noch nicht
 fertig geladen wurden, auf Webseiten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/Proxy_pattern_diagram.svg
	width 50text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
UML Proxy Pattern
\begin_inset CommandInset label
LatexCommand label
name "fig:UML-Proxy-Pattern"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Representational state transfer
\end_layout

\begin_layout Standard
Representational state transfer(REST) ist ein Programmierparadigma für Service
 orientierte verteilte Systeme.
 REST wurde im Jahr 2000 von Roy Fielding in seiner Doktorarbeit 
\begin_inset CommandInset citation
LatexCommand cite
key "Fielding:2000:ASD:932295"

\end_inset

 wie folgt beschrieben.
 REST definiert sich über eine Menge von Beschränkungen bei der Kommunikation
 von Komponenten.
 Das prominentest Beispiel ist das World Wide Web.
\end_layout

\begin_layout Standard
Die Beschränkungen werden im folgendem kurz vorgestellt.
\end_layout

\begin_layout Subsubsection*
Client-Server Model
\end_layout

\begin_layout Standard
Nach Andrews 
\begin_inset CommandInset citation
LatexCommand cite
key "Andrews:1991:PPI:103162.103164"

\end_inset

 ist der Client ein auslösender Prozess und der Server ein reagierender
 Prozess.
 Clienten stellen Anfragen auf welcher der Server reagiert.
 Der Klient kann entscheiden wann er mit dem Server interagiert.
 Der Server wiederum muss auf Anfragen warten und dann auf diese reagieren.
 Oft ist ein Server auf nicht endender Prozess welcher auf mehrere Clienten
 reagiert.
\end_layout

\begin_layout Subsubsection*
Zustandslosigkeit
\end_layout

\begin_layout Standard
Jede Anfrage vom Clienten muss alle Informationen enthalten welche Notwendig
 sind um die Anfrage zu verarbeiten.
 Des weiteren darf kein gespeicherter Kontext auf dem Server vorliegen auf
 welchen Bezug genommen wird.
 Alle Zustände werden auf dem Klienten gespeichert.
\end_layout

\begin_layout Subsubsection*
Caching
\end_layout

\begin_layout Standard
Server Antworten müssen implizit oder explizit als cachebar gekennzeichnet
 sein.
 Die Idee ist den Netzwerkverkehr effizienter zu machen.
 Bemerkenswert dabei ist das dadurch ganze Interaktionen wegfallen können.
\end_layout

\begin_layout Subsubsection*
Einheitliche Schnittstelle
\end_layout

\begin_layout Standard
Ein integraler Bestandteil einer REST Architektur ist eine einheitliche
 Schnittstelle.
 Das vereinfacht die System Architektur und die Sichtbarkeit von Interaktionen
 ist verbessert.
 Sie ist durch 4 weitere Eigenschaften beschrieben.
\end_layout

\begin_layout Subparagraph
Adressierbarkeit von Ressourcen
\end_layout

\begin_layout Standard
Jede Information, die über einen URI kenntlich gemacht wurde, wird als Ressource
 gekennzeichnet.
 Die Ressource selbst wie in einer Repräsentation übertragen welche sich
 von der internen Repräsentation unterscheidet.
 Jeder REST-konforme Dienst hat eine eindeutige Adresse, den Uniform Resource
 Locator (URL).
\end_layout

\begin_layout Subparagraph
Repräsentationen zur Veränderung von Ressourcen
\end_layout

\begin_layout Standard
Wenn ein Client die Repräsentation einer Ressource besitzt mit seinen Metadaten,
 reicht dies aus um die Ressource zu modifizieren bzw zu löschen.
 
\end_layout

\begin_layout Subparagraph
Self-descriptive messages
\end_layout

\begin_layout Standard
Jede Nachricht enthält beschreibt wie seine Informationen zu verarbeitet
 sind.
 Z.B durch Angabe seine Internet Media Types(MIME-Type)
\end_layout

\begin_layout Subparagraph
„Hypermedia as the Engine of Application State
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Bei „Hypermedia as the Engine of Application State
\begin_inset Quotes grd
\end_inset

 HATEOAS navigiert der Client einer REST-Schnittstelle ausschließlich über
 URLs, welche vom Server bereitgestellt werden.
 Abhängig von der gewählten Repräsentation geschieht die Bereitstellung
 der URIs über Hypermedia.
 Abstrakt betrachtet stellen HATEOAS-konforme REST-Services einen endlichen
 Automaten dar, dessen Zustandsveränderungen durch die Navigation mittels
 der bereitgestellten URIs erfolgt.
 Durch HATEOAS ist eine lose Bindung gewährleistet und die Schnittstelle
 kann verändert werden.
 
\end_layout

\begin_layout Subsubsection*
Mehrschichtige Systeme
\end_layout

\begin_layout Standard
Der Klient soll lediglich die Schnittstelle kennen.
 Schichten dahinter bleiben ihm verborgen.
\end_layout

\begin_layout Subsection
Google Protocol Buffers
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bei Google Protocol Buffers
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://developers.google.com/protocol-buffers/
\end_layout

\end_inset


\end_layout

\end_inset

 handelt es sich um eine Plattform unabhängige Datenstruktur von Google.
 Die Datenstruktur wird in einem einheitlichen Format festgelegt.
 Nun kann für jede unterstützte Sprache Klassen generiert werden welche
 die Daten (de)serializieren.
 Das macht es möglich Clienten in anderen Sprachen zu schreiben.
 Ausserdem verringert es den Overhead merklich im Vergleich zu JSON oder
 XML.
 Nachteilig ist das die übertragenden Daten nicht ohne weiteres für einen
 Menschen lesbar sind.
\end_layout

\begin_layout Subsection
Open Graphics Library for Embedded Systems(OpenGL ES)
\end_layout

\begin_layout Standard
OpenGL Es ist eine sprachenunabhängige Programmierschnittstelle zur Entwicklung
 von 3D-Computergrafik.
 Die Spezifikation beschreibt eine vereinfachte Version der OpenGL-Spezifikation
, welche sich besonders für den Einsatz im Bereich von eingebetteten Systemen
 eignet.
 
\begin_inset CommandInset citation
LatexCommand cite
key "OpenGLESWiki"

\end_inset


\end_layout

\begin_layout Subsection
NanoHTTPD
\begin_inset CommandInset label
LatexCommand label
name "sub:NanoHTTPD"

\end_inset


\end_layout

\begin_layout Standard
NanoHTTPD
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/NanoHttpd/nanohttpd
\end_layout

\end_inset


\end_layout

\end_inset

 bezeichnet sich selbst als einen schlanker HTTP Server welche darauf ausgericht
et ist sich einfach in bestehende Anwendungen einbetten zu lassen.
\end_layout

\begin_layout Standard
Das Project ist Open Source und wird aktiv auf github entwickelt.
\end_layout

\begin_layout Subsection
la4j
\end_layout

\begin_layout Standard
La4j 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://la4j.org/
\end_layout

\end_inset


\end_layout

\end_inset

ist eine offene Java Bibliothek für Lineare Algebra.
\end_layout

\begin_layout Subsection
DEFLATE
\end_layout

\begin_layout Standard
Bei DEFLATE 
\begin_inset CommandInset citation
LatexCommand citep
key "Deutsch:1996:DCD:RFC1951"

\end_inset

 handelt es sich um einen Kompression Algorithmus von Phil Katz aus dem
 Jahre 1993.
 Er kombiniert die die Kompressions Algorithmen LZ77 oder LZSS mit einer
 Huffman Kodierung.
 Der Algorithmus zeichnet such durch eine solide Kompression in kurzer Zeit
 aus.
 Der Algorithmus findet zum Beispiel im .png Format Anwendung.
\end_layout

\begin_layout Subsection
Volley 
\begin_inset CommandInset label
LatexCommand label
name "sub:Volley"

\end_inset


\end_layout

\begin_layout Standard
Bei Volley 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://developer.android.com/training/volley/index.html
\end_layout

\end_inset


\end_layout

\end_inset

 handelt es sich um ein HTTP Bibliothek zum Verwalten von Netzwerkanfragen.
 Volley bietet automatisches koordinieren von Anfragen.
 Es ermöglicht mehrere neben läufige Netzwerkverbindungen, Anfragen Priorisierun
g und einiges mehr.
\end_layout

\begin_layout Standard
Die Bibliothek ist frei und wird unter diesem Link 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://android.googlesource.com/platform/frameworks/volley
\end_layout

\end_inset


\end_layout

\end_inset

 entwickelt.
\end_layout

\begin_layout Chapter
Gewählter Lösungsansatz
\end_layout

\begin_layout Standard
Mobile Geräte verfügen über begrenzte Ressourcen was Rechenleistung und
 Speicher angeht.
 Punktwolken mit mehr als einer Million Punkte bringen die GPU schnell an
 Ihre Grenzen.
 Daher wurde ein Ansatz gewählt der es ermöglicht präzise Punkte auszuwählen.
 Darin unterscheiden wir zwischen 2 Dimension.
 Einmal die Sichtbarkeit und zum anderen die Detailstufe der Punkte.
 Zum ermitteln der Punkt unter diesen Kriterien kommt ein Multi-Resolution
 Octree(siehe Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Multiresolution-Octree"

\end_inset

) zum Einsatz.
 Dadurch wird die GPU effizient eingesetzt.
 
\end_layout

\begin_layout Standard
Die Defizite beim Speicher werden durch eine Client-Server Architektur ausgeglic
hen.
 Das eigentliche Model wird von einem Server verwaltet.
 Der Mobile Client hat selber nur den momentan benötigten Satz Punkte gespeicher
t.
 Um Netzwerkverkehr niedrig zu halten werden die Punkte von Client in einem
 Cache nach dem 
\begin_inset Quotes gld
\end_inset

Last Recently Used
\begin_inset Quotes grd
\end_inset

 Prinzip gespeichert.
 Zum Rendern werden die Punkte als 
\begin_inset Quotes gld
\end_inset

vertex buffer object
\begin_inset Quotes grd
\end_inset

 in den Speicher der GPU geschrieben und anschließend gezeichnet.
\end_layout

\begin_layout Standard
Also Programmiersprache wurde Java gewählt aufgrund ihres guten Kompromisses
 aus Portabilität und Performance.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Datenfluss Diagram
\end_layout

\end_inset


\end_layout

\begin_layout Section
Architektur
\end_layout

\begin_layout Subsection
Server
\end_layout

\begin_layout Standard
Der Server hat drei Aufgaben.
 Zum ersten erstellt er aus gegebenen Punkten einen MRT.
 Seine zweite Aufgabe ist es aus den Knoten des MRT auf Anfrage zu verschicken
 und als letztes einen eine Proxy Objekt (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Proxy-Design-Pattern"

\end_inset

) des MRTs an die Klienten zu verteilen.
\end_layout

\begin_layout Standard
Zur Interaktion stellt der Server ein Interface auf Basis des HTTP Protokolls
 bereit.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Warum nicht normaler Socketverkehr
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Multi Resolution Tree
\end_layout

\begin_layout Standard
Der MultiResolution Tree besteht aus 4 Klassen (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Multiresolution-Tree-UML"

\end_inset

).
 Die Klasse 
\begin_inset Quotes eld
\end_inset

MultiResolutionTree
\begin_inset Quotes erd
\end_inset

 dient als Schnittstelle für alle äußeren Komponenten.
 Dadurch ist eine sinnvolle Kapselung gewährleistet.
 Sie beherbergt einen Zeiger auf den Wurzelknoten des MRT.
 Des weiteren legt sie einen Index von den Knoten an um schnellen Zugriff
 zu ermöglichen.
 Zusätzlich existiert einer Factory Methode zum erstellen von Google Protocol
 Buffer Objekten.
\end_layout

\begin_layout Standard
Die Implementierung des MRT ist analog zu der Beschreibung in Kapitel
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Multiresolution-Octree"

\end_inset

.
 Jeder Knoten besitzt eine ID.
 Diese sind die Koordinaten seines absoluten Mittelpunkts.
 Erwähnenswert sind die Entscheidungen bei der Raster Klasse.
 Die Rasterwerte sind in einer interne DefaultHashMap vermerkt.
 Diese bildet einen dreidimensionalen Vektor auf Farbwerte und Gewicht ab.
 Bei einer DefaultHashMap werden bei Abfrage von nicht existierender Einträge
 Standartwerte zurück gegeben.
 Dadurch wird im Vergleich zu einem 
\begin_inset Formula $n^{3}$
\end_inset

Array Speicherplatz gespart.
 Die eigentliche Rastervorgang wird durch die folgende Hashfunktion erreicht.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
H(p)=(\left\lfloor \frac{x(p)}{cellLength}\right\rfloor ,\left\lfloor \frac{y(p)}{cellLength}\right\rfloor ,\left\lfloor \frac{z(p)}{cellLength}\right\rfloor )
\]

\end_inset


\end_layout

\begin_layout Standard
wobei die Koordinate von 
\begin_inset Formula $p$
\end_inset

 relativ zu Ursprung des Würfel ist.
 Die Variable
\begin_inset Formula $cellLength$
\end_inset

 entspricht der Länge einer Gitterzelle.
 Also:
\begin_inset Formula 
\[
cellLength=\frac{cube.length}{k}
\]

\end_inset


\end_layout

\begin_layout Standard
Einfach gesprochen werden die Koordinaten auf ein Vielfaches der 
\begin_inset Formula $cellLength$
\end_inset

 abgerundet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/MultiResolutionTreeUML.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Multiresolution-Tree-UML"

\end_inset

Multiresolution Tree UML
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit schnelle Zugriffe bei Anfragen auf die entsprechenden Knoten bzw.
 Punkte möglich sind existiert eine Hashmap als Index.
 Dieser bildet Ids auf die entsprechenden Knoten ab.
 Der Index wird in nach einer festen Anzahl Einfüge Operationen aktualisiert.
\end_layout

\begin_layout Subsubsection
RESTful API
\end_layout

\begin_layout Standard
Die API wurde mit Hilfe des NanoHTTPD Frameworks (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:NanoHTTPD"

\end_inset

) implementiert.
 NanoHTTPD wurde ausgewählt weil es schlank und einfach ist.
\end_layout

\begin_layout Standard
Prinzipiell wird bei jeder Anfrage eine Fallunterscheidung an dem 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 Parameter gemacht.
 Die Anfragen werden im folgenden vorgestellt.
\end_layout

\begin_layout Subsubsection
MRT-Proxy Anfrage
\begin_inset CommandInset label
LatexCommand label
name "sub:MRT-Proxy-Anfrage"

\end_inset


\end_layout

\begin_layout Standard
Da die Ermittlung gebrauchten Punkte auf dem Klienten geschieht muss auch
 dieser in Kenntnis über die Struktur der MRTs sein.
 Aus diesem Grund Stellt der Server ein MRT-Proxy zur Verfügung.
 Der MRT-Proxy ist im Prinzip der gespeicherte Multiresolution Octree allerdings
 haben seine Knoten keine Punkte bzw Rasterung gespeichert, sondern nur
 Ids um beim Server die entsprechenden Punkte anzufragen.
 Diese können entweder Original Punkte aus Blättern sein oder Punkte aus
 der Rasterung.
 
\end_layout

\begin_layout Standard
Zum versendet wird aus der Datenstruktur ein Protocol Buffer Objekt erstellt.
 Diese kann dann problemlos serialisiert werden.
 Das Protocol Buffer Objekt ist wie folgt definiert.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package DataAccesLayer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

option java_outer_classname = "MultiResTreeProtos";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

message MRTree{
\end_layout

\begin_layout Plain Layout

	required MRNode root = 1;
\end_layout

\begin_layout Plain Layout

	message MRNode {
\end_layout

\begin_layout Plain Layout

		required string id = 1;    
\end_layout

\begin_layout Plain Layout

		repeated double center = 2 [packed=true];         
\end_layout

\begin_layout Plain Layout

		required double cellLength = 3;         
\end_layout

\begin_layout Plain Layout

		required int32 pointCount = 4;         
\end_layout

\begin_layout Plain Layout

		required bool isLeaf = 5;         
\end_layout

\begin_layout Plain Layout

		repeated MRNode octant = 6;     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Punktanfrage
\end_layout

\begin_layout Standard
Der 2.
 Typ Anfragen liefert Punkte an den Klienten aus.
 Bei dieser Anfrage wird vom Klienten immer eine Id als Parameter mitgesendet.
 Diese Id passt auf einen Knoten des MRT.
\end_layout

\begin_layout Standard
Falls es sich um ein inneren Knoten handelt wird die Rasterung zu einer
 Liste von Punkten exportiert.
 Beim einem Blatt wird lediglich auch die vorhandene Punktliste zugegriffen.
 
\end_layout

\begin_layout Standard
Der Server greift über die MultiResolutionTree Klasse auf den entsprechende
 Knoten zu und generiert ein Protocol Buffer Objekt.
 Die Spezifikation des Objektes lautet:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package DataAccesLayer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

option java_outer_classname = "RasterProtos";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

message Raster{     
\end_layout

\begin_layout Plain Layout

	repeated Point3DRGB sample = 1;
\end_layout

\begin_layout Plain Layout

	message Point3DRGB{         
\end_layout

\begin_layout Plain Layout

		repeated float position = 1;         
\end_layout

\begin_layout Plain Layout

		repeated float color = 2;         
\end_layout

\begin_layout Plain Layout

		required int32 size = 3;     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es handelt sich also um eine Liste von Punkten mit Positions-, Farb- und
 einer Gewichtswerten (size).
\end_layout

\begin_layout Standard
Alle Protocol Buffer Objekte werden bevor sie über das Netzwerk versendet
 werden serialisiert und durch den DEFLATE Algorithmus komprimiert, um den
 Netzwerkverkehr möglichst niedrig zu halten.
 
\end_layout

\begin_layout Subsection
Client
\end_layout

\begin_layout Standard
Bei dem Klienten handelt es um eine Android Anwendung.
 Der Klient ist verantwortlich für das Darstellen der Punktwolke und reagiert
 auf Eingaben des Users.
\end_layout

\begin_layout Standard
Der Client verfolgt eine eventbasierte Architektur.
 Wird vom Nutzer eine Translation(2-Finger Geste) oder Rotation(Slide Geste)
 an dem Punktmodel ausgeführt kann sich die Menge der zu zeichnenden Punkte
 ändern.
\end_layout

\begin_layout Standard
Die Menge der momentan zu zeichnenden Punkte wird im folgenden als aktive
 Punkte bezeichnet.
 Die Knoten welche die aktiven Punkte beinhalten werden als aktive Knoten
 bezeichnet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename uml/Client.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Client UML
\begin_inset CommandInset label
LatexCommand label
name "fig:Client-UML"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
UML Diagram
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Scene Klasse
\end_layout

\begin_layout Standard
Die Scene Klasse siehe(Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Client-UML"

\end_inset

)ist die Schnittstelle für alle Rendering relevanten Aktionen.
 Nutzereingaben werden von dieser Klasse entgegengenommen und entsprechend
 weitergeleitet.
 Die Kamera mit Projektions Matrix ist hier gespeichert.
\end_layout

\begin_layout Standard
Alle zu zeichnenden Objekte werden in modelList gespeichert.
 Bei Aufruf der drawScene Methode wird die draw Methode von jedem Element
 der Liste ausgelöst.
\end_layout

\begin_layout Subsubsection
RemotePointClusterGL
\end_layout

\begin_layout Standard
RemotePointClusterGL kümmert sich um das Ermitteln und Speichern aktiver
 Punkte im MRT, dafür hat sie einen Verweise auf den Cache und dem MRT-Proxy.
 Desweiteren greift die Klasse auf den DataLayer zu um entweder nach dem
 MRT Proxy zu fragen oder nach neuen Punkten.
\end_layout

\begin_layout Subsubsection
Ermittlung der aktiven Knoten
\end_layout

\begin_layout Standard
Bevor etwas gerendert werden kann, muss bestimmt werden, welche Punkte sichtbar
 sind und in welcher Detailstufe man diese darstellen möchte.
 Dafür ist der MRT-Proxy nötig, daher wird dieser beim Start der App angefordert
 (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:MRT-Proxy-Anfrage"

\end_inset

).
\end_layout

\begin_layout Standard
Nach jeder Kamerabewegung kann sich die Menge der aktiven Punkte ändern,
 dann wird update cache ausgeführt.
 Rotiert der Nutzer etwa die Szene wird der MRT-Proxy mit Hilfe des folgenden
 Algorithmus traversiert um die Ids von aktiven Knoten zu ermitteln.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public List<String> getIdsViewDependent(){         
\end_layout

\begin_layout Plain Layout

	List<String> ids = new LinkedList<>();         
\end_layout

\begin_layout Plain Layout

	_getIdsViewDependent(root, ids);         
\end_layout

\begin_layout Plain Layout

	return ids;     V
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private void _getIdsViewDependent(OctreeNodeGL currentNode, List<String>
 ids) {      
\end_layout

\begin_layout Plain Layout

	if ((currentNode.isLeaf || 
\end_layout

\begin_layout Plain Layout

	currentNode.getDetailFactor(this.owner) < DETAIL_THRESHOLD)){           
  
\end_layout

\begin_layout Plain Layout

		ids.add(currentNode.id);             
\end_layout

\begin_layout Plain Layout

		return;         
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	for (OctreeNodeGL node : currentNode.octants ) {             
\end_layout

\begin_layout Plain Layout

		if (node.isVisible(owner) && node.pointCount > 0)         
\end_layout

\begin_layout Plain Layout

			_getIdsViewDependent(node, ids);
\end_layout

\begin_layout Plain Layout

	}     
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Salop gesagt besuche alle sichtbaren Knoten solange bis entweder ein Blatt
 erreicht ist oder eine ausreichende Detailstufe.
\end_layout

\begin_layout Standard
Der Vorgang findet in eigenem Thread statt damit der Nutzer nicht warten
 muss um neue Eingabe zu machen.
 Für die Verwaltung weiterer Threads kommt die von Java mitgelieferte ThreadPool
Executor Klasse zum Einsatz.
\end_layout

\begin_layout Standard
Nachdem alle nötigen Knoten festgestellt wurden, wird geprüft ob sich diese
 schon im Cache befinden.
 Falls nicht müssen diese vom Server angefordert werden.
\end_layout

\begin_layout Subsubsection
DataAcessLayer Klasse
\end_layout

\begin_layout Standard
Zum asynchronen nachladen von Punkten kommt das 
\begin_inset Quotes gld
\end_inset

Volley Framework
\begin_inset Quotes grd
\end_inset

.
 (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Volley"

\end_inset

).
 Das Framework stellt ein RequestQueue zur Verfügung.
 Volley ermöglicht es die Callback Funktion beim Eintreffen einer Anfrage
 zu überschreiben, um eigene Logik zu definieren.
 Sobald ein Anfrage empfangen wurde wird diese entpackt und deserialsiert.
 Anschliessend wird wenn es sich um Punktdaten handel dem Cache hinzugefügt
 oder bei einem Proxy Objekt wird das alte überschrieben.
\end_layout

\begin_layout Subsubsection
Rendering
\end_layout

\begin_layout Standard
Das Rendering ist mit OpenGL realisiert.
 Jeder Knoten im Cache zeigt auf einem Buffer gefüllt mir Positions-, Farb-
 und Gewichtswerten.
 Beim zeichen werden alle aktiven Knoten ,welche im Cache sind, gezeichnet.
 Dabei wird jeder Buffer einmalig als Vertex Buffer Object(VBO) in den Speicher
 der GPU geschrieben.
 Das verbessert die Performance enorm weil so nicht in jedem Frame die Daten
 neu übertragen werden müssen.
\end_layout

\begin_layout Standard
-
\end_layout

\begin_layout Chapter
Experimente und Auswertung
\end_layout

\begin_layout Standard
-
\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "sources"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
